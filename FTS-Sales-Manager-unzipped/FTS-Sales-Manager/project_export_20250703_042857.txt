================================================================================
PROJECT STRUCTURE
================================================================================

PROJECT_ROOT/
├── app.py
├── export_project_improved.py
├── fts_sales_cache.db
├── project_analysis.json
├── project_analysis.txt
├── project_analyzer.py
├── project_export_20250703_042857.txt
├── requirements.txt
├── cache/
│   └── dropdown_cache.json
├── config/
│   ├── login_config.py
│   ├── modern_color_palettes.py
│   └── settings.yaml
├── controllers/
│   └── app_controller.py
├── core/
│   ├── airtable_dropdown_manager.py
│   ├── airtable_manager.py
│   ├── app_state_manager.py
│   ├── config_manager.py
│   ├── constants.py
│   ├── db_manager.py
│   ├── event_system.py
│   ├── language_manager.py
│   ├── logger.py
│   ├── permissions.py
│   ├── session_manager.py
│   ├── state_manager.py
│   ├── theme_color_manager.py
│   ├── theme_manager.py
│   ├── user_manager.py
│   ├── core/security/
│   │   ├── encryption.py
│   │   ├── rate_limiter.py
│   │   └── two_factor_auth.py
├── data/
│   └── login_cache.json
├── drafts/
├── locales/
│   ├── ar.yaml
│   └── en.yaml
├── logs/
│   ├── app.log
│   ├── logs/logs/
├── resources/
│   ├── company_logo.png
│   └── fts_icon.ico
├── utils/
│   ├── async_operations.py
│   ├── error_handler.py
│   ├── image_utils.py
│   ├── login_visual_effects.py
│   ├── threading_utils.py
│   ├── validators.py
│   └── window_manager.py
├── views/
│   ├── add_edit_window.py
│   ├── login_window.py
│   ├── main_window.py
│   ├── splash_screen.py
│   ├── views/components/
│   │   ├── autocomplete_entry.py
│   │   ├── combobox.py
│   │   ├── data_table.py
│   │   ├── dropdown_dialogs.py
│   │   ├── header.py
│   │   ├── menu_bar.py
│   │   ├── quick_test.py
│   │   ├── searchable_combobox.py
│   │   ├── sidebar.py
│   │   ├── status_bar.py
│   │   └── toolbar.py

================================================================================
FILE CONTENTS
================================================================================


============================================================
FILE: app.py
SIZE: 6242 characters
============================================================

# -*- coding: utf-8 -*-
"""
app.py

نقطة البداية (entry point) لتشغيل تطبيق FTS Sales Manager.
"""

# تتبع الأخطاء وإدارتها
import sys
import traceback
import warnings
import traceback

# تعطيل تحذير "invalid command name"
warnings.filterwarnings("ignore", message="invalid command name")

# محاولة تفعيل faulthandler فقط إذا كان مدعوماً
try:
    import faulthandler
    # التحقق من أننا لسنا في IDLE
    if hasattr(sys.stderr, 'fileno') and hasattr(sys.stderr.fileno, '__call__'):
        try:
            sys.stderr.fileno()
            faulthandler.enable()
        except:
            # إذا فشل، نتجاهل الخطأ
            pass
except ImportError:
    # إذا لم يكن faulthandler متاحاً
    pass

# معالج أخطاء عام لـ Tkinter
def handle_tk_error(*args):
    import traceback
    import sys

    try:
        # الحالة الأولى: tkinter يرسل (exc_type, exc_value, exc_tb)
        if isinstance(args, tuple) and len(args) == 3 and isinstance(args[1], BaseException):
            exc_type, exc_value, exc_tb = args

        # الحالة الثانية: tkinter يرسل كائن استثناء واحد فقط
        elif isinstance(args, tuple) and len(args) == 1 and isinstance(args[0], BaseException):
            exc_type = type(args[0])
            exc_value = args[0]
            exc_tb = args[0].__traceback__ if hasattr(args[0], "__traceback__") else None

        # الحالة الثالثة: (widget, exc_type, exc_value, exc_tb)
        elif isinstance(args, tuple) and len(args) == 4 and isinstance(args[2], BaseException):
            _, exc_type, exc_value, exc_tb = args

        else:
            print("📦 محتوى args غير المتوقع:", args, file=sys.stderr)
            raise ValueError("تنسيق غير معروف لمعالجة الخطأ")

        traceback.print_exception(exc_type, exc_value, exc_tb)

    except Exception as e:
        print(f"⚠️ فشل أثناء معالجة الاستثناء (داخليًا): {e}", file=sys.stderr)

# معالج أخطاء شامل
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    # استيراد logger هنا لتجنب مشاكل الاستيراد المبكر
    from core.logger import logger
    logger.critical("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))
    traceback.print_exception(exc_type, exc_value, exc_traceback)

sys.excepthook = handle_exception

# باقي الواردات
import os
import tkinter as tk

# إخفاء نافذة tk الافتراضية فوراً بعد استيراد tkinter
if tk._default_root:
    tk._default_root.withdraw()

from core.config_manager import ConfigManager
from core.db_manager import DatabaseManager
from core.airtable_manager import AirtableManager, AirtableModel
from core.user_manager import UserManager
from core.logger import logger
from controllers.app_controller import AppController
from views.splash_screen import SplashScreen

# ربط معالج الأخطاء بـ Tkinter
tk.Tk.report_callback_exception = handle_tk_error


def hide_default_tk_window():
    """إخفاء أي نافذة tk افتراضية"""
    try:
        # إخفاء النافذة الافتراضية إذا كانت موجودة
        if tk._default_root:
            tk._default_root.withdraw()
            tk._default_root.overrideredirect(True)

        # البحث عن أي نوافذ tk مفتوحة وإخفاؤها
        for widget in tk._default_root.winfo_children() if tk._default_root else []:
            if widget.winfo_class() == 'Tk' and widget.title() == 'tk':
                widget.withdraw()
    except:
        pass


def main() -> None:
    """
    الدالة الرئيسية لتشغيل التطبيق.
    """
    # إنشاء نافذة أساسية مخفية لـ CTkToplevel
    root = tk.Tk()
    root.withdraw()  # إخفاء النافذة فوراً
    root.overrideredirect(True)  # إزالة من شريط المهام

    # إخفاء أي نافذة tk افتراضية أخرى
    hide_default_tk_window()

    # 1. عرض شاشة التحميل لمدة قصيرة
    try:
        splash = SplashScreen(duration=2000, master=root)  # تمرير النافذة الأساسية
        splash.update()
    except Exception as e:
        logger.warning(f"Failed to show splash screen: {e}", exc_info=True)

    # إخفاء النافذة مرة أخرى بعد شاشة التحميل
    hide_default_tk_window()

    # 2. تهيئة ConfigManager
    config_mgr = ConfigManager(config_path=os.path.join("config", "settings.yaml"))

    # 3. تهيئة DatabaseManager (SQLite للكاش المحلي)
    db_mgr = DatabaseManager(db_path="fts_sales_cache.db")

    # 4. تهيئة AirtableModel للمستخدمين
    users_table = config_mgr.get("airtable_users_table", "Users")
    airtable_users = AirtableModel(
        config_manager=config_mgr,
        db_manager=db_mgr,
        table_name=users_table
    )

    # 5. تهيئة AirtableModel للحجوزات
    booking_table = config_mgr.get("airtable_booking_table", "List V2")
    airtable_booking = AirtableModel(
        config_manager=config_mgr,
        db_manager=db_mgr,
        table_name=booking_table
    )

    # 6. تهيئة UserManager (يستخدم airtable_users فقط)
    user_mgr = UserManager(airtable_model=airtable_users, db_manager=db_mgr)

    # 7. تشغيل AppController مع كلا النموذجين
    try:
        app_ctrl = AppController(
            config_mgr=config_mgr,
            db_mgr=db_mgr,
            airtable_users=airtable_users,
            airtable_booking=airtable_booking,
            user_mgr=user_mgr
        )
        app_ctrl.run()
    except Exception as e:
        logger.error(f"Unexpected error in main loop: {e}", exc_info=True)
        raise
    finally:
        # تنظيف النافذة الأساسية
        try:
            if 'root' in locals() and root:
                root.destroy()
        except:
            pass


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"Fatal error on startup: {e}", exc_info=True)
        # عرض رسالة خطأ للمستخدم
        try:
            import tkinter as tk
            from tkinter import messagebox

            # إنشاء نافذة مؤقتة لرسالة الخطأ
            error_root = tk.Tk()
            error_root.withdraw()  # إخفاء النافذة الرئيسية

            messagebox.showerror(
                "خطأ في بدء التطبيق",
                f"حدث خطأ أثناء تشغيل التطبيق:\n\n{str(e)}\n\nيرجى التحقق من السجلات للمزيد من التفاصيل."
            )

            error_root.destroy()
        except:
            pass
        sys.exit(1)

============================================================
FILE: export_project_improved.py
SIZE: 3849 characters
============================================================

import os
import datetime

output_file = f"project_export_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

# المجلدات المستثناة
EXCLUDED_DIRS = {'.git', '__pycache__', 'venv', '.venv', 'node_modules', '.idea', '.vscode'}
# الامتدادات المستثناة
EXCLUDED_EXTENSIONS = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.dylib', '.exe'}

with open(output_file, 'w', encoding='utf-8') as out:
    # كتابة هيكل المشروع
    out.write("=" * 80 + "\n")
    out.write("PROJECT STRUCTURE\n")
    out.write("=" * 80 + "\n\n")

    # طريقة محسنة لرسم الشجرة
    for root, dirs, files in os.walk('.'):
        # استثناء المجلدات غير المرغوبة
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        # حساب المستوى بشكل صحيح
        if root == '.':
            level = 0
            display_path = 'PROJECT_ROOT/'
        else:
            # إزالة ./ أو .\ من البداية
            relative_path = os.path.relpath(root, '.')
            level = relative_path.count(os.sep) + 1
            display_path = relative_path.replace(os.sep, '/') + '/'

        # رسم المسار الهرمي
        indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
        out.write(f'{indent}{display_path}\n')

        # رسم الملفات
        for i, file in enumerate(files):
            # استثناء الملفات المخفية والملفات المترجمة
            if file.startswith('.') or any(file.endswith(ext) for ext in EXCLUDED_EXTENSIONS):
                continue

            # تحديد الرمز المناسب (آخر ملف أم لا)
            is_last = (i == len(files) - 1) and not dirs
            file_indent = '│   ' * level + ('└── ' if is_last else '├── ')
            out.write(f'{file_indent}{file}\n')

    # كتابة محتوى الملفات
    out.write("\n" + "=" * 80 + "\n")
    out.write("FILE CONTENTS\n")
    out.write("=" * 80 + "\n")

    # امتدادات الملفات المراد قراءتها
    READ_EXTENSIONS = {'.py', '.json', '.txt', '.md', '.yml', '.yaml', '.js', '.html', '.css',
                      '.jsx', '.tsx', '.ts', '.vue', '.sql', '.sh', '.bat', '.env.example'}

    files_read = 0
    errors = []

    for root, dirs, files in os.walk('.'):
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        for file in files:
            # التحقق من الامتداد
            if any(file.endswith(ext) for ext in READ_EXTENSIONS):
                filepath = os.path.join(root, file)
                relative_path = os.path.relpath(filepath, '.')

                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()

                    out.write(f"\n\n{'='*60}\n")
                    out.write(f"FILE: {relative_path}\n")
                    out.write(f"SIZE: {len(content)} characters\n")
                    out.write(f"{'='*60}\n\n")
                    out.write(content)
                    files_read += 1

                except Exception as e:
                    error_msg = f"Error reading {relative_path}: {e}"
                    out.write(f"\n\n{'='*60}\n")
                    out.write(f"ERROR: {error_msg}\n")
                    out.write(f"{'='*60}\n")
                    errors.append(error_msg)

    # ملخص التصدير
    out.write(f"\n\n{'='*80}\n")
    out.write("EXPORT SUMMARY\n")
    out.write(f"{'='*80}\n")
    out.write(f"Total files read: {files_read}\n")
    out.write(f"Errors encountered: {len(errors)}\n")
    out.write(f"Export date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

    if errors:
        out.write("\nErrors details:\n")
        for error in errors:
            out.write(f"  - {error}\n")

print(f"✅ تم تصدير المشروع إلى: {output_file}")
print(f"📁 عدد الملفات المقروءة: {files_read}")
if errors:
    print(f"⚠️  عدد الأخطاء: {len(errors)}")

============================================================
FILE: project_analysis.json
SIZE: 35687 characters
============================================================

{
  "files": {
    "app": {
      "path": "app.py",
      "size": 6242,
      "lines": 201,
      "local_imports": [
        "core.user_manager",
        "core.config_manager",
        "core.airtable_manager",
        "views.splash_screen",
        "core.logger",
        "controllers.app_controller",
        "core.db_manager"
      ],
      "external_imports": [
        "os",
        "warnings",
        "traceback",
        "tkinter",
        "sys",
        "faulthandler"
      ]
    },
    "project_analyzer": {
      "path": "project_analyzer.py",
      "size": 15466,
      "lines": 401,
      "local_imports": [],
      "external_imports": [
        "os",
        "ast",
        "re",
        "pathlib",
        "typing",
        "json",
        "collections",
        "argparse"
      ]
    },
    "config.login_config": {
      "path": "config\\login_config.py",
      "size": 6796,
      "lines": 217,
      "local_imports": [],
      "external_imports": []
    },
    "config.modern_color_palettes": {
      "path": "config\\modern_color_palettes.py",
      "size": 5867,
      "lines": 202,
      "local_imports": [],
      "external_imports": []
    },
    "controllers.app_controller": {
      "path": "controllers\\app_controller.py",
      "size": 29214,
      "lines": 787,
      "local_imports": [
        "utils.threading_utils",
        "core.user_manager",
        "views.login_window",
        "views.main_window",
        "core.config_manager",
        "core.airtable_manager",
        "views.add_edit_window",
        "core.theme_manager",
        "core.logger",
        "core.language_manager",
        "core.db_manager",
        "core.airtable_dropdown_manager"
      ],
      "external_imports": [
        "typing",
        "threading",
        "datetime",
        "json",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "core.airtable_dropdown_manager": {
      "path": "core\\airtable_dropdown_manager.py",
      "size": 24117,
      "lines": 602,
      "local_imports": [
        "core.airtable_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "logging",
        "time",
        "concurrent.futures"
      ]
    },
    "core.airtable_manager": {
      "path": "core\\airtable_manager.py",
      "size": 28862,
      "lines": 774,
      "local_imports": [],
      "external_imports": [
        "os",
        "re",
        "typing",
        "threading",
        "datetime",
        "json",
        "requests",
        "logging",
        "time",
        "concurrent.futures"
      ]
    },
    "core.app_state_manager": {
      "path": "core\\app_state_manager.py",
      "size": 14840,
      "lines": 403,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "threading",
        "datetime",
        "enum",
        "time"
      ]
    },
    "core.config_manager": {
      "path": "core\\config_manager.py",
      "size": 18851,
      "lines": 499,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "dotenv",
        "typing",
        "yaml"
      ]
    },
    "core.constants": {
      "path": "core\\constants.py",
      "size": 8556,
      "lines": 295,
      "local_imports": [],
      "external_imports": [
        "typing",
        "enum"
      ]
    },
    "core.db_manager": {
      "path": "core\\db_manager.py",
      "size": 10852,
      "lines": 261,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "sqlite3",
        "typing",
        "threading"
      ]
    },
    "core.event_system": {
      "path": "core\\event_system.py",
      "size": 1015,
      "lines": 31,
      "local_imports": [],
      "external_imports": [
        "queue",
        "typing",
        "threading",
        "datetime"
      ]
    },
    "core.language_manager": {
      "path": "core\\language_manager.py",
      "size": 6614,
      "lines": 166,
      "local_imports": [
        "core.logger",
        "core.config_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "yaml"
      ]
    },
    "core.logger": {
      "path": "core\\logger.py",
      "size": 2118,
      "lines": 62,
      "local_imports": [],
      "external_imports": [
        "os",
        "logging",
        "logging.handlers"
      ]
    },
    "core.permissions": {
      "path": "core\\permissions.py",
      "size": 5411,
      "lines": 176,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "tkinter",
        "functools"
      ]
    },
    "core.session_manager": {
      "path": "core\\session_manager.py",
      "size": 14093,
      "lines": 411,
      "local_imports": [
        "core.security.encryption",
        "core.logger"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "secrets",
        "json",
        "time"
      ]
    },
    "core.state_manager": {
      "path": "core\\state_manager.py",
      "size": 2557,
      "lines": 75,
      "local_imports": [],
      "external_imports": [
        "dataclasses",
        "typing",
        "threading",
        "datetime"
      ]
    },
    "core.theme_color_manager": {
      "path": "core\\theme_color_manager.py",
      "size": 12242,
      "lines": 320,
      "local_imports": [
        "config.modern_color_palettes",
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    },
    "core.theme_manager": {
      "path": "core\\theme_manager.py",
      "size": 25669,
      "lines": 562,
      "local_imports": [
        "core.logger",
        "core.config_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "json",
        "tkinter",
        "customtkinter"
      ]
    },
    "core.user_manager": {
      "path": "core\\user_manager.py",
      "size": 14899,
      "lines": 387,
      "local_imports": [
        "core.airtable_manager",
        "core.db_manager",
        "core.logger"
      ],
      "external_imports": [
        "hmac",
        "base64",
        "typing",
        "secrets",
        "datetime",
        "hashlib"
      ]
    },
    "utils.async_operations": {
      "path": "utils\\async_operations.py",
      "size": 736,
      "lines": 21,
      "local_imports": [],
      "external_imports": [
        "threading",
        "concurrent.futures"
      ]
    },
    "utils.error_handler": {
      "path": "utils\\error_handler.py",
      "size": 1884,
      "lines": 49,
      "local_imports": [
        "utils.window_manager"
      ],
      "external_imports": [
        "typing",
        "logging",
        "traceback",
        "tkinter",
        "functools"
      ]
    },
    "utils.image_utils": {
      "path": "utils\\image_utils.py",
      "size": 8538,
      "lines": 297,
      "local_imports": [],
      "external_imports": [
        "os",
        "PIL",
        "typing",
        "logging",
        "tkinter",
        "customtkinter",
        "sys"
      ]
    },
    "utils.login_visual_effects": {
      "path": "utils\\login_visual_effects.py",
      "size": 11479,
      "lines": 356,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "math",
        "customtkinter",
        "time"
      ]
    },
    "utils.threading_utils": {
      "path": "utils\\threading_utils.py",
      "size": 5475,
      "lines": 178,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "tkinter",
        "queue",
        "typing",
        "threading"
      ]
    },
    "utils.validators": {
      "path": "utils\\validators.py",
      "size": 12546,
      "lines": 405,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "re",
        "typing",
        "datetime",
        "string"
      ]
    },
    "utils.window_manager": {
      "path": "utils\\window_manager.py",
      "size": 48019,
      "lines": 1208,
      "local_imports": [],
      "external_imports": [
        "ctypes",
        "platform",
        "weakref",
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.add_edit_window": {
      "path": "views\\add_edit_window.py",
      "size": 35739,
      "lines": 861,
      "local_imports": [
        "core.theme_color_manager",
        "core.logger",
        "core.language_manager",
        "views.components.combobox",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "tkcalendar",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.login_window": {
      "path": "views\\login_window.py",
      "size": 91114,
      "lines": 2369,
      "local_imports": [
        "core.constants",
        "core.theme_color_manager",
        "core.security.encryption",
        "utils.validators",
        "core.security.rate_limiter",
        "config.login_config",
        "core.logger",
        "core.theme_manager",
        "core.language_manager",
        "config.modern_color_palettes",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "ctypes",
        "platform",
        "re",
        "typing",
        "threading",
        "secrets",
        "json",
        "datetime",
        "string",
        "tkinter",
        "customtkinter",
        "time",
        "hashlib",
        "queue",
        "functools"
      ]
    },
    "views.main_window": {
      "path": "views\\main_window.py",
      "size": 55631,
      "lines": 1310,
      "local_imports": [
        "views.components.data_table",
        "core.theme_color_manager",
        "views.components.header",
        "utils.image_utils",
        "core.state_manager",
        "core.event_system",
        "core.permissions",
        "views.components.status_bar",
        "core.logger",
        "core.theme_manager",
        "core.language_manager",
        "views.components.toolbar",
        "views.components.menu_bar",
        "views.components.sidebar",
        "utils.async_operations",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "platform",
        "typing",
        "threading",
        "datetime",
        "weakref",
        "tkinter",
        "customtkinter",
        "functools"
      ]
    },
    "views.splash_screen": {
      "path": "views\\splash_screen.py",
      "size": 11100,
      "lines": 363,
      "local_imports": [],
      "external_imports": [
        "os",
        "PIL",
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "core.security.encryption": {
      "path": "core\\security\\encryption.py",
      "size": 6042,
      "lines": 210,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "base64",
        "typing",
        "secrets",
        "json",
        "hashlib",
        "cryptography.fernet"
      ]
    },
    "core.security.rate_limiter": {
      "path": "core\\security\\rate_limiter.py",
      "size": 10258,
      "lines": 311,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "collections",
        "time"
      ]
    },
    "core.security.two_factor_auth": {
      "path": "core\\security\\two_factor_auth.py",
      "size": 11664,
      "lines": 403,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "io",
        "pyotp",
        "base64",
        "typing",
        "secrets",
        "datetime",
        "json",
        "qrcode",
        "time",
        "hashlib"
      ]
    },
    "venv.Lib.site-packages.pip.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\__main__.py",
      "size": 854,
      "lines": 24,
      "local_imports": [],
      "external_imports": [
        "os",
        "pip._internal.cli.main",
        "sys"
      ]
    },
    "venv.Lib.site-packages.pip._internal.main": {
      "path": "venv\\Lib\\site-packages\\pip\\_internal\\main.py",
      "size": 340,
      "lines": 12,
      "local_imports": [],
      "external_imports": [
        "typing",
        "pip._internal.utils.entrypoints"
      ]
    },
    "venv.Lib.site-packages.pip._internal.cli.main": {
      "path": "venv\\Lib\\site-packages\\pip\\_internal\\cli\\main.py",
      "size": 2817,
      "lines": 80,
      "local_imports": [],
      "external_imports": [
        "os",
        "pip._internal.cli.autocompletion",
        "pip._internal.cli.main_parser",
        "pip._internal.exceptions",
        "typing",
        "pip._internal.utils",
        "logging",
        "warnings",
        "sys",
        "locale",
        "pip._internal.commands"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.certifi.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\certifi\\__main__.py",
      "size": 255,
      "lines": 12,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.certifi",
        "argparse"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.distro.distro": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\distro\\distro.py",
      "size": 49430,
      "lines": 1403,
      "local_imports": [],
      "external_imports": [
        "os",
        "re",
        "typing",
        "json",
        "logging",
        "subprocess",
        "warnings",
        "argparse",
        "sys",
        "shlex",
        "functools"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.distro.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\distro\\__main__.py",
      "size": 64,
      "lines": 4,
      "local_imports": [
        "venv.Lib.site-packages.pip._vendor.distro.distro"
      ],
      "external_imports": []
    },
    "venv.Lib.site-packages.pip._vendor.platformdirs.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\platformdirs\\__main__.py",
      "size": 1505,
      "lines": 55,
      "local_imports": [],
      "external_imports": [
        "__future__",
        "pip._vendor.platformdirs"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.pygments.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\pygments\\__main__.py",
      "size": 353,
      "lines": 17,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.pygments.cmdline",
        "sys"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.rich.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\rich\\__main__.py",
      "size": 8319,
      "lines": 273,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.rich.markdown",
        "pip._vendor.rich.console",
        "io",
        "pip._vendor.rich.style",
        "pip._vendor.rich.pretty",
        "pip._vendor.rich.segment",
        "pip._vendor.rich.measure",
        "pip._vendor.rich",
        "pip._vendor.rich.panel",
        "pip._vendor.rich.color",
        "pip._vendor.rich.syntax",
        "pip._vendor.rich.text",
        "time",
        "colorsys",
        "pip._vendor.rich.table"
      ]
    },
    "views.components.autocomplete_entry": {
      "path": "views\\components\\autocomplete_entry.py",
      "size": 19262,
      "lines": 616,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "enum",
        "time",
        "random",
        "dataclasses"
      ]
    },
    "views.components.combobox": {
      "path": "views\\components\\combobox.py",
      "size": 70009,
      "lines": 1855,
      "local_imports": [],
      "external_imports": [
        "typing",
        "traceback",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.components.data_table": {
      "path": "views\\components\\data_table.py",
      "size": 20968,
      "lines": 614,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "datetime",
        "typing",
        "tkinter",
        "customtkinter"
      ]
    },
    "views.components.dropdown_dialogs": {
      "path": "views\\components\\dropdown_dialogs.py",
      "size": 54108,
      "lines": 1558,
      "local_imports": [
        "core.logger",
        "core.theme_manager",
        "core.config_manager",
        "core.language_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "datetime",
        "json",
        "tkinter",
        "customtkinter",
        "webbrowser"
      ]
    },
    "views.components.header": {
      "path": "views\\components\\header.py",
      "size": 28565,
      "lines": 867,
      "local_imports": [
        "views.components.dropdown_dialogs",
        "core.logger",
        "core.language_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "weakref",
        "datetime",
        "tkinter",
        "customtkinter",
        "sys",
        "webbrowser"
      ]
    },
    "views.components.menu_bar": {
      "path": "views\\components\\menu_bar.py",
      "size": 11466,
      "lines": 371,
      "local_imports": [
        "core.logger",
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "tkinter"
      ]
    },
    "views.components.quick_test": {
      "path": "views\\components\\quick_test.py",
      "size": 2201,
      "lines": 84,
      "local_imports": [],
      "external_imports": [
        "enhanced_searchable_combobox",
        "customtkinter"
      ]
    },
    "views.components.searchable_combobox": {
      "path": "views\\components\\searchable_combobox.py",
      "size": 20729,
      "lines": 643,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time",
        "random"
      ]
    },
    "views.components.sidebar": {
      "path": "views\\components\\sidebar.py",
      "size": 19652,
      "lines": 601,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    },
    "views.components.status_bar": {
      "path": "views\\components\\status_bar.py",
      "size": 20837,
      "lines": 600,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "datetime",
        "typing",
        "threading",
        "customtkinter"
      ]
    },
    "views.components.toolbar": {
      "path": "views\\components\\toolbar.py",
      "size": 18926,
      "lines": 520,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    }
  },
  "dependencies": {
    "app": [
      "core.user_manager",
      "core.config_manager",
      "core.airtable_manager",
      "views.splash_screen",
      "core.logger",
      "controllers.app_controller",
      "core.db_manager"
    ],
    "controllers.app_controller": [
      "utils.threading_utils",
      "core.user_manager",
      "views.main_window",
      "core.config_manager",
      "core.airtable_manager",
      "views.add_edit_window",
      "core.theme_manager",
      "core.logger",
      "views.login_window",
      "core.language_manager",
      "core.db_manager",
      "core.airtable_dropdown_manager"
    ],
    "core.airtable_dropdown_manager": [
      "core.airtable_manager"
    ],
    "core.app_state_manager": [
      "core.logger"
    ],
    "core.config_manager": [
      "core.logger"
    ],
    "core.db_manager": [
      "core.logger"
    ],
    "core.language_manager": [
      "core.logger",
      "core.config_manager"
    ],
    "core.permissions": [
      "core.logger"
    ],
    "core.session_manager": [
      "core.security.encryption",
      "core.logger"
    ],
    "core.theme_color_manager": [
      "config.modern_color_palettes",
      "core.logger"
    ],
    "core.theme_manager": [
      "core.logger",
      "core.config_manager"
    ],
    "core.user_manager": [
      "core.airtable_manager",
      "core.db_manager",
      "core.logger"
    ],
    "utils.error_handler": [
      "utils.window_manager"
    ],
    "utils.threading_utils": [
      "core.logger"
    ],
    "utils.validators": [
      "core.logger"
    ],
    "views.add_edit_window": [
      "core.theme_color_manager",
      "core.logger",
      "core.language_manager",
      "views.components.combobox",
      "utils.window_manager"
    ],
    "views.login_window": [
      "core.constants",
      "core.theme_color_manager",
      "core.security.encryption",
      "utils.validators",
      "config.login_config",
      "config.modern_color_palettes",
      "core.logger",
      "core.theme_manager",
      "core.language_manager",
      "core.security.rate_limiter",
      "utils.window_manager"
    ],
    "views.main_window": [
      "views.components.data_table",
      "core.theme_color_manager",
      "utils.window_manager",
      "utils.image_utils",
      "core.state_manager",
      "core.event_system",
      "core.permissions",
      "views.components.status_bar",
      "core.logger",
      "core.theme_manager",
      "core.language_manager",
      "views.components.toolbar",
      "views.components.menu_bar",
      "views.components.sidebar",
      "utils.async_operations",
      "views.components.header"
    ],
    "core.security.encryption": [
      "core.logger"
    ],
    "core.security.rate_limiter": [
      "core.logger"
    ],
    "core.security.two_factor_auth": [
      "core.logger"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.__main__": [
      "venv.Lib.site-packages.pip._vendor.distro.distro"
    ],
    "views.components.data_table": [
      "core.language_manager"
    ],
    "views.components.dropdown_dialogs": [
      "core.theme_manager",
      "core.logger",
      "core.config_manager",
      "core.language_manager"
    ],
    "views.components.header": [
      "views.components.dropdown_dialogs",
      "core.logger",
      "core.language_manager"
    ],
    "views.components.menu_bar": [
      "core.logger",
      "core.language_manager"
    ],
    "views.components.sidebar": [
      "core.language_manager"
    ],
    "views.components.status_bar": [
      "core.language_manager"
    ],
    "views.components.toolbar": [
      "core.language_manager"
    ]
  },
  "reverse_dependencies": {
    "core.user_manager": [
      "app",
      "controllers.app_controller"
    ],
    "core.config_manager": [
      "app",
      "views.components.dropdown_dialogs",
      "core.theme_manager",
      "controllers.app_controller",
      "core.language_manager"
    ],
    "core.airtable_manager": [
      "app",
      "core.user_manager",
      "core.airtable_dropdown_manager",
      "controllers.app_controller"
    ],
    "views.splash_screen": [
      "app"
    ],
    "core.logger": [
      "utils.threading_utils",
      "core.user_manager",
      "core.theme_color_manager",
      "app",
      "core.config_manager",
      "views.add_edit_window",
      "core.permissions",
      "core.security.two_factor_auth",
      "core.language_manager",
      "core.security.rate_limiter",
      "core.db_manager",
      "views.components.dropdown_dialogs",
      "utils.validators",
      "core.app_state_manager",
      "views.components.header",
      "core.security.encryption",
      "views.components.menu_bar",
      "controllers.app_controller",
      "views.login_window",
      "views.main_window",
      "core.theme_manager",
      "core.session_manager"
    ],
    "controllers.app_controller": [
      "app"
    ],
    "core.db_manager": [
      "app",
      "core.user_manager",
      "controllers.app_controller"
    ],
    "utils.threading_utils": [
      "controllers.app_controller"
    ],
    "views.login_window": [
      "controllers.app_controller"
    ],
    "views.main_window": [
      "controllers.app_controller"
    ],
    "views.add_edit_window": [
      "controllers.app_controller"
    ],
    "core.theme_manager": [
      "views.components.dropdown_dialogs",
      "views.main_window",
      "controllers.app_controller",
      "views.login_window"
    ],
    "core.language_manager": [
      "views.components.data_table",
      "views.components.dropdown_dialogs",
      "views.main_window",
      "views.add_edit_window",
      "views.components.menu_bar",
      "views.components.status_bar",
      "controllers.app_controller",
      "views.login_window",
      "views.components.toolbar",
      "views.components.sidebar",
      "views.components.header"
    ],
    "core.airtable_dropdown_manager": [
      "controllers.app_controller"
    ],
    "core.security.encryption": [
      "views.login_window",
      "core.session_manager"
    ],
    "config.modern_color_palettes": [
      "core.theme_color_manager",
      "views.login_window"
    ],
    "utils.window_manager": [
      "views.add_edit_window",
      "utils.error_handler",
      "views.main_window",
      "views.login_window"
    ],
    "core.theme_color_manager": [
      "views.add_edit_window",
      "views.main_window",
      "views.login_window"
    ],
    "views.components.combobox": [
      "views.add_edit_window"
    ],
    "core.constants": [
      "views.login_window"
    ],
    "utils.validators": [
      "views.login_window"
    ],
    "core.security.rate_limiter": [
      "views.login_window"
    ],
    "config.login_config": [
      "views.login_window"
    ],
    "views.components.data_table": [
      "views.main_window"
    ],
    "views.components.header": [
      "views.main_window"
    ],
    "utils.image_utils": [
      "views.main_window"
    ],
    "core.state_manager": [
      "views.main_window"
    ],
    "core.event_system": [
      "views.main_window"
    ],
    "core.permissions": [
      "views.main_window"
    ],
    "views.components.status_bar": [
      "views.main_window"
    ],
    "views.components.toolbar": [
      "views.main_window"
    ],
    "views.components.menu_bar": [
      "views.main_window"
    ],
    "views.components.sidebar": [
      "views.main_window"
    ],
    "utils.async_operations": [
      "views.main_window"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.distro": [
      "venv.Lib.site-packages.pip._vendor.distro.__main__"
    ],
    "views.components.dropdown_dialogs": [
      "views.components.header"
    ]
  },
  "external_imports": {
    "app": [
      "os",
      "warnings",
      "traceback",
      "tkinter",
      "sys",
      "faulthandler"
    ],
    "project_analyzer": [
      "os",
      "ast",
      "re",
      "pathlib",
      "typing",
      "json",
      "collections",
      "argparse"
    ],
    "config.login_config": [],
    "config.modern_color_palettes": [],
    "controllers.app_controller": [
      "typing",
      "threading",
      "datetime",
      "json",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "core.airtable_dropdown_manager": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "logging",
      "time",
      "concurrent.futures"
    ],
    "core.airtable_manager": [
      "os",
      "re",
      "typing",
      "threading",
      "datetime",
      "json",
      "requests",
      "logging",
      "time",
      "concurrent.futures"
    ],
    "core.app_state_manager": [
      "typing",
      "threading",
      "datetime",
      "enum",
      "time"
    ],
    "core.config_manager": [
      "os",
      "dotenv",
      "typing",
      "yaml"
    ],
    "core.constants": [
      "typing",
      "enum"
    ],
    "core.db_manager": [
      "sqlite3",
      "typing",
      "threading"
    ],
    "core.event_system": [
      "queue",
      "typing",
      "threading",
      "datetime"
    ],
    "core.language_manager": [
      "os",
      "typing",
      "yaml"
    ],
    "core.logger": [
      "os",
      "logging",
      "logging.handlers"
    ],
    "core.permissions": [
      "typing",
      "tkinter",
      "functools"
    ],
    "core.session_manager": [
      "os",
      "typing",
      "threading",
      "datetime",
      "secrets",
      "json",
      "time"
    ],
    "core.state_manager": [
      "dataclasses",
      "typing",
      "threading",
      "datetime"
    ],
    "core.theme_color_manager": [
      "typing",
      "customtkinter"
    ],
    "core.theme_manager": [
      "os",
      "typing",
      "json",
      "tkinter",
      "customtkinter"
    ],
    "core.user_manager": [
      "hmac",
      "base64",
      "typing",
      "secrets",
      "datetime",
      "hashlib"
    ],
    "utils.async_operations": [
      "threading",
      "concurrent.futures"
    ],
    "utils.error_handler": [
      "typing",
      "logging",
      "traceback",
      "tkinter",
      "functools"
    ],
    "utils.image_utils": [
      "os",
      "PIL",
      "typing",
      "logging",
      "tkinter",
      "customtkinter",
      "sys"
    ],
    "utils.login_visual_effects": [
      "typing",
      "threading",
      "math",
      "customtkinter",
      "time"
    ],
    "utils.threading_utils": [
      "tkinter",
      "queue",
      "typing",
      "threading"
    ],
    "utils.validators": [
      "re",
      "typing",
      "datetime",
      "string"
    ],
    "utils.window_manager": [
      "ctypes",
      "platform",
      "weakref",
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.add_edit_window": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "tkcalendar",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.login_window": [
      "os",
      "ctypes",
      "platform",
      "re",
      "typing",
      "threading",
      "secrets",
      "json",
      "datetime",
      "string",
      "tkinter",
      "customtkinter",
      "time",
      "hashlib",
      "queue",
      "functools"
    ],
    "views.main_window": [
      "os",
      "platform",
      "typing",
      "threading",
      "datetime",
      "weakref",
      "tkinter",
      "customtkinter",
      "functools"
    ],
    "views.splash_screen": [
      "os",
      "PIL",
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "core.security.encryption": [
      "os",
      "base64",
      "typing",
      "secrets",
      "json",
      "hashlib",
      "cryptography.fernet"
    ],
    "core.security.rate_limiter": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "collections",
      "time"
    ],
    "core.security.two_factor_auth": [
      "io",
      "pyotp",
      "base64",
      "typing",
      "secrets",
      "datetime",
      "json",
      "qrcode",
      "time",
      "hashlib"
    ],
    "venv.Lib.site-packages.pip.__main__": [
      "os",
      "pip._internal.cli.main",
      "sys"
    ],
    "venv.Lib.site-packages.pip._internal.main": [
      "typing",
      "pip._internal.utils.entrypoints"
    ],
    "venv.Lib.site-packages.pip._internal.cli.main": [
      "os",
      "pip._internal.cli.autocompletion",
      "pip._internal.cli.main_parser",
      "pip._internal.exceptions",
      "typing",
      "pip._internal.utils",
      "logging",
      "warnings",
      "sys",
      "locale",
      "pip._internal.commands"
    ],
    "venv.Lib.site-packages.pip._vendor.certifi.__main__": [
      "pip._vendor.certifi",
      "argparse"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.distro": [
      "os",
      "re",
      "typing",
      "json",
      "logging",
      "subprocess",
      "warnings",
      "argparse",
      "sys",
      "shlex",
      "functools"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.__main__": [],
    "venv.Lib.site-packages.pip._vendor.platformdirs.__main__": [
      "__future__",
      "pip._vendor.platformdirs"
    ],
    "venv.Lib.site-packages.pip._vendor.pygments.__main__": [
      "pip._vendor.pygments.cmdline",
      "sys"
    ],
    "venv.Lib.site-packages.pip._vendor.rich.__main__": [
      "pip._vendor.rich.markdown",
      "pip._vendor.rich.console",
      "io",
      "pip._vendor.rich.style",
      "pip._vendor.rich.pretty",
      "pip._vendor.rich.segment",
      "pip._vendor.rich.measure",
      "pip._vendor.rich",
      "pip._vendor.rich.panel",
      "pip._vendor.rich.color",
      "pip._vendor.rich.syntax",
      "pip._vendor.rich.text",
      "time",
      "colorsys",
      "pip._vendor.rich.table"
    ],
    "views.components.autocomplete_entry": [
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "enum",
      "time",
      "random",
      "dataclasses"
    ],
    "views.components.combobox": [
      "typing",
      "traceback",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.components.data_table": [
      "datetime",
      "typing",
      "tkinter",
      "customtkinter"
    ],
    "views.components.dropdown_dialogs": [
      "os",
      "typing",
      "datetime",
      "json",
      "tkinter",
      "customtkinter",
      "webbrowser"
    ],
    "views.components.header": [
      "os",
      "typing",
      "weakref",
      "datetime",
      "tkinter",
      "customtkinter",
      "sys",
      "webbrowser"
    ],
    "views.components.menu_bar": [
      "typing",
      "tkinter"
    ],
    "views.components.quick_test": [
      "enhanced_searchable_combobox",
      "customtkinter"
    ],
    "views.components.searchable_combobox": [
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time",
      "random"
    ],
    "views.components.sidebar": [
      "typing",
      "customtkinter"
    ],
    "views.components.status_bar": [
      "datetime",
      "typing",
      "threading",
      "customtkinter"
    ],
    "views.components.toolbar": [
      "typing",
      "customtkinter"
    ]
  },
  "statistics": {
    "total_files": 54,
    "total_lines": 25382,
    "total_size": 915166,
    "circular_dependencies": [],
    "most_imported": [
      [
        "core.logger",
        22
      ],
      [
        "core.language_manager",
        11
      ],
      [
        "core.config_manager",
        5
      ],
      [
        "core.airtable_manager",
        4
      ],
      [
        "core.theme_manager",
        4
      ],
      [
        "utils.window_manager",
        4
      ],
      [
        "core.db_manager",
        3
      ],
      [
        "core.theme_color_manager",
        3
      ],
      [
        "core.user_manager",
        2
      ],
      [
        "core.security.encryption",
        2
      ]
    ],
    "most_importing": [
      [
        "views.main_window",
        16
      ],
      [
        "controllers.app_controller",
        12
      ],
      [
        "views.login_window",
        11
      ],
      [
        "app",
        7
      ],
      [
        "views.add_edit_window",
        5
      ],
      [
        "views.components.dropdown_dialogs",
        4
      ],
      [
        "core.user_manager",
        3
      ],
      [
        "views.components.header",
        3
      ],
      [
        "core.language_manager",
        2
      ],
      [
        "core.session_manager",
        2
      ]
    ]
  }
}

============================================================
FILE: project_analysis.txt
SIZE: 3750 characters
============================================================

============================================================
📊 تقرير تحليل المشروع
============================================================

📈 الإحصائيات العامة:
  • عدد الملفات: 54
  • إجمالي الأسطر: 25,382
  • إجمالي الحجم: 915,166 حرف

🔗 أكثر الوحدات استدعاءً:
  • core.logger: 22 استدعاء
  • core.language_manager: 11 استدعاء
  • core.config_manager: 5 استدعاء
  • core.airtable_manager: 4 استدعاء
  • core.theme_manager: 4 استدعاء
  • utils.window_manager: 4 استدعاء
  • core.db_manager: 3 استدعاء
  • core.theme_color_manager: 3 استدعاء
  • core.user_manager: 2 استدعاء
  • core.security.encryption: 2 استدعاء

📤 الوحدات التي تستدعي أكثر وحدات:
  • views.main_window: يستدعي 16 وحدة
  • controllers.app_controller: يستدعي 12 وحدة
  • views.login_window: يستدعي 11 وحدة
  • app: يستدعي 7 وحدة
  • views.add_edit_window: يستدعي 5 وحدة
  • views.components.dropdown_dialogs: يستدعي 4 وحدة
  • core.user_manager: يستدعي 3 وحدة
  • views.components.header: يستدعي 3 وحدة
  • core.language_manager: يستدعي 2 وحدة
  • core.session_manager: يستدعي 2 وحدة

✅ لا توجد اعتماديات دائرية

🌳 شجرة اعتماديات الملف الرئيسي (app):
├── app
  ├── controllers.app_controller
    ├── controllers.app_controller
      ├── core.airtable_dropdown_manager
        ├── core.airtable_dropdown_manager
          └── core.airtable_manager
      ├── core.airtable_manager
      ├── core.config_manager
        ├── core.config_manager
          └── core.logger
      ├── core.db_manager
        ├── core.db_manager
          └── core.logger
      ├── core.language_manager
        ├── core.language_manager
          ├── core.config_manager
          └── core.logger
      ├── core.logger
      ├── core.theme_manager
        ├── core.theme_manager
          ├── core.config_manager
          └── core.logger
      ├── core.user_manager
        ├── core.user_manager
          ├── core.airtable_manager
          ├── core.db_manager
          └── core.logger
      ├── utils.threading_utils
        ├── utils.threading_utils
          └── core.logger
      ├── views.add_edit_window
        ├── views.add_edit_window
          ├── core.language_manager
          ├── core.logger
          ├── core.theme_color_manager
          ├── utils.window_manager
          └── views.components.combobox
      ├── views.login_window
        ├── views.login_window
          ├── config.login_config
          ├── config.modern_color_palettes
          ├── core.constants
          ├── core.language_manager
          ├── core.logger
          ├── core.security.encryption
          ├── core.security.rate_limiter
          ├── core.theme_color_manager
          ├── core.theme_manager
          ├── utils.validators
          └── utils.window_manager
      └── views.main_window
        ├── views.main_window
          ├── core.event_system
          ├── core.language_manager
          ├── core.logger
          ├── core.permissions
          ├── core.state_manager
          ├── core.theme_color_manager
          ├── core.theme_manager
          ├── utils.async_operations
          ├── utils.image_utils
          ├── utils.window_manager
          ├── views.components.data_table
          ├── views.components.header
          ├── views.components.menu_bar
          ├── views.components.sidebar
          ├── views.components.status_bar
          └── views.components.toolbar
  ├── core.airtable_manager
  ├── core.config_manager
    ├── core.config_manager
      └── core.logger
  ├── core.db_manager
    ├── core.db_manager
      └── core.logger
  ├── core.logger
  ├── core.user_manager
    ├── core.user_manager
      ├── core.airtable_manager
      ├── core.db_manager
        ├── core.db_manager
          └── core.logger
      └── core.logger
  └── views.splash_screen


============================================================
FILE: project_analyzer.py
SIZE: 15466 characters
============================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Project File Dependency Analyzer
يحلل ملفات المشروع ويرسم شجرة الاستدعاءات والاعتماديات
"""

import os
import ast
import json
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple
from collections import defaultdict, deque
import argparse


class ProjectAnalyzer:
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.files_info = {}
        self.dependencies = defaultdict(set)
        self.reverse_dependencies = defaultdict(set)
        self.external_imports = defaultdict(set)

    def find_python_files(self) -> List[Path]:
        """البحث عن جميع ملفات Python في المشروع"""
        python_files = []
        for file_path in self.project_root.rglob("*.py"):
            if not any(part.startswith('.') for part in file_path.parts):
                python_files.append(file_path)
        return python_files

    def get_relative_module_name(self, file_path: Path) -> str:
        """تحويل مسار الملف إلى اسم وحدة نسبي"""
        relative_path = file_path.relative_to(self.project_root)
        module_parts = list(relative_path.parts[:-1])  # المجلدات
        filename = relative_path.stem

        if filename != "__init__":
            module_parts.append(filename)

        return ".".join(module_parts) if module_parts else filename

    def parse_imports(self, file_content: str, current_module: str) -> Tuple[Set[str], Set[str]]:
        """استخراج الاستدعاءات من محتوى الملف"""
        local_imports = set()
        external_imports = set()

        try:
            tree = ast.parse(file_content)

            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        module_name = alias.name
                        if self.is_local_import(module_name):
                            local_imports.add(module_name)
                        else:
                            external_imports.add(module_name)

                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        module_name = node.module
                        if node.level > 0:  # relative import
                            # معالجة الاستدعاءات النسبية
                            resolved_module = self.resolve_relative_import(
                                current_module, module_name, node.level
                            )
                            if resolved_module:
                                local_imports.add(resolved_module)
                        else:
                            if self.is_local_import(module_name):
                                local_imports.add(module_name)
                            else:
                                external_imports.add(module_name)

        except SyntaxError as e:
            print(f"خطأ في تحليل الملف {current_module}: {e}")

        return local_imports, external_imports

    def is_local_import(self, module_name: str) -> bool:
        """تحديد ما إذا كان الاستدعاء محلي أم خارجي"""
        # قائمة بالمكتبات الخارجية الشائعة
        external_modules = {
            'os', 'sys', 'json', 'ast', 're', 'pathlib', 'typing',
            'collections', 'datetime', 'time', 'logging', 'sqlite3',
            'tkinter', 'threading', 'asyncio', 'urllib', 'http',
            'pandas', 'numpy', 'matplotlib', 'seaborn', 'requests',
            'flask', 'django', 'fastapi', 'aiohttp', 'sqlalchemy',
            'pytest', 'unittest', 'mock', 'cryptography', 'PIL',
            'cv2', 'tensorflow', 'torch', 'sklearn', 'scipy'
        }

        # التحقق من الجذر الأول للوحدة
        root_module = module_name.split('.')[0]

        # إذا كان في قائمة المكتبات الخارجية
        if root_module in external_modules:
            return False

        # التحقق من وجود الملف في المشروع
        possible_paths = [
            self.project_root / f"{module_name.replace('.', '/')}.py",
            self.project_root / f"{module_name.replace('.', '/')}/__init__.py"
        ]

        return any(path.exists() for path in possible_paths)

    def resolve_relative_import(self, current_module: str, import_module: str, level: int) -> str:
        """حل الاستدعاءات النسبية"""
        if not current_module:
            return None

        current_parts = current_module.split('.')

        # إزالة المستويات بناءً على عدد النقاط
        for _ in range(level):
            if current_parts:
                current_parts.pop()

        if import_module:
            return '.'.join(current_parts + [import_module])
        else:
            return '.'.join(current_parts) if current_parts else None

    def analyze_file(self, file_path: Path):
        """تحليل ملف واحد"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            module_name = self.get_relative_module_name(file_path)
            local_imports, external_imports = self.parse_imports(content, module_name)

            # تخزين معلومات الملف
            self.files_info[module_name] = {
                'path': str(file_path),
                'size': len(content),
                'lines': len(content.splitlines()),
                'local_imports': list(local_imports),
                'external_imports': list(external_imports)
            }

            # إضافة الاعتماديات
            for imported_module in local_imports:
                self.dependencies[module_name].add(imported_module)
                self.reverse_dependencies[imported_module].add(module_name)

            self.external_imports[module_name] = external_imports

        except Exception as e:
            print(f"خطأ في تحليل الملف {file_path}: {e}")

    def analyze_project(self):
        """تحليل المشروع كاملاً"""
        print("🔍 البحث عن ملفات Python...")
        python_files = self.find_python_files()
        print(f"تم العثور على {len(python_files)} ملف Python")

        print("📖 تحليل الملفات...")
        for file_path in python_files:
            self.analyze_file(file_path)

        print(f"✅ تم تحليل {len(self.files_info)} ملف بنجاح")

    def generate_dependency_tree(self, module: str, visited: Set[str] = None, depth: int = 0) -> str:
        """إنشاء شجرة الاعتماديات لوحدة معينة"""
        if visited is None:
            visited = set()

        if module in visited:
            return "  " * depth + f"├── {module} (دائري)\n"

        visited.add(module)
        tree = "  " * depth + f"├── {module}\n"

        if module in self.dependencies:
            deps = sorted(self.dependencies[module])
            for i, dep in enumerate(deps):
                if i == len(deps) - 1:
                    tree += "  " * (depth + 1) + f"└── {dep}\n"
                else:
                    tree += "  " * (depth + 1) + f"├── {dep}\n"

                if dep in self.dependencies and depth < 3:  # تحديد العمق لتجنب التعقيد
                    tree += self.generate_dependency_tree(dep, visited.copy(), depth + 2)

        return tree

    def find_circular_dependencies(self) -> List[List[str]]:
        """البحث عن الاعتماديات الدائرية"""
        circles = []
        visited = set()

        def dfs(node, path, rec_stack):
            if node in rec_stack:
                # وجدنا دائرة
                circle_start = path.index(node)
                circle = path[circle_start:] + [node]
                circles.append(circle)
                return

            if node in visited:
                return

            visited.add(node)
            rec_stack.add(node)
            path.append(node)

            for neighbor in self.dependencies.get(node, []):
                dfs(neighbor, path, rec_stack)

            path.pop()
            rec_stack.remove(node)

        for module in self.files_info:
            if module not in visited:
                dfs(module, [], set())

        return circles

    def get_most_imported_modules(self, top_n: int = 10) -> List[Tuple[str, int]]:
        """الحصول على أكثر الوحدات استدعاءً"""
        import_counts = {}
        for module, deps in self.reverse_dependencies.items():
            import_counts[module] = len(deps)

        return sorted(import_counts.items(), key=lambda x: x[1], reverse=True)[:top_n]

    def get_most_importing_modules(self, top_n: int = 10) -> List[Tuple[str, int]]:
        """الحصول على الوحدات التي تستدعي أكثر وحدات أخرى"""
        import_counts = {}
        for module, deps in self.dependencies.items():
            import_counts[module] = len(deps)

        return sorted(import_counts.items(), key=lambda x: x[1], reverse=True)[:top_n]

    def generate_report(self) -> str:
        """إنشاء تقرير شامل"""
        report = []
        report.append("=" * 60)
        report.append("📊 تقرير تحليل المشروع")
        report.append("=" * 60)
        report.append("")

        # إحصائيات عامة
        report.append("📈 الإحصائيات العامة:")
        report.append(f"  • عدد الملفات: {len(self.files_info)}")
        total_lines = sum(info['lines'] for info in self.files_info.values())
        report.append(f"  • إجمالي الأسطر: {total_lines:,}")
        total_size = sum(info['size'] for info in self.files_info.values())
        report.append(f"  • إجمالي الحجم: {total_size:,} حرف")
        report.append("")

        # أكثر الوحدات استدعاءً
        report.append("🔗 أكثر الوحدات استدعاءً:")
        most_imported = self.get_most_imported_modules()
        for module, count in most_imported:
            report.append(f"  • {module}: {count} استدعاء")
        report.append("")

        # الوحدات التي تستدعي أكثر وحدات
        report.append("📤 الوحدات التي تستدعي أكثر وحدات:")
        most_importing = self.get_most_importing_modules()
        for module, count in most_importing:
            report.append(f"  • {module}: يستدعي {count} وحدة")
        report.append("")

        # البحث عن الاعتماديات الدائرية
        circles = self.find_circular_dependencies()
        if circles:
            report.append("⚠️  اعتماديات دائرية تم العثور عليها:")
            for i, circle in enumerate(circles, 1):
                report.append(f"  {i}. {' → '.join(circle)}")
        else:
            report.append("✅ لا توجد اعتماديات دائرية")
        report.append("")

        # شجرة الاعتماديات للملف الرئيسي
        if "app" in self.files_info:
            report.append("🌳 شجرة اعتماديات الملف الرئيسي (app):")
            report.append(self.generate_dependency_tree("app"))

        return "\n".join(report)

    def save_detailed_analysis(self, output_file: str = "project_analysis.json"):
        """حفظ التحليل المفصل في ملف JSON"""
        analysis_data = {
            "files": self.files_info,
            "dependencies": {k: list(v) for k, v in self.dependencies.items()},
            "reverse_dependencies": {k: list(v) for k, v in self.reverse_dependencies.items()},
            "external_imports": {k: list(v) for k, v in self.external_imports.items()},
            "statistics": {
                "total_files": len(self.files_info),
                "total_lines": sum(info['lines'] for info in self.files_info.values()),
                "total_size": sum(info['size'] for info in self.files_info.values()),
                "circular_dependencies": self.find_circular_dependencies(),
                "most_imported": self.get_most_imported_modules(),
                "most_importing": self.get_most_importing_modules()
            }
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(analysis_data, f, ensure_ascii=False, indent=2)

        print(f"💾 تم حفظ التحليل المفصل في: {output_file}")

    def generate_graphviz_dot(self, output_file: str = "dependency_graph.dot"):
        """إنشاء ملف Graphviz لرسم الشجرة بصرياً"""
        dot_content = ["digraph ProjectDependencies {"]
        dot_content.append("  rankdir=TB;")
        dot_content.append("  node [shape=box, style=filled, fillcolor=lightblue];")
        dot_content.append("")

        # إضافة العقد
        for module in self.files_info:
            # تنسيق اسم العقدة
            clean_name = module.replace(".", "_")
            display_name = module.split(".")[-1] if "." in module else module

            # تحديد اللون بناءً على نوع الملف
            if "controller" in module:
                color = "lightcoral"
            elif "view" in module:
                color = "lightgreen"
            elif "core" in module:
                color = "lightyellow"
            elif "util" in module:
                color = "lightgray"
            else:
                color = "lightblue"

            dot_content.append(f'  {clean_name} [label="{display_name}", fillcolor={color}];')

        dot_content.append("")

        # إضافة الاتصالات
        for module, deps in self.dependencies.items():
            clean_module = module.replace(".", "_")
            for dep in deps:
                clean_dep = dep.replace(".", "_")
                dot_content.append(f"  {clean_module} -> {clean_dep};")

        dot_content.append("}")

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("\n".join(dot_content))

        print(f"📊 تم إنشاء ملف Graphviz: {output_file}")
        print("لرسم الشجرة، استخدم الأمر: dot -Tpng dependency_graph.dot -o dependency_graph.png")


def main():
    parser = argparse.ArgumentParser(description="تحليل اعتماديات ملفات المشروع")
    parser.add_argument("project_path", nargs="?", default=".",
                       help="مسار المشروع (افتراضي: المجلد الحالي)")
    parser.add_argument("--output", "-o", default="project_analysis",
                       help="اسم ملف الإخراج (بدون امتداد)")
    parser.add_argument("--graphviz", action="store_true",
                       help="إنشاء ملف Graphviz للرسم البصري")

    args = parser.parse_args()

    # التحقق من وجود المشروع
    if not os.path.exists(args.project_path):
        print(f"❌ المسار غير موجود: {args.project_path}")
        return

    print(f"🚀 بدء تحليل المشروع في: {os.path.abspath(args.project_path)}")
    print("-" * 50)

    # إنشاء المحلل
    analyzer = ProjectAnalyzer(args.project_path)

    # تحليل المشروع
    analyzer.analyze_project()

    # إنشاء التقرير
    report = analyzer.generate_report()
    print(report)

    # حفظ التحليل المفصل
    json_file = f"{args.output}.json"
    analyzer.save_detailed_analysis(json_file)

    # حفظ التقرير النصي
    txt_file = f"{args.output}.txt"
    with open(txt_file, 'w', encoding='utf-8') as f:
        f.write(report)
    print(f"📄 تم حفظ التقرير في: {txt_file}")

    # إنشاء ملف Graphviz إذا طُلب
    if args.graphviz:
        dot_file = f"{args.output}.dot"
        analyzer.generate_graphviz_dot(dot_file)


if __name__ == "__main__":
    main()


============================================================
FILE: project_export_20250703_042857.txt
SIZE: 67932 characters
============================================================

================================================================================
PROJECT STRUCTURE
================================================================================

PROJECT_ROOT/
├── app.py
├── export_project_improved.py
├── fts_sales_cache.db
├── project_analysis.json
├── project_analysis.txt
├── project_analyzer.py
├── project_export_20250703_042857.txt
├── requirements.txt
├── cache/
│   └── dropdown_cache.json
├── config/
│   ├── login_config.py
│   ├── modern_color_palettes.py
│   └── settings.yaml
├── controllers/
│   └── app_controller.py
├── core/
│   ├── airtable_dropdown_manager.py
│   ├── airtable_manager.py
│   ├── app_state_manager.py
│   ├── config_manager.py
│   ├── constants.py
│   ├── db_manager.py
│   ├── event_system.py
│   ├── language_manager.py
│   ├── logger.py
│   ├── permissions.py
│   ├── session_manager.py
│   ├── state_manager.py
│   ├── theme_color_manager.py
│   ├── theme_manager.py
│   ├── user_manager.py
│   ├── core/security/
│   │   ├── encryption.py
│   │   ├── rate_limiter.py
│   │   └── two_factor_auth.py
├── data/
│   └── login_cache.json
├── drafts/
├── locales/
│   ├── ar.yaml
│   └── en.yaml
├── logs/
│   ├── app.log
│   ├── logs/logs/
├── resources/
│   ├── company_logo.png
│   └── fts_icon.ico
├── utils/
│   ├── async_operations.py
│   ├── error_handler.py
│   ├── image_utils.py
│   ├── login_visual_effects.py
│   ├── threading_utils.py
│   ├── validators.py
│   └── window_manager.py
├── views/
│   ├── add_edit_window.py
│   ├── login_window.py
│   ├── main_window.py
│   ├── splash_screen.py
│   ├── views/components/
│   │   ├── autocomplete_entry.py
│   │   ├── combobox.py
│   │   ├── data_table.py
│   │   ├── dropdown_dialogs.py
│   │   ├── header.py
│   │   ├── menu_bar.py
│   │   ├── quick_test.py
│   │   ├── searchable_combobox.py
│   │   ├── sidebar.py
│   │   ├── status_bar.py
│   │   └── toolbar.py

================================================================================
FILE CONTENTS
================================================================================


============================================================
FILE: app.py
SIZE: 6242 characters
============================================================

# -*- coding: utf-8 -*-
"""
app.py

نقطة البداية (entry point) لتشغيل تطبيق FTS Sales Manager.
"""

# تتبع الأخطاء وإدارتها
import sys
import traceback
import warnings
import traceback

# تعطيل تحذير "invalid command name"
warnings.filterwarnings("ignore", message="invalid command name")

# محاولة تفعيل faulthandler فقط إذا كان مدعوماً
try:
    import faulthandler
    # التحقق من أننا لسنا في IDLE
    if hasattr(sys.stderr, 'fileno') and hasattr(sys.stderr.fileno, '__call__'):
        try:
            sys.stderr.fileno()
            faulthandler.enable()
        except:
            # إذا فشل، نتجاهل الخطأ
            pass
except ImportError:
    # إذا لم يكن faulthandler متاحاً
    pass

# معالج أخطاء عام لـ Tkinter
def handle_tk_error(*args):
    import traceback
    import sys

    try:
        # الحالة الأولى: tkinter يرسل (exc_type, exc_value, exc_tb)
        if isinstance(args, tuple) and len(args) == 3 and isinstance(args[1], BaseException):
            exc_type, exc_value, exc_tb = args

        # الحالة الثانية: tkinter يرسل كائن استثناء واحد فقط
        elif isinstance(args, tuple) and len(args) == 1 and isinstance(args[0], BaseException):
            exc_type = type(args[0])
            exc_value = args[0]
            exc_tb = args[0].__traceback__ if hasattr(args[0], "__traceback__") else None

        # الحالة الثالثة: (widget, exc_type, exc_value, exc_tb)
        elif isinstance(args, tuple) and len(args) == 4 and isinstance(args[2], BaseException):
            _, exc_type, exc_value, exc_tb = args

        else:
            print("📦 محتوى args غير المتوقع:", args, file=sys.stderr)
            raise ValueError("تنسيق غير معروف لمعالجة الخطأ")

        traceback.print_exception(exc_type, exc_value, exc_tb)

    except Exception as e:
        print(f"⚠️ فشل أثناء معالجة الاستثناء (داخليًا): {e}", file=sys.stderr)

# معالج أخطاء شامل
def handle_exception(exc_type, exc_value, exc_traceback):
    if issubclass(exc_type, KeyboardInterrupt):
        sys.__excepthook__(exc_type, exc_value, exc_traceback)
        return

    # استيراد logger هنا لتجنب مشاكل الاستيراد المبكر
    from core.logger import logger
    logger.critical("Uncaught exception", exc_info=(exc_type, exc_value, exc_traceback))
    traceback.print_exception(exc_type, exc_value, exc_traceback)

sys.excepthook = handle_exception

# باقي الواردات
import os
import tkinter as tk

# إخفاء نافذة tk الافتراضية فوراً بعد استيراد tkinter
if tk._default_root:
    tk._default_root.withdraw()

from core.config_manager import ConfigManager
from core.db_manager import DatabaseManager
from core.airtable_manager import AirtableManager, AirtableModel
from core.user_manager import UserManager
from core.logger import logger
from controllers.app_controller import AppController
from views.splash_screen import SplashScreen

# ربط معالج الأخطاء بـ Tkinter
tk.Tk.report_callback_exception = handle_tk_error


def hide_default_tk_window():
    """إخفاء أي نافذة tk افتراضية"""
    try:
        # إخفاء النافذة الافتراضية إذا كانت موجودة
        if tk._default_root:
            tk._default_root.withdraw()
            tk._default_root.overrideredirect(True)

        # البحث عن أي نوافذ tk مفتوحة وإخفاؤها
        for widget in tk._default_root.winfo_children() if tk._default_root else []:
            if widget.winfo_class() == 'Tk' and widget.title() == 'tk':
                widget.withdraw()
    except:
        pass


def main() -> None:
    """
    الدالة الرئيسية لتشغيل التطبيق.
    """
    # إنشاء نافذة أساسية مخفية لـ CTkToplevel
    root = tk.Tk()
    root.withdraw()  # إخفاء النافذة فوراً
    root.overrideredirect(True)  # إزالة من شريط المهام

    # إخفاء أي نافذة tk افتراضية أخرى
    hide_default_tk_window()

    # 1. عرض شاشة التحميل لمدة قصيرة
    try:
        splash = SplashScreen(duration=2000, master=root)  # تمرير النافذة الأساسية
        splash.update()
    except Exception as e:
        logger.warning(f"Failed to show splash screen: {e}", exc_info=True)

    # إخفاء النافذة مرة أخرى بعد شاشة التحميل
    hide_default_tk_window()

    # 2. تهيئة ConfigManager
    config_mgr = ConfigManager(config_path=os.path.join("config", "settings.yaml"))

    # 3. تهيئة DatabaseManager (SQLite للكاش المحلي)
    db_mgr = DatabaseManager(db_path="fts_sales_cache.db")

    # 4. تهيئة AirtableModel للمستخدمين
    users_table = config_mgr.get("airtable_users_table", "Users")
    airtable_users = AirtableModel(
        config_manager=config_mgr,
        db_manager=db_mgr,
        table_name=users_table
    )

    # 5. تهيئة AirtableModel للحجوزات
    booking_table = config_mgr.get("airtable_booking_table", "List V2")
    airtable_booking = AirtableModel(
        config_manager=config_mgr,
        db_manager=db_mgr,
        table_name=booking_table
    )

    # 6. تهيئة UserManager (يستخدم airtable_users فقط)
    user_mgr = UserManager(airtable_model=airtable_users, db_manager=db_mgr)

    # 7. تشغيل AppController مع كلا النموذجين
    try:
        app_ctrl = AppController(
            config_mgr=config_mgr,
            db_mgr=db_mgr,
            airtable_users=airtable_users,
            airtable_booking=airtable_booking,
            user_mgr=user_mgr
        )
        app_ctrl.run()
    except Exception as e:
        logger.error(f"Unexpected error in main loop: {e}", exc_info=True)
        raise
    finally:
        # تنظيف النافذة الأساسية
        try:
            if 'root' in locals() and root:
                root.destroy()
        except:
            pass


if __name__ == "__main__":
    try:
        main()
    except Exception as e:
        logger.critical(f"Fatal error on startup: {e}", exc_info=True)
        # عرض رسالة خطأ للمستخدم
        try:
            import tkinter as tk
            from tkinter import messagebox

            # إنشاء نافذة مؤقتة لرسالة الخطأ
            error_root = tk.Tk()
            error_root.withdraw()  # إخفاء النافذة الرئيسية

            messagebox.showerror(
                "خطأ في بدء التطبيق",
                f"حدث خطأ أثناء تشغيل التطبيق:\n\n{str(e)}\n\nيرجى التحقق من السجلات للمزيد من التفاصيل."
            )

            error_root.destroy()
        except:
            pass
        sys.exit(1)

============================================================
FILE: export_project_improved.py
SIZE: 3849 characters
============================================================

import os
import datetime

output_file = f"project_export_{datetime.datetime.now().strftime('%Y%m%d_%H%M%S')}.txt"

# المجلدات المستثناة
EXCLUDED_DIRS = {'.git', '__pycache__', 'venv', '.venv', 'node_modules', '.idea', '.vscode'}
# الامتدادات المستثناة
EXCLUDED_EXTENSIONS = {'.pyc', '.pyo', '.pyd', '.so', '.dll', '.dylib', '.exe'}

with open(output_file, 'w', encoding='utf-8') as out:
    # كتابة هيكل المشروع
    out.write("=" * 80 + "\n")
    out.write("PROJECT STRUCTURE\n")
    out.write("=" * 80 + "\n\n")

    # طريقة محسنة لرسم الشجرة
    for root, dirs, files in os.walk('.'):
        # استثناء المجلدات غير المرغوبة
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        # حساب المستوى بشكل صحيح
        if root == '.':
            level = 0
            display_path = 'PROJECT_ROOT/'
        else:
            # إزالة ./ أو .\ من البداية
            relative_path = os.path.relpath(root, '.')
            level = relative_path.count(os.sep) + 1
            display_path = relative_path.replace(os.sep, '/') + '/'

        # رسم المسار الهرمي
        indent = '│   ' * (level - 1) + '├── ' if level > 0 else ''
        out.write(f'{indent}{display_path}\n')

        # رسم الملفات
        for i, file in enumerate(files):
            # استثناء الملفات المخفية والملفات المترجمة
            if file.startswith('.') or any(file.endswith(ext) for ext in EXCLUDED_EXTENSIONS):
                continue

            # تحديد الرمز المناسب (آخر ملف أم لا)
            is_last = (i == len(files) - 1) and not dirs
            file_indent = '│   ' * level + ('└── ' if is_last else '├── ')
            out.write(f'{file_indent}{file}\n')

    # كتابة محتوى الملفات
    out.write("\n" + "=" * 80 + "\n")
    out.write("FILE CONTENTS\n")
    out.write("=" * 80 + "\n")

    # امتدادات الملفات المراد قراءتها
    READ_EXTENSIONS = {'.py', '.json', '.txt', '.md', '.yml', '.yaml', '.js', '.html', '.css',
                      '.jsx', '.tsx', '.ts', '.vue', '.sql', '.sh', '.bat', '.env.example'}

    files_read = 0
    errors = []

    for root, dirs, files in os.walk('.'):
        dirs[:] = [d for d in dirs if d not in EXCLUDED_DIRS]

        for file in files:
            # التحقق من الامتداد
            if any(file.endswith(ext) for ext in READ_EXTENSIONS):
                filepath = os.path.join(root, file)
                relative_path = os.path.relpath(filepath, '.')

                try:
                    with open(filepath, 'r', encoding='utf-8') as f:
                        content = f.read()

                    out.write(f"\n\n{'='*60}\n")
                    out.write(f"FILE: {relative_path}\n")
                    out.write(f"SIZE: {len(content)} characters\n")
                    out.write(f"{'='*60}\n\n")
                    out.write(content)
                    files_read += 1

                except Exception as e:
                    error_msg = f"Error reading {relative_path}: {e}"
                    out.write(f"\n\n{'='*60}\n")
                    out.write(f"ERROR: {error_msg}\n")
                    out.write(f"{'='*60}\n")
                    errors.append(error_msg)

    # ملخص التصدير
    out.write(f"\n\n{'='*80}\n")
    out.write("EXPORT SUMMARY\n")
    out.write(f"{'='*80}\n")
    out.write(f"Total files read: {files_read}\n")
    out.write(f"Errors encountered: {len(errors)}\n")
    out.write(f"Export date: {datetime.datetime.now().strftime('%Y-%m-%d %H:%M:%S')}\n")

    if errors:
        out.write("\nErrors details:\n")
        for error in errors:
            out.write(f"  - {error}\n")

print(f"✅ تم تصدير المشروع إلى: {output_file}")
print(f"📁 عدد الملفات المقروءة: {files_read}")
if errors:
    print(f"⚠️  عدد الأخطاء: {len(errors)}")

============================================================
FILE: project_analysis.json
SIZE: 35687 characters
============================================================

{
  "files": {
    "app": {
      "path": "app.py",
      "size": 6242,
      "lines": 201,
      "local_imports": [
        "core.user_manager",
        "core.config_manager",
        "core.airtable_manager",
        "views.splash_screen",
        "core.logger",
        "controllers.app_controller",
        "core.db_manager"
      ],
      "external_imports": [
        "os",
        "warnings",
        "traceback",
        "tkinter",
        "sys",
        "faulthandler"
      ]
    },
    "project_analyzer": {
      "path": "project_analyzer.py",
      "size": 15466,
      "lines": 401,
      "local_imports": [],
      "external_imports": [
        "os",
        "ast",
        "re",
        "pathlib",
        "typing",
        "json",
        "collections",
        "argparse"
      ]
    },
    "config.login_config": {
      "path": "config\\login_config.py",
      "size": 6796,
      "lines": 217,
      "local_imports": [],
      "external_imports": []
    },
    "config.modern_color_palettes": {
      "path": "config\\modern_color_palettes.py",
      "size": 5867,
      "lines": 202,
      "local_imports": [],
      "external_imports": []
    },
    "controllers.app_controller": {
      "path": "controllers\\app_controller.py",
      "size": 29214,
      "lines": 787,
      "local_imports": [
        "utils.threading_utils",
        "core.user_manager",
        "views.login_window",
        "views.main_window",
        "core.config_manager",
        "core.airtable_manager",
        "views.add_edit_window",
        "core.theme_manager",
        "core.logger",
        "core.language_manager",
        "core.db_manager",
        "core.airtable_dropdown_manager"
      ],
      "external_imports": [
        "typing",
        "threading",
        "datetime",
        "json",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "core.airtable_dropdown_manager": {
      "path": "core\\airtable_dropdown_manager.py",
      "size": 24117,
      "lines": 602,
      "local_imports": [
        "core.airtable_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "logging",
        "time",
        "concurrent.futures"
      ]
    },
    "core.airtable_manager": {
      "path": "core\\airtable_manager.py",
      "size": 28862,
      "lines": 774,
      "local_imports": [],
      "external_imports": [
        "os",
        "re",
        "typing",
        "threading",
        "datetime",
        "json",
        "requests",
        "logging",
        "time",
        "concurrent.futures"
      ]
    },
    "core.app_state_manager": {
      "path": "core\\app_state_manager.py",
      "size": 14840,
      "lines": 403,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "threading",
        "datetime",
        "enum",
        "time"
      ]
    },
    "core.config_manager": {
      "path": "core\\config_manager.py",
      "size": 18851,
      "lines": 499,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "dotenv",
        "typing",
        "yaml"
      ]
    },
    "core.constants": {
      "path": "core\\constants.py",
      "size": 8556,
      "lines": 295,
      "local_imports": [],
      "external_imports": [
        "typing",
        "enum"
      ]
    },
    "core.db_manager": {
      "path": "core\\db_manager.py",
      "size": 10852,
      "lines": 261,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "sqlite3",
        "typing",
        "threading"
      ]
    },
    "core.event_system": {
      "path": "core\\event_system.py",
      "size": 1015,
      "lines": 31,
      "local_imports": [],
      "external_imports": [
        "queue",
        "typing",
        "threading",
        "datetime"
      ]
    },
    "core.language_manager": {
      "path": "core\\language_manager.py",
      "size": 6614,
      "lines": 166,
      "local_imports": [
        "core.logger",
        "core.config_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "yaml"
      ]
    },
    "core.logger": {
      "path": "core\\logger.py",
      "size": 2118,
      "lines": 62,
      "local_imports": [],
      "external_imports": [
        "os",
        "logging",
        "logging.handlers"
      ]
    },
    "core.permissions": {
      "path": "core\\permissions.py",
      "size": 5411,
      "lines": 176,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "tkinter",
        "functools"
      ]
    },
    "core.session_manager": {
      "path": "core\\session_manager.py",
      "size": 14093,
      "lines": 411,
      "local_imports": [
        "core.security.encryption",
        "core.logger"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "secrets",
        "json",
        "time"
      ]
    },
    "core.state_manager": {
      "path": "core\\state_manager.py",
      "size": 2557,
      "lines": 75,
      "local_imports": [],
      "external_imports": [
        "dataclasses",
        "typing",
        "threading",
        "datetime"
      ]
    },
    "core.theme_color_manager": {
      "path": "core\\theme_color_manager.py",
      "size": 12242,
      "lines": 320,
      "local_imports": [
        "config.modern_color_palettes",
        "core.logger"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    },
    "core.theme_manager": {
      "path": "core\\theme_manager.py",
      "size": 25669,
      "lines": 562,
      "local_imports": [
        "core.logger",
        "core.config_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "json",
        "tkinter",
        "customtkinter"
      ]
    },
    "core.user_manager": {
      "path": "core\\user_manager.py",
      "size": 14899,
      "lines": 387,
      "local_imports": [
        "core.airtable_manager",
        "core.db_manager",
        "core.logger"
      ],
      "external_imports": [
        "hmac",
        "base64",
        "typing",
        "secrets",
        "datetime",
        "hashlib"
      ]
    },
    "utils.async_operations": {
      "path": "utils\\async_operations.py",
      "size": 736,
      "lines": 21,
      "local_imports": [],
      "external_imports": [
        "threading",
        "concurrent.futures"
      ]
    },
    "utils.error_handler": {
      "path": "utils\\error_handler.py",
      "size": 1884,
      "lines": 49,
      "local_imports": [
        "utils.window_manager"
      ],
      "external_imports": [
        "typing",
        "logging",
        "traceback",
        "tkinter",
        "functools"
      ]
    },
    "utils.image_utils": {
      "path": "utils\\image_utils.py",
      "size": 8538,
      "lines": 297,
      "local_imports": [],
      "external_imports": [
        "os",
        "PIL",
        "typing",
        "logging",
        "tkinter",
        "customtkinter",
        "sys"
      ]
    },
    "utils.login_visual_effects": {
      "path": "utils\\login_visual_effects.py",
      "size": 11479,
      "lines": 356,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "math",
        "customtkinter",
        "time"
      ]
    },
    "utils.threading_utils": {
      "path": "utils\\threading_utils.py",
      "size": 5475,
      "lines": 178,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "tkinter",
        "queue",
        "typing",
        "threading"
      ]
    },
    "utils.validators": {
      "path": "utils\\validators.py",
      "size": 12546,
      "lines": 405,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "re",
        "typing",
        "datetime",
        "string"
      ]
    },
    "utils.window_manager": {
      "path": "utils\\window_manager.py",
      "size": 48019,
      "lines": 1208,
      "local_imports": [],
      "external_imports": [
        "ctypes",
        "platform",
        "weakref",
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.add_edit_window": {
      "path": "views\\add_edit_window.py",
      "size": 35739,
      "lines": 861,
      "local_imports": [
        "core.theme_color_manager",
        "core.logger",
        "core.language_manager",
        "views.components.combobox",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "tkcalendar",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.login_window": {
      "path": "views\\login_window.py",
      "size": 91114,
      "lines": 2369,
      "local_imports": [
        "core.constants",
        "core.theme_color_manager",
        "core.security.encryption",
        "utils.validators",
        "core.security.rate_limiter",
        "config.login_config",
        "core.logger",
        "core.theme_manager",
        "core.language_manager",
        "config.modern_color_palettes",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "ctypes",
        "platform",
        "re",
        "typing",
        "threading",
        "secrets",
        "json",
        "datetime",
        "string",
        "tkinter",
        "customtkinter",
        "time",
        "hashlib",
        "queue",
        "functools"
      ]
    },
    "views.main_window": {
      "path": "views\\main_window.py",
      "size": 55631,
      "lines": 1310,
      "local_imports": [
        "views.components.data_table",
        "core.theme_color_manager",
        "views.components.header",
        "utils.image_utils",
        "core.state_manager",
        "core.event_system",
        "core.permissions",
        "views.components.status_bar",
        "core.logger",
        "core.theme_manager",
        "core.language_manager",
        "views.components.toolbar",
        "views.components.menu_bar",
        "views.components.sidebar",
        "utils.async_operations",
        "utils.window_manager"
      ],
      "external_imports": [
        "os",
        "platform",
        "typing",
        "threading",
        "datetime",
        "weakref",
        "tkinter",
        "customtkinter",
        "functools"
      ]
    },
    "views.splash_screen": {
      "path": "views\\splash_screen.py",
      "size": 11100,
      "lines": 363,
      "local_imports": [],
      "external_imports": [
        "os",
        "PIL",
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "core.security.encryption": {
      "path": "core\\security\\encryption.py",
      "size": 6042,
      "lines": 210,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "base64",
        "typing",
        "secrets",
        "json",
        "hashlib",
        "cryptography.fernet"
      ]
    },
    "core.security.rate_limiter": {
      "path": "core\\security\\rate_limiter.py",
      "size": 10258,
      "lines": 311,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "os",
        "typing",
        "threading",
        "datetime",
        "json",
        "collections",
        "time"
      ]
    },
    "core.security.two_factor_auth": {
      "path": "core\\security\\two_factor_auth.py",
      "size": 11664,
      "lines": 403,
      "local_imports": [
        "core.logger"
      ],
      "external_imports": [
        "io",
        "pyotp",
        "base64",
        "typing",
        "secrets",
        "datetime",
        "json",
        "qrcode",
        "time",
        "hashlib"
      ]
    },
    "venv.Lib.site-packages.pip.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\__main__.py",
      "size": 854,
      "lines": 24,
      "local_imports": [],
      "external_imports": [
        "os",
        "pip._internal.cli.main",
        "sys"
      ]
    },
    "venv.Lib.site-packages.pip._internal.main": {
      "path": "venv\\Lib\\site-packages\\pip\\_internal\\main.py",
      "size": 340,
      "lines": 12,
      "local_imports": [],
      "external_imports": [
        "typing",
        "pip._internal.utils.entrypoints"
      ]
    },
    "venv.Lib.site-packages.pip._internal.cli.main": {
      "path": "venv\\Lib\\site-packages\\pip\\_internal\\cli\\main.py",
      "size": 2817,
      "lines": 80,
      "local_imports": [],
      "external_imports": [
        "os",
        "pip._internal.cli.autocompletion",
        "pip._internal.cli.main_parser",
        "pip._internal.exceptions",
        "typing",
        "pip._internal.utils",
        "logging",
        "warnings",
        "sys",
        "locale",
        "pip._internal.commands"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.certifi.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\certifi\\__main__.py",
      "size": 255,
      "lines": 12,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.certifi",
        "argparse"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.distro.distro": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\distro\\distro.py",
      "size": 49430,
      "lines": 1403,
      "local_imports": [],
      "external_imports": [
        "os",
        "re",
        "typing",
        "json",
        "logging",
        "subprocess",
        "warnings",
        "argparse",
        "sys",
        "shlex",
        "functools"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.distro.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\distro\\__main__.py",
      "size": 64,
      "lines": 4,
      "local_imports": [
        "venv.Lib.site-packages.pip._vendor.distro.distro"
      ],
      "external_imports": []
    },
    "venv.Lib.site-packages.pip._vendor.platformdirs.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\platformdirs\\__main__.py",
      "size": 1505,
      "lines": 55,
      "local_imports": [],
      "external_imports": [
        "__future__",
        "pip._vendor.platformdirs"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.pygments.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\pygments\\__main__.py",
      "size": 353,
      "lines": 17,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.pygments.cmdline",
        "sys"
      ]
    },
    "venv.Lib.site-packages.pip._vendor.rich.__main__": {
      "path": "venv\\Lib\\site-packages\\pip\\_vendor\\rich\\__main__.py",
      "size": 8319,
      "lines": 273,
      "local_imports": [],
      "external_imports": [
        "pip._vendor.rich.markdown",
        "pip._vendor.rich.console",
        "io",
        "pip._vendor.rich.style",
        "pip._vendor.rich.pretty",
        "pip._vendor.rich.segment",
        "pip._vendor.rich.measure",
        "pip._vendor.rich",
        "pip._vendor.rich.panel",
        "pip._vendor.rich.color",
        "pip._vendor.rich.syntax",
        "pip._vendor.rich.text",
        "time",
        "colorsys",
        "pip._vendor.rich.table"
      ]
    },
    "views.components.autocomplete_entry": {
      "path": "views\\components\\autocomplete_entry.py",
      "size": 19262,
      "lines": 616,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "enum",
        "time",
        "random",
        "dataclasses"
      ]
    },
    "views.components.combobox": {
      "path": "views\\components\\combobox.py",
      "size": 70009,
      "lines": 1855,
      "local_imports": [],
      "external_imports": [
        "typing",
        "traceback",
        "tkinter",
        "customtkinter",
        "time"
      ]
    },
    "views.components.data_table": {
      "path": "views\\components\\data_table.py",
      "size": 20968,
      "lines": 614,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "datetime",
        "typing",
        "tkinter",
        "customtkinter"
      ]
    },
    "views.components.dropdown_dialogs": {
      "path": "views\\components\\dropdown_dialogs.py",
      "size": 54108,
      "lines": 1558,
      "local_imports": [
        "core.logger",
        "core.theme_manager",
        "core.config_manager",
        "core.language_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "datetime",
        "json",
        "tkinter",
        "customtkinter",
        "webbrowser"
      ]
    },
    "views.components.header": {
      "path": "views\\components\\header.py",
      "size": 28565,
      "lines": 867,
      "local_imports": [
        "views.components.dropdown_dialogs",
        "core.logger",
        "core.language_manager"
      ],
      "external_imports": [
        "os",
        "typing",
        "weakref",
        "datetime",
        "tkinter",
        "customtkinter",
        "sys",
        "webbrowser"
      ]
    },
    "views.components.menu_bar": {
      "path": "views\\components\\menu_bar.py",
      "size": 11466,
      "lines": 371,
      "local_imports": [
        "core.logger",
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "tkinter"
      ]
    },
    "views.components.quick_test": {
      "path": "views\\components\\quick_test.py",
      "size": 2201,
      "lines": 84,
      "local_imports": [],
      "external_imports": [
        "enhanced_searchable_combobox",
        "customtkinter"
      ]
    },
    "views.components.searchable_combobox": {
      "path": "views\\components\\searchable_combobox.py",
      "size": 20729,
      "lines": 643,
      "local_imports": [],
      "external_imports": [
        "typing",
        "threading",
        "tkinter",
        "customtkinter",
        "time",
        "random"
      ]
    },
    "views.components.sidebar": {
      "path": "views\\components\\sidebar.py",
      "size": 19652,
      "lines": 601,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    },
    "views.components.status_bar": {
      "path": "views\\components\\status_bar.py",
      "size": 20837,
      "lines": 600,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "datetime",
        "typing",
        "threading",
        "customtkinter"
      ]
    },
    "views.components.toolbar": {
      "path": "views\\components\\toolbar.py",
      "size": 18926,
      "lines": 520,
      "local_imports": [
        "core.language_manager"
      ],
      "external_imports": [
        "typing",
        "customtkinter"
      ]
    }
  },
  "dependencies": {
    "app": [
      "core.user_manager",
      "core.config_manager",
      "core.airtable_manager",
      "views.splash_screen",
      "core.logger",
      "controllers.app_controller",
      "core.db_manager"
    ],
    "controllers.app_controller": [
      "utils.threading_utils",
      "core.user_manager",
      "views.main_window",
      "core.config_manager",
      "core.airtable_manager",
      "views.add_edit_window",
      "core.theme_manager",
      "core.logger",
      "views.login_window",
      "core.language_manager",
      "core.db_manager",
      "core.airtable_dropdown_manager"
    ],
    "core.airtable_dropdown_manager": [
      "core.airtable_manager"
    ],
    "core.app_state_manager": [
      "core.logger"
    ],
    "core.config_manager": [
      "core.logger"
    ],
    "core.db_manager": [
      "core.logger"
    ],
    "core.language_manager": [
      "core.logger",
      "core.config_manager"
    ],
    "core.permissions": [
      "core.logger"
    ],
    "core.session_manager": [
      "core.security.encryption",
      "core.logger"
    ],
    "core.theme_color_manager": [
      "config.modern_color_palettes",
      "core.logger"
    ],
    "core.theme_manager": [
      "core.logger",
      "core.config_manager"
    ],
    "core.user_manager": [
      "core.airtable_manager",
      "core.db_manager",
      "core.logger"
    ],
    "utils.error_handler": [
      "utils.window_manager"
    ],
    "utils.threading_utils": [
      "core.logger"
    ],
    "utils.validators": [
      "core.logger"
    ],
    "views.add_edit_window": [
      "core.theme_color_manager",
      "core.logger",
      "core.language_manager",
      "views.components.combobox",
      "utils.window_manager"
    ],
    "views.login_window": [
      "core.constants",
      "core.theme_color_manager",
      "core.security.encryption",
      "utils.validators",
      "config.login_config",
      "config.modern_color_palettes",
      "core.logger",
      "core.theme_manager",
      "core.language_manager",
      "core.security.rate_limiter",
      "utils.window_manager"
    ],
    "views.main_window": [
      "views.components.data_table",
      "core.theme_color_manager",
      "utils.window_manager",
      "utils.image_utils",
      "core.state_manager",
      "core.event_system",
      "core.permissions",
      "views.components.status_bar",
      "core.logger",
      "core.theme_manager",
      "core.language_manager",
      "views.components.toolbar",
      "views.components.menu_bar",
      "views.components.sidebar",
      "utils.async_operations",
      "views.components.header"
    ],
    "core.security.encryption": [
      "core.logger"
    ],
    "core.security.rate_limiter": [
      "core.logger"
    ],
    "core.security.two_factor_auth": [
      "core.logger"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.__main__": [
      "venv.Lib.site-packages.pip._vendor.distro.distro"
    ],
    "views.components.data_table": [
      "core.language_manager"
    ],
    "views.components.dropdown_dialogs": [
      "core.theme_manager",
      "core.logger",
      "core.config_manager",
      "core.language_manager"
    ],
    "views.components.header": [
      "views.components.dropdown_dialogs",
      "core.logger",
      "core.language_manager"
    ],
    "views.components.menu_bar": [
      "core.logger",
      "core.language_manager"
    ],
    "views.components.sidebar": [
      "core.language_manager"
    ],
    "views.components.status_bar": [
      "core.language_manager"
    ],
    "views.components.toolbar": [
      "core.language_manager"
    ]
  },
  "reverse_dependencies": {
    "core.user_manager": [
      "app",
      "controllers.app_controller"
    ],
    "core.config_manager": [
      "app",
      "views.components.dropdown_dialogs",
      "core.theme_manager",
      "controllers.app_controller",
      "core.language_manager"
    ],
    "core.airtable_manager": [
      "app",
      "core.user_manager",
      "core.airtable_dropdown_manager",
      "controllers.app_controller"
    ],
    "views.splash_screen": [
      "app"
    ],
    "core.logger": [
      "utils.threading_utils",
      "core.user_manager",
      "core.theme_color_manager",
      "app",
      "core.config_manager",
      "views.add_edit_window",
      "core.permissions",
      "core.security.two_factor_auth",
      "core.language_manager",
      "core.security.rate_limiter",
      "core.db_manager",
      "views.components.dropdown_dialogs",
      "utils.validators",
      "core.app_state_manager",
      "views.components.header",
      "core.security.encryption",
      "views.components.menu_bar",
      "controllers.app_controller",
      "views.login_window",
      "views.main_window",
      "core.theme_manager",
      "core.session_manager"
    ],
    "controllers.app_controller": [
      "app"
    ],
    "core.db_manager": [
      "app",
      "core.user_manager",
      "controllers.app_controller"
    ],
    "utils.threading_utils": [
      "controllers.app_controller"
    ],
    "views.login_window": [
      "controllers.app_controller"
    ],
    "views.main_window": [
      "controllers.app_controller"
    ],
    "views.add_edit_window": [
      "controllers.app_controller"
    ],
    "core.theme_manager": [
      "views.components.dropdown_dialogs",
      "views.main_window",
      "controllers.app_controller",
      "views.login_window"
    ],
    "core.language_manager": [
      "views.components.data_table",
      "views.components.dropdown_dialogs",
      "views.main_window",
      "views.add_edit_window",
      "views.components.menu_bar",
      "views.components.status_bar",
      "controllers.app_controller",
      "views.login_window",
      "views.components.toolbar",
      "views.components.sidebar",
      "views.components.header"
    ],
    "core.airtable_dropdown_manager": [
      "controllers.app_controller"
    ],
    "core.security.encryption": [
      "views.login_window",
      "core.session_manager"
    ],
    "config.modern_color_palettes": [
      "core.theme_color_manager",
      "views.login_window"
    ],
    "utils.window_manager": [
      "views.add_edit_window",
      "utils.error_handler",
      "views.main_window",
      "views.login_window"
    ],
    "core.theme_color_manager": [
      "views.add_edit_window",
      "views.main_window",
      "views.login_window"
    ],
    "views.components.combobox": [
      "views.add_edit_window"
    ],
    "core.constants": [
      "views.login_window"
    ],
    "utils.validators": [
      "views.login_window"
    ],
    "core.security.rate_limiter": [
      "views.login_window"
    ],
    "config.login_config": [
      "views.login_window"
    ],
    "views.components.data_table": [
      "views.main_window"
    ],
    "views.components.header": [
      "views.main_window"
    ],
    "utils.image_utils": [
      "views.main_window"
    ],
    "core.state_manager": [
      "views.main_window"
    ],
    "core.event_system": [
      "views.main_window"
    ],
    "core.permissions": [
      "views.main_window"
    ],
    "views.components.status_bar": [
      "views.main_window"
    ],
    "views.components.toolbar": [
      "views.main_window"
    ],
    "views.components.menu_bar": [
      "views.main_window"
    ],
    "views.components.sidebar": [
      "views.main_window"
    ],
    "utils.async_operations": [
      "views.main_window"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.distro": [
      "venv.Lib.site-packages.pip._vendor.distro.__main__"
    ],
    "views.components.dropdown_dialogs": [
      "views.components.header"
    ]
  },
  "external_imports": {
    "app": [
      "os",
      "warnings",
      "traceback",
      "tkinter",
      "sys",
      "faulthandler"
    ],
    "project_analyzer": [
      "os",
      "ast",
      "re",
      "pathlib",
      "typing",
      "json",
      "collections",
      "argparse"
    ],
    "config.login_config": [],
    "config.modern_color_palettes": [],
    "controllers.app_controller": [
      "typing",
      "threading",
      "datetime",
      "json",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "core.airtable_dropdown_manager": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "logging",
      "time",
      "concurrent.futures"
    ],
    "core.airtable_manager": [
      "os",
      "re",
      "typing",
      "threading",
      "datetime",
      "json",
      "requests",
      "logging",
      "time",
      "concurrent.futures"
    ],
    "core.app_state_manager": [
      "typing",
      "threading",
      "datetime",
      "enum",
      "time"
    ],
    "core.config_manager": [
      "os",
      "dotenv",
      "typing",
      "yaml"
    ],
    "core.constants": [
      "typing",
      "enum"
    ],
    "core.db_manager": [
      "sqlite3",
      "typing",
      "threading"
    ],
    "core.event_system": [
      "queue",
      "typing",
      "threading",
      "datetime"
    ],
    "core.language_manager": [
      "os",
      "typing",
      "yaml"
    ],
    "core.logger": [
      "os",
      "logging",
      "logging.handlers"
    ],
    "core.permissions": [
      "typing",
      "tkinter",
      "functools"
    ],
    "core.session_manager": [
      "os",
      "typing",
      "threading",
      "datetime",
      "secrets",
      "json",
      "time"
    ],
    "core.state_manager": [
      "dataclasses",
      "typing",
      "threading",
      "datetime"
    ],
    "core.theme_color_manager": [
      "typing",
      "customtkinter"
    ],
    "core.theme_manager": [
      "os",
      "typing",
      "json",
      "tkinter",
      "customtkinter"
    ],
    "core.user_manager": [
      "hmac",
      "base64",
      "typing",
      "secrets",
      "datetime",
      "hashlib"
    ],
    "utils.async_operations": [
      "threading",
      "concurrent.futures"
    ],
    "utils.error_handler": [
      "typing",
      "logging",
      "traceback",
      "tkinter",
      "functools"
    ],
    "utils.image_utils": [
      "os",
      "PIL",
      "typing",
      "logging",
      "tkinter",
      "customtkinter",
      "sys"
    ],
    "utils.login_visual_effects": [
      "typing",
      "threading",
      "math",
      "customtkinter",
      "time"
    ],
    "utils.threading_utils": [
      "tkinter",
      "queue",
      "typing",
      "threading"
    ],
    "utils.validators": [
      "re",
      "typing",
      "datetime",
      "string"
    ],
    "utils.window_manager": [
      "ctypes",
      "platform",
      "weakref",
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.add_edit_window": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "tkcalendar",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.login_window": [
      "os",
      "ctypes",
      "platform",
      "re",
      "typing",
      "threading",
      "secrets",
      "json",
      "datetime",
      "string",
      "tkinter",
      "customtkinter",
      "time",
      "hashlib",
      "queue",
      "functools"
    ],
    "views.main_window": [
      "os",
      "platform",
      "typing",
      "threading",
      "datetime",
      "weakref",
      "tkinter",
      "customtkinter",
      "functools"
    ],
    "views.splash_screen": [
      "os",
      "PIL",
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "core.security.encryption": [
      "os",
      "base64",
      "typing",
      "secrets",
      "json",
      "hashlib",
      "cryptography.fernet"
    ],
    "core.security.rate_limiter": [
      "os",
      "typing",
      "threading",
      "datetime",
      "json",
      "collections",
      "time"
    ],
    "core.security.two_factor_auth": [
      "io",
      "pyotp",
      "base64",
      "typing",
      "secrets",
      "datetime",
      "json",
      "qrcode",
      "time",
      "hashlib"
    ],
    "venv.Lib.site-packages.pip.__main__": [
      "os",
      "pip._internal.cli.main",
      "sys"
    ],
    "venv.Lib.site-packages.pip._internal.main": [
      "typing",
      "pip._internal.utils.entrypoints"
    ],
    "venv.Lib.site-packages.pip._internal.cli.main": [
      "os",
      "pip._internal.cli.autocompletion",
      "pip._internal.cli.main_parser",
      "pip._internal.exceptions",
      "typing",
      "pip._internal.utils",
      "logging",
      "warnings",
      "sys",
      "locale",
      "pip._internal.commands"
    ],
    "venv.Lib.site-packages.pip._vendor.certifi.__main__": [
      "pip._vendor.certifi",
      "argparse"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.distro": [
      "os",
      "re",
      "typing",
      "json",
      "logging",
      "subprocess",
      "warnings",
      "argparse",
      "sys",
      "shlex",
      "functools"
    ],
    "venv.Lib.site-packages.pip._vendor.distro.__main__": [],
    "venv.Lib.site-packages.pip._vendor.platformdirs.__main__": [
      "__future__",
      "pip._vendor.platformdirs"
    ],
    "venv.Lib.site-packages.pip._vendor.pygments.__main__": [
      "pip._vendor.pygments.cmdline",
      "sys"
    ],
    "venv.Lib.site-packages.pip._vendor.rich.__main__": [
      "pip._vendor.rich.markdown",
      "pip._vendor.rich.console",
      "io",
      "pip._vendor.rich.style",
      "pip._vendor.rich.pretty",
      "pip._vendor.rich.segment",
      "pip._vendor.rich.measure",
      "pip._vendor.rich",
      "pip._vendor.rich.panel",
      "pip._vendor.rich.color",
      "pip._vendor.rich.syntax",
      "pip._vendor.rich.text",
      "time",
      "colorsys",
      "pip._vendor.rich.table"
    ],
    "views.components.autocomplete_entry": [
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "enum",
      "time",
      "random",
      "dataclasses"
    ],
    "views.components.combobox": [
      "typing",
      "traceback",
      "tkinter",
      "customtkinter",
      "time"
    ],
    "views.components.data_table": [
      "datetime",
      "typing",
      "tkinter",
      "customtkinter"
    ],
    "views.components.dropdown_dialogs": [
      "os",
      "typing",
      "datetime",
      "json",
      "tkinter",
      "customtkinter",
      "webbrowser"
    ],
    "views.components.header": [
      "os",
      "typing",
      "weakref",
      "datetime",
      "tkinter",
      "customtkinter",
      "sys",
      "webbrowser"
    ],
    "views.components.menu_bar": [
      "typing",
      "tkinter"
    ],
    "views.components.quick_test": [
      "enhanced_searchable_combobox",
      "customtkinter"
    ],
    "views.components.searchable_combobox": [
      "typing",
      "threading",
      "tkinter",
      "customtkinter",
      "time",
      "random"
    ],
    "views.components.sidebar": [
      "typing",
      "customtkinter"
    ],
    "views.components.status_bar": [
      "datetime",
      "typing",
      "threading",
      "customtkinter"
    ],
    "views.components.toolbar": [
      "typing",
      "customtkinter"
    ]
  },
  "statistics": {
    "total_files": 54,
    "total_lines": 25382,
    "total_size": 915166,
    "circular_dependencies": [],
    "most_imported": [
      [
        "core.logger",
        22
      ],
      [
        "core.language_manager",
        11
      ],
      [
        "core.config_manager",
        5
      ],
      [
        "core.airtable_manager",
        4
      ],
      [
        "core.theme_manager",
        4
      ],
      [
        "utils.window_manager",
        4
      ],
      [
        "core.db_manager",
        3
      ],
      [
        "core.theme_color_manager",
        3
      ],
      [
        "core.user_manager",
        2
      ],
      [
        "core.security.encryption",
        2
      ]
    ],
    "most_importing": [
      [
        "views.main_window",
        16
      ],
      [
        "controllers.app_controller",
        12
      ],
      [
        "views.login_window",
        11
      ],
      [
        "app",
        7
      ],
      [
        "views.add_edit_window",
        5
      ],
      [
        "views.components.dropdown_dialogs",
        4
      ],
      [
        "core.user_manager",
        3
      ],
      [
        "views.components.header",
        3
      ],
      [
        "core.language_manager",
        2
      ],
      [
        "core.session_manager",
        2
      ]
    ]
  }
}

============================================================
FILE: project_analysis.txt
SIZE: 3750 characters
============================================================

============================================================
📊 تقرير تحليل المشروع
============================================================

📈 الإحصائيات العامة:
  • عدد الملفات: 54
  • إجمالي الأسطر: 25,382
  • إجمالي الحجم: 915,166 حرف

🔗 أكثر الوحدات استدعاءً:
  • core.logger: 22 استدعاء
  • core.language_manager: 11 استدعاء
  • core.config_manager: 5 استدعاء
  • core.airtable_manager: 4 استدعاء
  • core.theme_manager: 4 استدعاء
  • utils.window_manager: 4 استدعاء
  • core.db_manager: 3 استدعاء
  • core.theme_color_manager: 3 استدعاء
  • core.user_manager: 2 استدعاء
  • core.security.encryption: 2 استدعاء

📤 الوحدات التي تستدعي أكثر وحدات:
  • views.main_window: يستدعي 16 وحدة
  • controllers.app_controller: يستدعي 12 وحدة
  • views.login_window: يستدعي 11 وحدة
  • app: يستدعي 7 وحدة
  • views.add_edit_window: يستدعي 5 وحدة
  • views.components.dropdown_dialogs: يستدعي 4 وحدة
  • core.user_manager: يستدعي 3 وحدة
  • views.components.header: يستدعي 3 وحدة
  • core.language_manager: يستدعي 2 وحدة
  • core.session_manager: يستدعي 2 وحدة

✅ لا توجد اعتماديات دائرية

🌳 شجرة اعتماديات الملف الرئيسي (app):
├── app
  ├── controllers.app_controller
    ├── controllers.app_controller
      ├── core.airtable_dropdown_manager
        ├── core.airtable_dropdown_manager
          └── core.airtable_manager
      ├── core.airtable_manager
      ├── core.config_manager
        ├── core.config_manager
          └── core.logger
      ├── core.db_manager
        ├── core.db_manager
          └── core.logger
      ├── core.language_manager
        ├── core.language_manager
          ├── core.config_manager
          └── core.logger
      ├── core.logger
      ├── core.theme_manager
        ├── core.theme_manager
          ├── core.config_manager
          └── core.logger
      ├── core.user_manager
        ├── core.user_manager
          ├── core.airtable_manager
          ├── core.db_manager
          └── core.logger
      ├── utils.threading_utils
        ├── utils.threading_utils
          └── core.logger
      ├── views.add_edit_window
        ├── views.add_edit_window
          ├── core.language_manager
          ├── core.logger
          ├── core.theme_color_manager
          ├── utils.window_manager
          └── views.components.combobox
      ├── views.login_window
        ├── views.login_window
          ├── config.login_config
          ├── config.modern_color_palettes
          ├── core.constants
          ├── core.language_manager
          ├── core.logger
          ├── core.security.encryption
          ├── core.security.rate_limiter
          ├── core.theme_color_manager
          ├── core.theme_manager
          ├── utils.validators
          └── utils.window_manager
      └── views.main_window
        ├── views.main_window
          ├── core.event_system
          ├── core.language_manager
          ├── core.logger
          ├── core.permissions
          ├── core.state_manager
          ├── core.theme_color_manager
          ├── core.theme_manager
          ├── utils.async_operations
          ├── utils.image_utils
          ├── utils.window_manager
          ├── views.components.data_table
          ├── views.components.header
          ├── views.components.menu_bar
          ├── views.components.sidebar
          ├── views.components.status_bar
          └── views.components.toolbar
  ├── core.airtable_manager
  ├── core.config_manager
    ├── core.config_manager
      └── core.logger
  ├── core.db_manager
    ├── core.db_manager
      └── core.logger
  ├── core.logger
  ├── core.user_manager
    ├── core.user_manager
      ├── core.airtable_manager
      ├── core.db_manager
        ├── core.db_manager
          └── core.logger
      └── core.logger
  └── views.splash_screen


============================================================
FILE: project_analyzer.py
SIZE: 15466 characters
============================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
Project File Dependency Analyzer
يحلل ملفات المشروع ويرسم شجرة الاستدعاءات والاعتماديات
"""

import os
import ast
import json
import re
from pathlib import Path
from typing import Dict, List, Set, Tuple
from collections import defaultdict, deque
import argparse


class ProjectAnalyzer:
    def __init__(self, project_root: str):
        self.project_root = Path(project_root)
        self.files_info = {}
        self.dependencies = defaultdict(set)
        self.reverse_dependencies = defaultdict(set)
        self.external_imports = defaultdict(set)

    def find_python_files(self) -> List[Path]:
        """البحث عن جميع ملفات Python في المشروع"""
        python_files = []
        for file_path in self.project_root.rglob("*.py"):
            if not any(part.startswith('.') for part in file_path.parts):
                python_files.append(file_path)
        return python_files

    def get_relative_module_name(self, file_path: Path) -> str:
        """تحويل مسار الملف إلى اسم وحدة نسبي"""
        relative_path = file_path.relative_to(self.project_root)
        module_parts = list(relative_path.parts[:-1])  # المجلدات
        filename = relative_path.stem

        if filename != "__init__":
            module_parts.append(filename)

        return ".".join(module_parts) if module_parts else filename

    def parse_imports(self, file_content: str, current_module: str) -> Tuple[Set[str], Set[str]]:
        """استخراج الاستدعاءات من محتوى الملف"""
        local_imports = set()
        external_imports = set()

        try:
            tree = ast.parse(file_content)

            for node in ast.walk(tree):
                if isinstance(node, ast.Import):
                    for alias in node.names:
                        module_name = alias.name
                        if self.is_local_import(module_name):
                            local_imports.add(module_name)
                        else:
                            external_imports.add(module_name)

                elif isinstance(node, ast.ImportFrom):
                    if node.module:
                        module_name = node.module
                        if node.level > 0:  # relative import
                            # معالجة الاستدعاءات النسبية
                            resolved_module = self.resolve_relative_import(
                                current_module, module_name, node.level
                            )
                            if resolved_module:
                                local_imports.add(resolved_module)
                        else:
                            if self.is_local_import(module_name):
                                local_imports.add(module_name)
                            else:
                                external_imports.add(module_name)

        except SyntaxError as e:
            print(f"خطأ في تحليل الملف {current_module}: {e}")

        return local_imports, external_imports

    def is_local_import(self, module_name: str) -> bool:
        """تحديد ما إذا كان الاستدعاء محلي أم خارجي"""
        # قائمة بالمكتبات الخارجية الشائعة
        external_modules = {
            'os', 'sys', 'json', 'ast', 're', 'pathlib', 'typing',
            'collections', 'datetime', 'time', 'logging', 'sqlite3',
            'tkinter', 'threading', 'asyncio', 'urllib', 'http',
            'pandas', 'numpy', 'matplotlib', 'seaborn', 'requests',
            'flask', 'django', 'fastapi', 'aiohttp', 'sqlalchemy',
            'pytest', 'unittest', 'mock', 'cryptography', 'PIL',
            'cv2', 'tensorflow', 'torch', 'sklearn', 'scipy'
        }

        # التحقق من الجذر الأول للوحدة
        root_module = module_name.split('.')[0]

        # إذا كان في قائمة المكتبات الخارجية
        if root_module in external_modules:
            return False

        # التحقق من وجود الملف في المشروع
        possible_paths = [
            self.project_root / f"{module_name.replace('.', '/')}.py",
            self.project_root / f"{module_name.replace('.', '/')}/__init__.py"
        ]

        return any(path.exists() for path in possible_paths)

    def resolve_relative_import(self, current_module: str, import_module: str, level: int) -> str:
        """حل الاستدعاءات النسبية"""
        if not current_module:
            return None

        current_parts = current_module.split('.')

        # إزالة المستويات بناءً على عدد النقاط
        for _ in range(level):
            if current_parts:
                current_parts.pop()

        if import_module:
            return '.'.join(current_parts + [import_module])
        else:
            return '.'.join(current_parts) if current_parts else None

    def analyze_file(self, file_path: Path):
        """تحليل ملف واحد"""
        try:
            with open(file_path, 'r', encoding='utf-8') as f:
                content = f.read()

            module_name = self.get_relative_module_name(file_path)
            local_imports, external_imports = self.parse_imports(content, module_name)

            # تخزين معلومات الملف
            self.files_info[module_name] = {
                'path': str(file_path),
                'size': len(content),
                'lines': len(content.splitlines()),
                'local_imports': list(local_imports),
                'external_imports': list(external_imports)
            }

            # إضافة الاعتماديات
            for imported_module in local_imports:
                self.dependencies[module_name].add(imported_module)
                self.reverse_dependencies[imported_module].add(module_name)

            self.external_imports[module_name] = external_imports

        except Exception as e:
            print(f"خطأ في تحليل الملف {file_path}: {e}")

    def analyze_project(self):
        """تحليل المشروع كاملاً"""
        print("🔍 البحث عن ملفات Python...")
        python_files = self.find_python_files()
        print(f"تم العثور على {len(python_files)} ملف Python")

        print("📖 تحليل الملفات...")
        for file_path in python_files:
            self.analyze_file(file_path)

        print(f"✅ تم تحليل {len(self.files_info)} ملف بنجاح")

    def generate_dependency_tree(self, module: str, visited: Set[str] = None, depth: int = 0) -> str:
        """إنشاء شجرة الاعتماديات لوحدة معينة"""
        if visited is None:
            visited = set()

        if module in visited:
            return "  " * depth + f"├── {module} (دائري)\n"

        visited.add(module)
        tree = "  " * depth + f"├── {module}\n"

        if module in self.dependencies:
            deps = sorted(self.dependencies[module])
            for i, dep in enumerate(deps):
                if i == len(deps) - 1:
                    tree += "  " * (depth + 1) + f"└── {dep}\n"
                else:
                    tree += "  " * (depth + 1) + f"├── {dep}\n"

                if dep in self.dependencies and depth < 3:  # تحديد العمق لتجنب التعقيد
                    tree += self.generate_dependency_tree(dep, visited.copy(), depth + 2)

        return tree

    def find_circular_dependencies(self) -> List[List[str]]:
        """البحث عن الاعتماديات الدائرية"""
        circles = []
        visited = set()

        def dfs(node, path, rec_stack):
            if node in rec_stack:
                # وجدنا دائرة
                circle_start = path.index(node)
                circle = path[circle_start:] + [node]
                circles.append(circle)
                return

            if node in visited:
                return

            visited.add(node)
            rec_stack.add(node)
            path.append(node)

            for neighbor in self.dependencies.get(node, []):
                dfs(neighbor, path, rec_stack)

            path.pop()
            rec_stack.remove(node)

        for module in self.files_info:
            if module not in visited:
                dfs(module, [], set())

        return circles

    def get_most_imported_modules(self, top_n: int = 10) -> List[Tuple[str, int]]:
        """الحصول على أكثر الوحدات استدعاءً"""
        import_counts = {}
        for module, deps in self.reverse_dependencies.items():
            import_counts[module] = len(deps)

        return sorted(import_counts.items(), key=lambda x: x[1], reverse=True)[:top_n]

    def get_most_importing_modules(self, top_n: int = 10) -> List[Tuple[str, int]]:
        """الحصول على الوحدات التي تستدعي أكثر وحدات أخرى"""
        import_counts = {}
        for module, deps in self.dependencies.items():
            import_counts[module] = len(deps)

        return sorted(import_counts.items(), key=lambda x: x[1], reverse=True)[:top_n]

    def generate_report(self) -> str:
        """إنشاء تقرير شامل"""
        report = []
        report.append("=" * 60)
        report.append("📊 تقرير تحليل المشروع")
        report.append("=" * 60)
        report.append("")

        # إحصائيات عامة
        report.append("📈 الإحصائيات العامة:")
        report.append(f"  • عدد الملفات: {len(self.files_info)}")
        total_lines = sum(info['lines'] for info in self.files_info.values())
        report.append(f"  • إجمالي الأسطر: {total_lines:,}")
        total_size = sum(info['size'] for info in self.files_info.values())
        report.append(f"  • إجمالي الحجم: {total_size:,} حرف")
        report.append("")

        # أكثر الوحدات استدعاءً
        report.append("🔗 أكثر الوحدات استدعاءً:")
        most_imported = self.get_most_imported_modules()
        for module, count in most_imported:
            report.append(f"  • {module}: {count} استدعاء")
        report.append("")

        # الوحدات التي تستدعي أكثر وحدات
        report.append("📤 الوحدات التي تستدعي أكثر وحدات:")
        most_importing = self.get_most_importing_modules()
        for module, count in most_importing:
            report.append(f"  • {module}: يستدعي {count} وحدة")
        report.append("")

        # البحث عن الاعتماديات الدائرية
        circles = self.find_circular_dependencies()
        if circles:
            report.append("⚠️  اعتماديات دائرية تم العثور عليها:")
            for i, circle in enumerate(circles, 1):
                report.append(f"  {i}. {' → '.join(circle)}")
        else:
            report.append("✅ لا توجد اعتماديات دائرية")
        report.append("")

        # شجرة الاعتماديات للملف الرئيسي
        if "app" in self.files_info:
            report.append("🌳 شجرة اعتماديات الملف الرئيسي (app):")
            report.append(self.generate_dependency_tree("app"))

        return "\n".join(report)

    def save_detailed_analysis(self, output_file: str = "project_analysis.json"):
        """حفظ التحليل المفصل في ملف JSON"""
        analysis_data = {
            "files": self.files_info,
            "dependencies": {k: list(v) for k, v in self.dependencies.items()},
            "reverse_dependencies": {k: list(v) for k, v in self.reverse_dependencies.items()},
            "external_imports": {k: list(v) for k, v in self.external_imports.items()},
            "statistics": {
                "total_files": len(self.files_info),
                "total_lines": sum(info['lines'] for info in self.files_info.values()),
                "total_size": sum(info['size'] for info in self.files_info.values()),
                "circular_dependencies": self.find_circular_dependencies(),
                "most_imported": self.get_most_imported_modules(),
                "most_importing": self.get_most_importing_modules()
            }
        }

        with open(output_file, 'w', encoding='utf-8') as f:
            json.dump(analysis_data, f, ensure_ascii=False, indent=2)

        print(f"💾 تم حفظ التحليل المفصل في: {output_file}")

    def generate_graphviz_dot(self, output_file: str = "dependency_graph.dot"):
        """إنشاء ملف Graphviz لرسم الشجرة بصرياً"""
        dot_content = ["digraph ProjectDependencies {"]
        dot_content.append("  rankdir=TB;")
        dot_content.append("  node [shape=box, style=filled, fillcolor=lightblue];")
        dot_content.append("")

        # إضافة العقد
        for module in self.files_info:
            # تنسيق اسم العقدة
            clean_name = module.replace(".", "_")
            display_name = module.split(".")[-1] if "." in module else module

            # تحديد اللون بناءً على نوع الملف
            if "controller" in module:
                color = "lightcoral"
            elif "view" in module:
                color = "lightgreen"
            elif "core" in module:
                color = "lightyellow"
            elif "util" in module:
                color = "lightgray"
            else:
                color = "lightblue"

            dot_content.append(f'  {clean_name} [label="{display_name}", fillcolor={color}];')

        dot_content.append("")

        # إضافة الاتصالات
        for module, deps in self.dependencies.items():
            clean_module = module.replace(".", "_")
            for dep in deps:
                clean_dep = dep.replace(".", "_")
                dot_content.append(f"  {clean_module} -> {clean_dep};")

        dot_content.append("}")

        with open(output_file, 'w', encoding='utf-8') as f:
            f.write("\n".join(dot_content))

        print(f"📊 تم إنشاء ملف Graphviz: {output_file}")
        print("لرسم الشجرة، استخدم الأمر: dot -Tpng dependency_graph.dot -o dependency_graph.png")


def main():
    parser = argparse.ArgumentParser(description="تحليل اعتماديات ملفات المشروع")
    parser.add_argument("project_path", nargs="?", default=".",
                       help="مسار المشروع (افتراضي: المجلد الحالي)")
    parser.add_argument("--output", "-o", default="project_analysis",
                       help="اسم ملف الإخراج (بدون امتداد)")
    parser.add_argument("--graphviz", action="store_true",
                       help="إنشاء ملف Graphviz للرسم البصري")

    args = parser.parse_args()

    # التحقق من وجود المشروع
    if not os.path.exists(args.project_path):
        print(f"❌ المسار غير موجود: {args.project_path}")
        return

    print(f"🚀 بدء تحليل المشروع في: {os.path.abspath(args.project_path)}")
    print("-" * 50)

    # إنشاء المحلل
    analyzer = ProjectAnalyzer(args.project_path)

    # تحليل المشروع
    analyzer.analyze_project()

    # إنشاء التقرير
    report = analyzer.generate_report()
    print(report)

    # حفظ التحليل المفصل
    json_file = f"{args.output}.json"
    analyzer.save_detailed_analysis(json_file)

    # حفظ التقرير النصي
    txt_file = f"{args.output}.txt"
    with open(txt_file, 'w', encoding='utf-8') as f:
        f.write(report)
    print(f"📄 تم حفظ التقرير في: {txt_file}")

    # إنشاء ملف Graphviz إذا طُلب
    if args.graphviz:
        dot_file = f"{args.output}.dot"
        analyzer.generate_graphviz_dot(dot_file)


if __name__ == "__main__":
    main()


============================================================
FILE: requirements.txt
SIZE: 784 characters
============================================================

# Core GUI Framework
customtkinter==5.2.2
tkinter-tooltip==2.2.0
tkcalendar==1.6.1

# Airtable Integration
pyairtable==3.1.1
requests==2.31.0

# Configuration & Environment
python-dotenv==1.0.0
PyYAML==6.0.1

# Image Processing
Pillow==11.2.1

# Data Analysis & Visualization
matplotlib==3.10.3
seaborn==0.13.2
pandas==2.2.3
numpy==2.2.5

# Excel & PDF Export
openpyxl==3.1.2
fpdf==1.7.2
reportlab==4.4.1

# Validation (اختياري)
phonenumbers==8.13.0

# System Monitoring (اختياري)
psutil>=5.9.0

# Testing
pytest==8.0.0
pytest-cov==6.1.1
pytest-mock==3.14.0

# Code Quality
black==24.1.1
flake8==7.0.0
isort==6.0.1
mypy==1.15.0

# Documentation
Sphinx==8.2.3
sphinx-rtd-theme==3.0.2

# Build Tools
setuptools==80.9.0
wheel==0.45.1
pyinstaller==6.13.0
pyinstaller-hooks-contrib==2025.3

============================================================
FILE: cache\dropdown_cache.json
SIZE: 48171 characters
============================================================

{
  "guides": {
    "values": [
      "Arabic",
      "Bengali",
      "Burmese",
      "Chinese",
      "English",
      "French",
      "German",
      "Gujarati",
      "Hindi",
      "Italian",
      "Japanese",
      "Javanese",
      "Kannada",
      "Korean",
      "Malayalam",
      "Marathi",
      "Pashto",
      "Persian",
      "Polish",
      "Portuguese",
      "Punjabi",
      "Russian",
      "Spanish",
      "Tamil",
      "Telugu",
      "Thai",
      "Turkish",
      "Ukrainian",
      "Urdu",
      "Vietnamese"
    ],
    "timestamp": "2025-07-03T04:16:24.975910"
  },
  "options": {
    "values": [
      "Adventure Tour",
      "Cultural Tour",
      "Custom Package",
      "Family Package",
      "Full Day",
      "Group Tour",
      "Half Day",
      "Multi-Day",
      "Private Tour",
      "Standard Tour",
      "VIP Experience",
      "test"
    ],
    "timestamp": "2025-07-03T04:16:25.015600"
  },
  "agencies": {
    "values": [
      "FTS-Travels",
      "Other",
      "Ägypten Ausflüge"
    ],
    "timestamp": "2025-07-03T04:16:25.024286"
  },
  "destinations": {
    "values": [
      "Aswan",
      "Cairo",
      "Hurghada",
      "Luxor",
      "Marsa Alam",
      "Sharm El-Sheikh"
    ],
    "timestamp": "2025-07-03T04:16:26.175975"
  },
  "addons": {
    "values": [
      "Transfer Extra: TUI MAGIC LIFE Kalawy, You will pay 25 euros per person for an extra transfer",
      "Transfer Extra: You will pay 10 euros per person for an extra transfer"
    ],
    "timestamp": "2025-07-03T04:16:27.325742"
  },
  "tripnames": {
    "values": [
      "ATV Quad Bike Ride At GIZA Pyramids & BBQ Dinner.",
      "Abu Simbel Sound & light Show - QR Ticket",
      "Abu Simbel Temple QR Tickets",
      "All-inclusive private Trip Pyramids Sphinx, Camel, VIP Lunch",
      "Aswan: Private Nile Boat Cruise and Botanical Garden Visit",
      "Cairo Elite: VIP Airport Welcome or Custom Luxury Tour",
      "Cairo Private Day Trip: Museum , Pyramids & Lunch",
      "Cairo on a Budget: 4-Night Stay & Guided City Highlights",
      "Cairo: 5-Day Egypt Itinerary for Cairo and the Pyramids",
      "Cairo: Customized Full-Day Private Tour",
      "Cairo: Egyptian Museum and National Museum Private Tour",
      "Cairo: Giza Pyramids Tour & Grand Egyptian Museum",
      "Cairo: Giza Pyramids, sphinx and National Museum with Lunch",
      "Cairo: Grand Egyptian Museum Guided Tour and Lunch",
      "Cairo: Guided tour with Al-Hakim Mosque",
      "Cairo: Guided tour with Mosque of Amr ibn al-As",
      "Cairo: Guided tour with Opera House",
      "Cairo: Museum of Islamic Arts QR Tickets & Skip Line",
      "Cairo: Nile Dinner Cruise with Belly Dancer Show and Music",
      "Cairo: Nile Pharaoh Dinner Cruise& Nile with Show",
      "Cairo: Oriental Breakfast (Fatir)or Lunch in arabian village",
      "Cairo: Private Airport Pickup or Drop-Off Service",
      "Cairo: Private Day Tour to Luxor with Sleeper train",
      "Cairo: Private Day Tour to Pharaonic Village",
      "Cairo: Private Jet Sightseeing Tour",
      "Cairo: Private Pyramids Tour with Photographer and Transfer",
      "Cairo: Pyramids & Sphinx Private Tour with Camel Ride",
      "Cairo: Pyramids Arabian Horse or Camel Ride with Bedouin Tea",
      "Cairo: Quad Bike Adventure at Giza Pyramids W/ Camel Ride",
      "Cairo: Sound and Light Show at Giza Pyramids",
      "Cairo: Sound and light show with Dinner with Pyramids view",
      "Cairo: The Coptic Museum QR ticket - Skip The Line",
      "Cairo: Trip Pyramids, Sakkara, & Memphis Tour Lunch",
      "Chatby Tombs Alexandria Day Tour from Cairo",
      "Citadel of Salahdin & Mohamed Ali Mosque QR Ticket",
      "Edfu Temple Sound Light Show Entry Ticket with Transfer",
      "Egyptian Civilization Museum, Citadel & Old Cairo Tour",
      "Egyptian Museum of Antiquities online QR Ticket",
      "Exclusivity: El Gouna Lagoon tour,Snorkel,Dive with Dolphins",
      "From Cairo: Small-Group Day Trip to Luxor by Plane",
      "From Giza/Cairo: Pyramids, Sphinx, and NMEC Tour with Lunch",
      "From Hurghada: Abydos, Osireion, and Dendera Day Tour",
      "From Hurghada: Full-Day Trip to Cairo by Plane",
      "From Hurghada: Historical Tour to Luxor with Hotel Transfer",
      "From Hurghada: Luxor Full-Day Trip with Valley of the Kings",
      "From Hurghada: Majestic Cairo & Giza Highlights Tour By Van",
      "From Hurghada: Two-Day Private Tour of Luxor and Abu Simbel",
      "From Marsa Alam: Private Day Trip to Luxor by Car",
      "From Sharm El-Sheikh: Cairo Day Tour to Pyramids By Bus",
      "From Sharm El-Sheikh: Cairo's Pyramids: Full-Day Journey",
      "From Sharm El-Sheikh: Giza Day Trip with Lunch and Transfer",
      "From Sharm ElSheikh: The Lost City (Petra) Day Tour by Ferry",
      "From Sharm: Ras Muhammed & White Island By Boat & intro Dive",
      "From Sokhna Port: Cairo & Pyramids New Passage Day-Tour",
      "Giza: Grand Egyptian Museum, Old Cairo and Khan Al-khalili",
      "Grand Egyptian Museum QR Ticket",
      "HRG:Private City Tour with Seafood at Barbouni Restaurant",
      "Hurghada to Cairo: Full-Day Tour one way Bus & Flight Return",
      "Hurghada: 2-Day Luxor Tour with Hotel, Balloon, & Nile Boat",
      "Hurghada: Cruise to Bianca Island Utopia w/ Transfer & Lunch",
      "Hurghada: Desert & Sea Horse Riding with + 360° Photos",
      "Hurghada: Desert Quad Bike Tout with Optional GoPro",
      "Hurghada: Desert Quad Bike and Buggy Adventure with Transfer",
      "Hurghada: Diving & Snorkeling Cruise Tour w Lunch & Drinks",
      "Hurghada: Dolphin & Coral Reef Snorkeling Tour with Lunch",
      "Hurghada: Dolphin Watching Boat Tour with Snorkeling & Lunch",
      "Hurghada: Dolphin Watching Cruise, Snorkeling & Lunch",
      "Hurghada: Eden Island Xtreme, Parasail, Dive & Water Sports",
      "Hurghada: Empire Submarine Boat Trip with Snorkel and Drinks",
      "Hurghada: Full-Day Snorkeling Tour in Sharm El Naga w/Lunch",
      "Hurghada: Full-Day Tour to Cairo by Plane with Egyptologist",
      "Hurghada: Full-Day Trip to Cairo by Plane",
      "Hurghada: Giftun Island with breakfast, lunch & Water Sports",
      "Hurghada: Giza Pyramids Day Trip with Nile Boat Tour Option",
      "Hurghada: Glass Boat and Parasailing Trip with Snorkeling",
      "Hurghada: Guided City Highlights Tour with Shopping Stops",
      "Hurghada: Jeep & Camel Safari with Dinner & Desert Fire Show",
      "Hurghada: Jerusalem day tour from Hurghada by flight",
      "Hurghada: Jungle Aqua Park with Lunch & Transfer (Optional)",
      "Hurghada: Karnak, Hatshepsut, and the Valley of the Kings",
      "Hurghada: Luxor Valley of the Kings & Tutankhamun Tomb Trip",
      "Hurghada: Luxury VIP La Rock Spa & Beauty Salon",
      "Hurghada: Makadi Water World with Lunch & Transfers",
      "Hurghada: Mega Jeep safari, ATV & Camel & with Bedouin vibe",
      "Hurghada: Morning or Sunset Sights Guided Tour with Shopping",
      "Hurghada: Neverland Musical Show Entry Tickets with Pickup",
      "Hurghada: Orange Bay Day Trip with Water Sports and Lunch",
      "Hurghada: Orange Bay island With Parachute Adventure & Lunch",
      "Hurghada: Orange Island Snorkeling, Diving, and Water Sports",
      "Hurghada: Orange Island Yacht Trip with Lunch & Water Sports",
      "Hurghada: Private Airport Arrival/Departure One Way Transfer",
      "Hurghada: Quad, Jeep, Camel and Buggy Safari with BBQ Dinner",
      "Hurghada: Red Sea & Desert Horse Riding Tour with Swimming",
      "Hurghada: Safari 5*1 Quad, Stargazing, Horse ride w/ Dinner",
      "Hurghada: Scenic Submarine Tour with Snorkeling and Transfer",
      "Hurghada: Sea and Mountains Quad or Buggy Family Tour",
      "Hurghada: Snorkeling Cruise to Eden Island with Lunch",
      "Hurghada: Star Watching Desert Adventure by Jeep with Dinner",
      "Hurghada: Unique Bedouin Craft, Handmade and Star Watching",
      "Luxor: Caravanserai private Day Tour",
      "Luxor: Half Day Motor Boat Ride with Banana Island Visit",
      "Luxor: Luxor Museum Entry Tickets or Guided Tour",
      "Luxor: Qurna Village in luxor tour and transfer",
      "Marsa Alam: Ancient Cairo & Giza Pyramids Day Trip by Plane",
      "Marsa Alam: Desert Stargazing Tour with Camel Ride & Dinner",
      "Marsa Alam: Hamata Island Snorkeling Trip with Lunch",
      "Marsa Alam: Snorkeling with Sea Turtles Marsa Mubarak",
      "Marsa Alam: Valley of the Kings & Karnak Temples Luxor Tour",
      "Marsa Alam:Sataya Reefs Dolphin Snorkeling Cruise with Lunch",
      "Mummification Museum QR Ticket or Guided tour",
      "National Museum of Egypt Skip-the-Line QR Ticket",
      "One-Way Journey from Sharm El Sheikh to Hurghada",
      "Philae Temple Sound & Light Show in Aswan",
      "Prince Mohamed Ali Palace Manial QR Tickets",
      "Private Customizable Day Tour to Alexandria from Cairo",
      "Private Half-Day Adventure: Giza Pyramids & Sphinx",
      "Private Half-Day Sightseeing Tour to El Gouna from Hurghada",
      "Pyramids of Giza Plateau Entrance Ticket",
      "Red Sea: SCUBA Diving Experience & Snorkeling Boot Tour",
      "Safaga Airport transfer with option meet & assist",
      "Sharm El Sheikh: ATV Dunes & Waves Adventure with Lunch",
      "Sharm El Sheikh: Cleopatra Bath with Deluxe Spa Treatments",
      "Sharm El Sheikh: Mount Sinai & St. Catherine Monastery Tour",
      "Sharm El Sheikh: Private City Tour W Water Sports Adventure",
      "Sharm El Sheikh: Private City Tour with Seafood Dinner",
      "Sharm El Sheikh: Snorkeling Trip to Tiran Island with Lunch",
      "Sharm El Sheikh: Trip to Luxor & Tutankhamun Tomb by Plane",
      "Sharm El-Sheikh Port to Ras Mohamed National Park by Car",
      "Sharm El-Sheikh: ATV and Camel Ride with BBQ Dinner and Show",
      "Sharm El-Sheikh: Airport One-Way Private Hotel Transfer",
      "Sharm El-Sheikh: Cairo Full-Day Meet The Pharaohs by Flight",
      "Sharm El-Sheikh: Camel Riding, Stargazing, BBQ Dinner & Show",
      "Sharm El-Sheikh: City & Shopping Tour With Old Market Visit",
      "Sharm El-Sheikh: Desert Buggy Safari Adventure",
      "Sharm El-Sheikh: Ghibli Raceway Day Trip",
      "Sharm El-Sheikh: Jeep Adventure to Blue Hole, Canyon & Dahab",
      "Sharm El-Sheikh: Morning Desert ATV Quad & Buggy Adventure",
      "Sharm El-Sheikh: Ras Mohamed & White Island Snorkeling Trip",
      "Sharm El-Sheikh: Ras Mohamed Half Day Tour & Allah's gate",
      "Sharm El-Sheikh: Ras Mohammed & White Island Cruise",
      "Sharm El-Sheikh: Stargazing with Luxury Dinner",
      "Sharm El-Sheikh: Ultimate ATV Quad, Stargazing & BBQ Dinner",
      "Sharm El-Sheikh:King Tut Museum QR Ticket with Optional Tour",
      "Sharm ElSheikh: ATV Quad & Buggy Adventure Sunrise or Sunset",
      "Sharm el-Sheikh Museum Entry Ticket & Private Hotel Transfer",
      "Temple of Hatshepsut QR Ticket - Skip The Line",
      "Trip from Cairo to Luxor by Sleeper Train with Shared group",
      "VIP Cairo Experience: Pyramids, ATV Adventure and Camel ride"
    ],
    "timestamp": "2025-07-03T04:16:27.721890"
  },
  "management_options": {
    "values": [
      "0ne guest with entrance fees and two without",
      "1 dbl buggy",
      "1 dbl buggy 2 x fts scarve",
      "1 dbl buggy 2 x fts scarve private transfer private guide",
      "1 dbl buggy 2 x stargazing",
      "1 dbl buggy 3 x fts scarve",
      "1 dbl buggy private guide",
      "1 dbl quaad 1 sgl quad",
      "1 dbl quad",
      "1 dbl quad 1 sgl quad",
      "1 dbl quad 1 x fts scarve",
      "1 dbl quad 2 x fts scarve",
      "1 dbl quad 2 x fts scarve private transfer 2 x vip dinner",
      "1 dbl quad 2 x vip dinner",
      "1 dbl quad 2 x vip dinner 2 x fts scarve",
      "1 dbl quad private guide",
      "1 family 1 trbl buggy 1 dbl buggy",
      "1 family buggy",
      "1 family buggy 2 x fts scarve",
      "1 family buggy stargazing private transfer",
      "1 sgl",
      "1 sgl buggy",
      "1 sgl quad",
      "1 sgl quad 1 x fts scarve",
      "1 trbl buggy",
      "1 trbl buggy 1 dbl buggy",
      "1 trbl buggy 1 x fts scarve",
      "1 trbl buggy 3 x vip dinner",
      "1 x fts scarve",
      "1-hour dolphin show afternoon at dolphina hurghada",
      "1-hour dolphin show afternoon at dolphina with transfers dh-aftn-01",
      "1-hour dolphin show at dolphin world with private transfer",
      "1-hour dolphin show at dolphin world with transfer",
      "1-hour dolphin show morning at dolphin world with transfer",
      "1-hour dolphin show morning at dolphin world with transfer dw-morn-01",
      "1009a 3-hour desert quad bike tour at sunset without gopro",
      "11 sgl quad",
      "123 2-hour horseback riding journey with swimming",
      "1990 dinner cruise on pharaoh",
      "2 days overnight trip with hot air balloon",
      "2 dbl buggy",
      "2 dbl quad",
      "2 dbl quad 1 sgl quad",
      "2 dbl quad 4 x fts scarve",
      "2 dbl quad 4 x vip dinner",
      "2 kids free 2 guide free",
      "2 sgl buggy",
      "2 sgl quad",
      "2 sgl quad 1 x fts scarve",
      "2 sgl quad 2 x fts scarve",
      "2 sgl quad 2 x fts scarve without dinner",
      "2 sgl quad 2 x vip dinner",
      "2 sgl quad without dinner",
      "2 sgl quadpriavte guide",
      "2 trbl buggy",
      "2-day luxor tour shared tour - with entry fees",
      "2-day luxor tour with hotel shared tour - without entry fees",
      "2-hour horse ride",
      "2-hour horse ride journey without swim",
      "2-hour horse ride without swim 14:00",
      "2-hour horseback riding journey with swimming",
      "2-hour horseback riding journey with swimming 123",
      "2-hour ride with swim stop 123",
      "2-hour ride without swim stop",
      "2-hour ride without swim stop 586",
      "2-hour safari with camel ride",
      "2-hour safari with camel ride bike",
      "2-hour safari with camel ride from hurghada",
      "2-hour safari with camel ride from hurghada bike",
      "2-hour swimming horse ride journey 360 photos",
      "2044 stargazing with atv quad ride & jeep",
      "2044 stargazing with quad ride & dance show with private transfer",
      "2212000 arrival at sharm el-sheikh international airport",
      "2212000 from sharm: ras muhammed & white island by boat & intro dive",
      "2212000 single quad - 1 person in 1 quad",
      "2x without entrance fees",
      "3 - hour desert horse ride with swimming - private transfer 586",
      "3 dbl quad",
      "3 dbl quad 1 sgl quad",
      "3 hour camel riding with bedouin vibe with private transfer",
      "3 hours quad tour",
      "3 hours quad tour -",
      "3 sgl quad",
      "3 sgl quad 3 x fts scarve",
      "3 sgl quad 3 x vip dinner 3 x fts scarve",
      "3-horse ride with swim stop",
      "3-horse ride with swim stop 586",
      "3-horse ride without swim stop",
      "3-hour atv quad tour morning with transfer",
      "3-hour atv quad tour morning with transfer without gopro",
      "3-hour atv quad tour sunset with transfer",
      "3-hour atv quad tour sunset with transfer 1009a",
      "3-hour atv quad tour sunset with transfer without gopro 1009a",
      "3-hour desert & sea horse riding with swimming",
      "3-hour desert & sea horse riding with swimming 586",
      "3-hour desert quad bike tour at sunset without gopro 1009a",
      "3-hour desert quad bike tour without gopro",
      "3-hour horse riding with swim",
      "3-hour quad tour with complimentary fts scarf",
      "3-hour sea horse riding with swimming without 360 photos",
      "3-hr horse ride & swim stop -",
      "3-hr horse ride & swim stop - 586",
      "3-hr horse ride & swim stop - makadi sahl hashesh safaga",
      "3-hr horse ride & swim stop - makadi sahl hashesh safaga 586",
      "3-hr horse ride & swim stop promo offer",
      "3-hr horse ride & swim stop promo offer 586",
      "4 dbl quad",
      "4 sgl quad",
      "4 sgl quad 4 x fts scarve",
      "4 sgl quad collect 20 euro",
      "4 sgl quad private transfer 1 x fts scarve 1 x private guide 1 x vip dinner",
      "4-day cairo short break without accommodation",
      "4567 private half-day sightseeing tour to el gouna from hurghada",
      "5 hour desert adventure safari with bbq dinner",
      "5 sgl quad",
      "5-hour atv quad tour with transfer & bbq dinner",
      "5-hour quad safari adventure and dinner bike",
      "5-hour safari with camel ride & dinner: al ahyaa/makadi/sahl",
      "5-hour safari with camel ride & dinner: al ahyaa/makadi/sahl bike",
      "5-hour safari with camel ride and dinner",
      "5-hour safari with camel ride and dinner bike",
      "5-hour safari with camel ride and dinner from hurghada",
      "5-hour safari with camel ride and dinner from hurghada bike",
      "5-hour safari with camel ride from hurghada bike",
      "5555 full-day orange bay group tour",
      "586 3-hour desert & sea horse riding with swimming",
      "586 mega offer: 2-hour horse ride journey without swim",
      "6 sgl quad",
      "618 with atv quad & blue hole tour & abu galum nature",
      "618 with blue hole & abu galum",
      "618 without blue hole & abu galum",
      "686868 family buggy desert safari from sharm el sheikh",
      "8 sgl quad",
      "8-hour safari with buggy camel bedouin village & dinner",
      "8-hour safari with buggy camel bedouin village & dinner buggy",
      "8-hour tour with pickup from cairo airport cai1",
      "8080 cairo private jet sightseeing tour",
      "8885 entry ticket to sharm el naga tour with snorkeling & lunch",
      "96969 hurghada: snorkeling dolphin watching",
      "9876 eden island with lunch on the island",
      "accommodate instead of going back",
      "accommodation transportation guides and entrance fees 17893",
      "afternoon",
      "al ahyaa/makadi bay/sahl hasheesh: 2-hour quad tour bike",
      "all inclusive",
      "all inclusive group tour",
      "all inclusive private trip with entrance fees 321",
      "all inclusive super safari",
      "all inclusive super safari tour",
      "all-inclusive",
      "all-inclusive private trip pyramids sphinx camel vip lunch",
      "all-inclusive private trip pyramids sphinx camel vip lunch 1515",
      "all-inclusive safari: buggy quad camel show & dinner",
      "all-inclusive safari: buggy quad camel show & dinner buggy",
      "all-inclusive super safari private tour",
      "all-inclusive super safari private tour bike",
      "all-inclusive tour: lunch great pyramid & boat",
      "aqua park ticket with transfer & all-inclusive food & drinks",
      "arrival at sharm el-sheikh international airport 2212000",
      "aswan - kom ombo - phaela temple lunch",
      "aswan to luxor cruise & sunrise balloon",
      "atv quad & blue holeabu galum 08:00",
      "atv quad adventure",
      "atv& blue hole tour& abu galum",
      "atv&blue hole tour& abu galum",
      "ausflug von hurghada nach kairo mit dem flugzeug tour type group",
      "ausflug-safaga-nach-luxor-mit-bus tour type group",
      "begginer boat cruise with 2 intro-dives snorkeling lunch",
      "best value tour entry fees & boat ride covered",
      "bike express morning desert safari with jeep quad & buggy",
      "blue bomba: eden island xtremeparasail & dive water sports 1212",
      "boat cruise snorkeling and lunch with private transfer",
      "boat cruise with 2 intro-dives snorkeling lunch premium begginer",
      "boat cruise with 2 snorkeling sites lunch deluxe snorkeling",
      "boat snorkeling lunch with private transfer",
      "boat trip with intro dive and snorkeling equipment",
      "boat trip with snorkeling equipment",
      "boat trip without snorkeling equipment",
      "boat trip without snorkeling equipment snor",
      "buy for 3 people get the fourth free",
      "cai2 cairo or giza: 10-hour private tour with hotel pickup",
      "cairo by bus hurghada",
      "cairo by bus hurghada with entry fees",
      "cairo by bus hurghada without entry fees",
      "cairo by plane: daily tour with entry fees",
      "cairo day tour",
      "cairo day tour with lunch",
      "cairo day tours to giza pyramids & and egmuseum / 6 hours",
      "cairo day trip pyramids & grand egyptian museum & egyptian museum & lunch",
      "cairo day trip with entry fees free hurghada city tour",
      "cairo grand egyptian museum from & khan el khalili bazaar 200134",
      "cairo or giza: 10-hour private tour with hotel pickup",
      "cairo or giza: 10-hour private tour with hotel pickup cai2",
      "cairo or giza: 8-hour private tour with hotel pickup",
      "cairo or giza: 8-hour private tour with hotel pickup 8-hour tour",
      "cairo pyramids day tour by plane hurghada",
      "cairo: egypt tour package: 15 days all-inclusive",
      "cairo: grand egyptian museum guided tour and lunch 85963",
      "cairo: grand egyptian museum qr ticket",
      "cairo: grand egyptian museum qr ticket 708090",
      "cairo: national museum of egypt skip-line qr ticket 2001618",
      "cairo: pharaoh dinner cruise on the with show",
      "cairo: private pyramids tour with photographer and transfer",
      "city & shopping tour with old market & new panorama cafe",
      "city & shopping tour with old market visit",
      "city & shopping tour with old market visit // limo",
      "city group tour without lunch",
      "city tour- small group experience - without lunch & shisha",
      "colored canyon & blue hole",
      "cruise aswan to luxor with meals",
      "dahab",
      "dbl quad",
      "desert & sea horse riding with swimming",
      "desert adventure safari with bbq dinner",
      "desert adventure safari with bbq dinner in 5 hours",
      "desert safari with double quad and stargazing",
      "dh-aftn-01 1-hour dolphin show afternoon at dolphina with transfers",
      "dinner cruise on crystal 1990",
      "dinner cruise on pharaoh",
      "dinner cruise on pharaoh 1990",
      "diving day trip by boat at ras mohamed in sharm el sheikh",
      "diving with dolphin snorkeling & lunch",
      "dolphin swimming hurghada excursion",
      "dolphin swimming hurghada excursion tour type group",
      "dolphin watching boat tour with diving",
      "dolphin watching boat tour with diving & lunch",
      "dolphin watching boat tour with snorkeling & lunch",
      "dolphin watching snorkeling & lunch - tax not include",
      "double buggy - 2 people in 1 buggy",
      "double buggy - 2 people in 1 buggy defaultd",
      "double dune buggy adventure to bedouin village bike",
      "double dune buggy desert safari from sharm el sheikh 686868",
      "double quad - 2 people in 1 quad",
      "double quad mega safari waves and dunes with lunch sunset",
      "dropoff: cairo airport",
      "dropoff: pyramids park",
      "dw-morn-01 1-hour dolphin show morning at dolphin world with transfer",
      "east and west",
      "eden island with lunch on the island 9876",
      "egyptian museumcitadel & old cairo tour without entry fees 1594",
      "el gouna lagoon and dolphin diving with lunch",
      "el gouna lagoon diving with dolphin snorkeling & lunch",
      "el gouna: desert & sea horse riding with swimming",
      "enter inside great pyramid boat",
      "enter the pyramids and ride a camel and lunch",
      "entry fee & inside the pyramid",
      "entry fees",
      "entry fees & boat ride",
      "entry fees & great pyramid",
      "entry fees & king tutankhamun tomb",
      "entry fees & king tutankhamun tomb - private tour",
      "entry fees & tutankhamun tomb",
      "entry fees & tutankhamun tomb 04:30",
      "entry fees and king tutankhamun tomb",
      "entry fees for the grand pyramids and boat",
      "entry fees with valley of the kings king tutankhamun tomb",
      "entry fees with valley of the kings king tutankhamun tomb tut",
      "entry ticket to grand aquarium & zoo tickets with transfers gaz-ht-001",
      "evening desert safari and stargazing",
      "evening dinner cruise in cairo with private transportation",
      "explore together tour with entry fees",
      "express morning desert safari with jeep quad & buggy",
      "express morning desert safari with jeep quad & buggy bike",
      "family buggy",
      "family buggy - 4 people in 1 buggy",
      "family buggy desert safari from sharm el sheikh",
      "family buggy desert safari from sharm el sheikh 686868",
      "family dune buggy adventure to bedouin village",
      "family dune buggy adventure to bedouin village buggy",
      "farsha cafe round-trip hotel transfers",
      "farsha cafe round-trip hotel transfers 202",
      "flight details",
      "flight from hurghada to cairo giza pyramids & grand egyptian museum & khan el khalili",
      "frais dentre et tombeau de toutankhamon",
      "from cairo: 8-day egypt tour with hotel meals & cruise",
      "from giza/cairo: pyramids sphinx and nmec tour with lunch",
      "from hurghada to giza pyramids and egyption museum tour type group",
      "from hurghada to giza pyramids and egyption museum tour type group without entry",
      "from hurghada: abydos osireion and dendera day tour",
      "from hurghada: private el gouna sightseeing half-day trip",
      "from hurghada: private el gouna sightseeing half-day trip 4567",
      "from marsa alam to pyramids",
      "from sharm el sheikh: guided day trip to luxor by plane",
      "from sharm el-sheikh: giza day trip with lunch and transfer 36963",
      "from sharm el-sheikh: ras mohammed & white island cruise ras muhammed",
      "from sharm elsheikh: the lost city day tour by ferry",
      "from sharm: ras muhammed & white island by boat & intro dive 17896",
      "from sharm: ras muhammed & white island by boat & intro dive 2212000",
      "from sharm: white island and ras mohamed snorkeling trip",
      "from the airport to hotels in sharm el-sheikh",
      "from-hurghada-to-the-pyramids-day-tour",
      "full-day giftun island trip",
      "full-day group tour to orange bay with",
      "full-day group tour with diving",
      "full-day group tour with diving 5555",
      "full-day group tour with entrance fees 5555",
      "full-day group tour with environmental fees 1122",
      "full-day group tour without entrance fees",
      "full-day group tour without entrance fees 5555",
      "full-day group tour without environment fees",
      "full-day group tour without environment fees 5555",
      "full-day group tour without environments fees",
      "full-day group tour without environments fees 5555",
      "full-day orange bay group tour",
      "full-day orange bay group tour 5555",
      "full-day trip to giftun island & orange island entrance fees gif",
      "full-day trip to giftun island & orange island with lunch gif",
      "full-day trip to giftun island with island entrance fees gif",
      "gaz-ht-001 entry ticket to grand aquarium & zoo tickets with transfers",
      "gif full-day trip to giftun island & orange island with lunch",
      "giza pyramids tour in english with entrance fees",
      "great pyramid",
      "great pyramid & boat",
      "group",
      "group city tour",
      "group tour entry fees",
      "group tour with entry fees",
      "group tour with entry fees one way transfer to luxor",
      "group tour with entry fees one way transfer to luxor o/n",
      "group tour with entry fees shared tour entrance",
      "group tour with entry fees with boat",
      "group tour without entry fees",
      "haice",
      "hiace",
      "hiace 1",
      "hiace 2",
      "hiace 2 with new panorama",
      "hiace 3",
      "hiace 4",
      "horseback riding from hurghada",
      "hrg quad jeep camel and buggy safari with bbq dinner",
      "hrg-eden hurghada: eden island xtreme parasail dive & water sports",
      "hrg-jeep-safari hurghada: jeep & camel safari with dinner & desert fire show",
      "hrg:private city tour with seafood at barbouni restaurant 5",
      "hurghada 2-day tour to luxor",
      "hurghada : diving & snorkeling cruise tour w lunch & drinks 08:00",
      "hurghada cairo pyramids day tour by plane - small group",
      "hurghada desert quad bike safari with dinner",
      "hurghada full-day trip to cairo by bus",
      "hurghada full-day trip to cairo by plane",
      "hurghada horse riding tour 3 hours",
      "hurghada morning or sunset sights guided tour with shopping",
      "hurghada pyramids excursion",
      "hurghada quad bike tour with stargazing telescope and dinner 4040",
      "hurghada quad tour afternoon",
      "hurghada scuba diving tour",
      "hurghada snorkelling & swimming with dolphin",
      "hurghada-pyramiden-ausflug tour type group",
      "hurghada: 2-hour camel ride with bedouin vibe",
      "hurghada: 3 hour camel riding with bedouin vibe",
      "hurghada: 3-hour camel ride with bedouin vibe",
      "hurghada: city tour with handicrafts museum entry tickets 258",
      "hurghada: dolphin & coral reef snorkeling tour with lunch",
      "hurghada: dolphin watching boat tour with snorkeling & lunch",
      "hurghada: eden island sirene boat snorkeling trip 1212",
      "hurghada: eden island xtreme parasail dive & water sports",
      "hurghada: glass boat and parasailing trip with snorkeling",
      "hurghada: jeep & camel safari with dinner & desert fire show",
      "hurghada: jungle aqua park with lunch & transfer",
      "hurghada: jungle aqua park with lunch & transfer 09:00",
      "hurghada: luxor valley of kings day trip include entry fees",
      "hurghada: luxor valley of kings day trip include entry fees tour type group",
      "hurghada: majestic vip cruise to orange bay & gourmet lunch vip",
      "hurghada: makadi water world ticket only",
      "hurghada: makadi water world with lunch & transfers",
      "hurghada: makadi water world with lunch & transfers 09:00",
      "hurghada: orange bay day trip with parasailing and lunch",
      "hurghada: orange bay day trip with parasailing and lunch 5555",
      "hurghada: orange bay day trip with water sports and lunch",
      "hurghada: orange bay day trip with water sports and lunch 5555",
      "hurghada: orange island snorkeling diving and water sports hrg-4in1",
      "hurghada: private airport arrival one way transfer",
      "hurghada: private sightseeing tour in el gouna with transfer",
      "hurghada: quad jeep camel and buggy safari with bbq dinner",
      "hurghada: royal sea scope submarine & snorkeling day tour",
      "hurghada: semi submarine & snorkeling day tour",
      "hurghada: semi submarine & snorkeling with transfer",
      "hurghada: semi submarine & snorkeling with transfer semi -sub",
      "hurghada: semi submarine & snorkeling with transfer semi-sub",
      "hurghada: sharm el naga tour with snorkeling & lunch 8885",
      "hurghada: snorkeling dolphin watching & banana boat fun 96969",
      "hurghada: snorkeling dolphin watching 96969",
      "hurghada: thrilling desert safari with quad buggy & bbq experience tour type group",
      "hurghada: unique bedouin craft handmade and star watching 9090",
      "include entry fees",
      "include entry fees tutankhamounvisit utankhamoun",
      "intro 1 x 1",
      "intro 1 x 2",
      "intro 2 x 1",
      "intro 2 x 2",
      "intro 3 x 1",
      "intro 3 x 2",
      "intro 4 x 2",
      "intro 5 x 1",
      "intro 6 x 1",
      "jaz aquaviva",
      "jungle aqua park with lunch without transfer",
      "karnak temple sound & light show qr ticket with transfer",
      "last-minute: group tour entry fees",
      "limo",
      "lowest price",
      "luxor adventure: all-inclusive group tour with entry fees",
      "luxor by bus",
      "luxor day tour with tutankhamun tomb entry fee",
      "luxor day tour without tutankhamun tomb entry fee",
      "luxor day trip",
      "luxor day trip with entry fees free hurghada city tour",
      "luxor museum guided tour",
      "luxor valley of kings day trip include entry fees",
      "luxor: private 10-hour tour with hotel or airport pickup",
      "luxor: private 10-hour tour with hotel or airport pickup lxr 4",
      "luxor: private 10-hour tour with pickup from hotel lxr 4",
      "luxor: private 6-hour tour with hotel pickup",
      "luxor: private 8-hour tour with hotel or airport pickup lxr 3",
      "luxor: private 8-hour tour with hotel pickup lxr 3",
      "lxr 4 luxor: private 10-hour tour with hotel or airport pickup",
      "lxr-private tour private tour vip service with entry fees",
      "makadi water world with lunch & private transfer",
      "makadi water world with lunch & transfers",
      "marsa alam : luxor valley of kings day trip include entry fees",
      "marsa alam: beginners scuba diving day-trip with lunch rmf",
      "marsa alam: desert stargazing tour with camel ride & dinner 2044",
      "marsa alam: snorkeling with sea turtles marsa mubarak rmf",
      "marsa alam:sataya reefs dolphin snorkeling cruise with lunch rmf",
      "massage spa",
      "mega offer: 2-hour horse ride journey",
      "mega offer: 2-hour horse ride journey with swim 123",
      "mega offer: 2-hour horse ride journey without swim",
      "mega offer: 2-hour horse ride journey without swim 586",
      "mega offer: 2-hour horse ride without 360 photos",
      "mega offer: 3-hour horse ride journey with swim 586",
      "mega offer:2-hour horse ride without 360 photos",
      "morning desert safari adventure buggy",
      "morning sunset quad desert adventure safari",
      "morning sunset quad desert adventure safari bike",
      "morning sunset quad or buggy desert adventure safari",
      "morning/ sunset quad or buggy desert adventure safari",
      "moses mountain & saint catherine from dahab",
      "museums only",
      "museums with citadel of saladin bazaar and old cairo 2xm cit",
      "n/a stargazing with jeep tour only",
      "neverland aqua park entry tickets without transfers",
      "neverland aqua park entry with transfer from hurghada",
      "new panorama sharm cafe & restaurant",
      "new panorama sharm cafe & restaurant fphn12",
      "no entry fees- mon/thurs offer",
      "no entry fees- mon/thurs offer 04:30",
      "no entry fees- sun/thurs offer",
      "no entry fees-mon/thurs offer",
      "oasis",
      "offer for one reduced ticket with lunch",
      "old cairo with citadel and lunch",
      "one way sleeper train to luxor",
      "one-way journey from sharm el sheikh to hurghada",
      "online qr ticket for egyptian museum",
      "option: 5555 full-day group tour with entrance fees",
      "option: bike all-inclusive super safari private tour",
      "option: buggy 8-hour safari with buggy camel bedouin village & dinner",
      "option: buy for 3 people get the fourth free",
      "option: desert safari with double quad and stargazing",
      "option: group tour without entry fees",
      "option: n/a stargazing with jeep tour",
      "option: offer for one reduced ticket with lunch",
      "option: quad and double buggy tour makadi sahl hasheesh safaga",
      "option: shared tour entrance group tour with entry fees",
      "option: small group tour: lunch entry fees & inside great pyramid",
      "option: small group with entry fees",
      "option: tut entry fees with valley of the kings king tutankhamun tomb",
      "orange bay day trip with parasailing",
      "orange bay day trip with parasailing 5555",
      "orange bay day trip with parasailing and lunch",
      "orange bay group tour",
      "orange bay group tour 5555",
      "orange bay island snorkeling",
      "orange bay island trip snorkeling & parasailing with lunch",
      "orange bay with a free glass boat cruise the next day",
      "package",
      "panoramic semi-submarine cruise with snorkeling",
      "pickup from hurghada",
      "premium begginer boat cruise with 2 intro-dives snorkeling lunch",
      "private",
      "private 1-hour boat ride and banana island visit",
      "private 10-hour tour with hotel or airport pickup lxr 4",
      "private 10-hour tour with pickup from hotel",
      "private 10-hour tour with pickup from hotel lxr 4",
      "private 2-day tour with entry fees tickets & balloon ride",
      "private 2-day tour with entry fees tickets & balloon ride o/n lxr 3",
      "private 6-hour customized tour with pickup at airport lxr 2",
      "private 6-hour tour with hotel pickup",
      "private 8-hour tour with hotel or airport pickup",
      "private 8-hour tour with hotel or airport pickup lxr 3",
      "private 8-hour tour with hotel pickup aracan eatabe luxor hotel",
      "private 8-hour tour with hotel pickup lxr 3",
      "private city & shopping tour with old market private",
      "private city tour with lunch & shisha pipe experience",
      "private city tour with lunch and shisha",
      "private city tour with personalized experience & shisha pipe",
      "private city tour with shisha and without lunch",
      "private guided",
      "private guided tour private tour",
      "private half-day sightseeing tour to el gouna from hurghada 4567",
      "private luxury beach and horse photoshoot experience photoshoot",
      "private tour",
      "private tour - with entry fees",
      "private tour - without entry fees",
      "private tour all-inclusive",
      "private tour vip service with entry fees",
      "private tour vip service with entry fees lxr-private tour",
      "private tour with entrance fees",
      "private tour with male guide",
      "private transfer",
      "private transfer with 5-hour safari and bbq dinner",
      "private transfer with 5-hour safari and bbq dinner buggy",
      "promo: 1 person free includes lunch & entry tickets",
      "pyramids & sphinx uncovered private half-day tour",
      "pyramids and the national museum 5555",
      "quad and double buggy tour",
      "quad and double buggy tour from hurghada",
      "quad and double buggy tour from hurghada or gouna",
      "quad and double buggy tour makadi sahl hasheesh safaga",
      "quad and double buggy tour sahl hasheesh safaga",
      "quad and double buggy tour with camel ride experience",
      "quad bike adventure at giza pyramids",
      "quad bike adventure at giza pyramids with camel ride",
      "quad buggy desert safari and barbecue",
      "quad double buggy tour from hurghada - private transfer",
      "quad jeep camel and buggy safari with bbq dinner hrg",
      "quad tour along the sea and mountains in hurghada",
      "quad tour along the sea and mountains in hurghada 08:00",
      "quad tour along the sea and mountains in hurghada 15:00",
      "quad-safari-hurghada",
      "ras mohamed half day tour & allahs gate",
      "ras mohammed snorkeling trip sharm el sheikh",
      "ras muhammed sharm el-sheikh: ras mohammed & white island cruise",
      "red sea desert horse ride with swimming - private transfer",
      "red sea desert horse ride with swimming - private transfer 586",
      "red sea: orange bay island and snorkeling cruise with lunch",
      "rmf marsa alam: snorkeling with sea turtles marsa mubarak",
      "rmf marsa alam:sataya reefs dolphin snorkeling cruise with lunch",
      "round tickets - sleeper train - to luxor",
      "royal seascope submarine with snorkeling from hurghada",
      "safari 51 quad stargazing",
      "safari to colored canyon and dahab tour type group",
      "scuba diving tour in hurghada",
      "seafood dinner",
      "seamless shared tour entry fees covered",
      "semi -sub hurghada: semi submarine & snorkeling with transfer",
      "shared day trip boat ride and entry included",
      "shared experience entry fees & lunch included",
      "shared group journey entry fees lunch & inside pyramid",
      "shared tour - pay as you explore",
      "shared tour - with entry fees",
      "shared tour - with entry fees 04:30",
      "shared tour - without entry fees",
      "shared tour - without entry fees in select languages",
      "shared tour with all entry fees and king tutankhamun tomb",
      "shared tour with entry fees",
      "shared tour with entry fees and king tutankhamuns tomb",
      "shared tour with entry fees lxr-inc-tickets",
      "shared tour with lunch - without entry fees no",
      "shared tour with lunch and entry fees",
      "shared tour with male guide",
      "shared tour without entrrance fees",
      "shared tour without entry fees",
      "shared transfer lunch and intro dive",
      "sharm el sheikh: mount sinai & st catherine monastery tour",
      "sharm el sheikh: private city tour with seafood dinner",
      "sharm el sheikh: snorkeling trip to tiran island with lunch",
      "sharm el-sheikh : ras mohamed half day tour & allahs gate",
      "sharm el-sheikh: cafe & restaurant included shisha & drink",
      "sharm el-sheikh: city & shopping tour with old market visit",
      "sharm el-sheikh: city & shopping tour with old market visit // hiace",
      "sharm el-sheikh: departure transfer from hotel to airport 2212000",
      "sharm el-sheikh: ghibli raceway day trip",
      "sharm el-sheikh: ras mohamed half day tour & allahs gate",
      "sharm el-sheikh: ras mohammed & white island cruise ras muhammed",
      "sharm elsheikh: camel riding stargazing bbq dinner & show",
      "single buggy - 1 person in 1 buggy",
      "single quad - 1 person in 1 quad",
      "single quad - 1 person in 1 quad 2212000",
      "single quad mega safari waves and dunes with lunch sunset",
      "sirius palace luxor",
      "small group cairo tour with lunch and entry fees included",
      "small group tour including lunch excluding entry fee",
      "small group tour with entry fees",
      "small group tour without entry fees",
      "small group tour without entry fees 123",
      "small group tour: lunch entry fees & inside great pyramid",
      "small group with entry fees",
      "small-group tour with boat cruise",
      "snor white island & ras mohamed without entrance fees",
      "snorkeling dolphin watching with a private transfer",
      "snorkeling dolphin watching with a private transfer 96969",
      "sound and light show regular price",
      "sound and light show regular price with transfer",
      "sound and light show vip price",
      "sound and light show vip price with transfer",
      "stargazing adventure with jeep tour",
      "stargazing by jeep & dance show with private transfer 2044",
      "stargazing desert adventure by jeep with dinner hurghada",
      "stargazing telescope and dinner 4040",
      "stargazing trip with a double quad",
      "stargazing trip with a single quad",
      "stargazing trip with double quad - 2 people in 1 quad",
      "stargazing trip with single quad - 1 person in 1 quad",
      "stargazing with atv quad ride & jeep",
      "stargazing with atv quad ride & jeep 2044",
      "stargazing with jeep tour",
      "stargazing with jeep tour n/a",
      "stargazing with jeep tour only",
      "stargazing with jeep tour only n/a",
      "stargazing with jeep tour with privite transfer",
      "stargazing with jeep with private transfer",
      "stargazing with quad ride",
      "stargazing with quad ride & dance show with private transfer",
      "stargazing with quad ride & dance show with private transfer 2044",
      "stargazing with quad ride 2044",
      "stargazing with quad ride and dance show 2044",
      "stargazing-camel ride-bbq-marsa alam",
      "stay for 3 hours at 6 october / dropoff pyramids park",
      "sunrise atv quad adventure",
      "sunset atv quad adventure with dinner",
      "sunset atv quad adventure without dinner",
      "sunset desert quad bike adventure with camel ride experience 1009a",
      "sunset double quad mega safari waves and dunes with lunch",
      "sunset quad bike & camel ride 4040",
      "super safari all inclusive",
      "swimming with dolphins in safaga tour type group",
      "ticket with tour and transfer",
      "top deal: inside great pyramids scenic boat ride",
      "top value experience entry fees covered",
      "top value experience entry fees covered lxr-inc-tickets",
      "tour : 3-hour quad tour safaga",
      "tour : hurghada-safari-quad biking-camel riding tour type group",
      "tour : hurghada: luxor valley of kings day trip include entry fees",
      "tour : hurghada: thrilling desert safari with quad buggy & bbq experience",
      "tour : marsa alam sataya reefs dolphin snorkel cruise with lunch tour type group",
      "tour hurghada with dune buggy",
      "tour hurghada with dune buggy: this option includes quad bike ride in the desert dune buggy ride in the desert an encounter and with an arabian camel",
      "tour in a double quad - from sahl hasheesh & safaga 122",
      "tour in a double quad - pickup from hurghada 122",
      "tour in a double quad - pickup from hurghada and el gouna 122",
      "tour type group",
      "tour with boat cruise",
      "tour with camel riding stargazing bbq dinner & show",
      "tour with entry fees",
      "tour with entry fees 04:30",
      "tour with entry fees in select languages",
      "tour with entry fees lunch & inside great pyramid",
      "tour with male guide",
      "tour with single quad bike",
      "transfer only : tour to pyramidsmemphis &saqqara from hotel",
      "transfer to aswan by car",
      "transfer to cairo airport flight cairo-hurghada ms46 am",
      "trip include entry fees",
      "trip with entry fees",
      "trip with entry fees and boat tour",
      "trip with entry fees great pyramid and boat ride",
      "trip- no entry fees no",
      "triple buggy - 3 person in 1 buggy",
      "trips in hurghada sightseeing private city tour",
      "turkish bath spa",
      "ultimate atv quad stargazing & bbq dinner",
      "ultimate tour lunch great pyramid & boat included",
      "unforgettable day at orange bay",
      "unique bedouin craft handmade and star watching 9090",
      "vip hurghada: magician plus vip cruise to orange bay & seafood",
      "visit luxor temple & the valley of the king & hatsehpsut &lunch",
      "visit the pyramids and the sphinx and dinner cruise",
      "von-hurghada-zu-den-pyramiden-tagestour tour type group",
      "walk with the pharaohs: entry fees & tutankhamun tomb access",
      "white hills",
      "white island & ras mohamed without entrance fees",
      "white island & ras mohamed without entrance fees snor",
      "white island and ras mohamed with entrance fees",
      "with atv quad & blue hole tour & abu galum nature",
      "with atv quad & blue hole tour & abu galum nature 618",
      "with atv quad & blue hole tour & abu galum nature 618x",
      "with atv quad & entrance fees",
      "with atv quad & entrance fees 1 x fts scarve",
      "with atv quad & entrance fees 2 x fts scarve",
      "with atv quad & entrances",
      "with atv quad & entrances fees",
      "with atv quad &entrance fees",
      "with atv quad/without blue hole tour & abu galum 618",
      "with atv quad/without blue hole tour & abu galum nature 618",
      "with blue hole & abu galum",
      "with blue hole & abu galum 2212000",
      "with blue hole & abu galum 618",
      "with entrance fees",
      "with entrance fees 08:00",
      "with entrance fees 2 x fts scarve",
      "with entrance fees of blue hole tour & abu galum",
      "with entrance fees of blue hole tour & abu galum 618",
      "with entry fees",
      "with entry fees & entry great pyramid",
      "with entry fees - private tour",
      "with entry fees - rmf",
      "with entry fees and tutankhamun tomb",
      "with entry fees one egyptian stu",
      "with entry fees pick up ftom sahl hashish",
      "with equipment",
      "without blue hole & abu galum",
      "without blue hole & abu galum 618",
      "without entrance fees",
      "without entrance fees 04:30",
      "without entrance fees 2 x fts scarve",
      "without entrance fees of blue hole tour & abu galum",
      "without entrance fees of blue hole tour & abu galum 618",
      "without entry fees",
      "without equipment",
      "without snorkeling",
      "yacht trip with island visit and lunch"
    ],
    "timestamp": "2025-07-03T04:16:37.115664"
  }
}

============================================================
FILE: config\login_config.py
SIZE: 6796 characters
============================================================

# -*- coding: utf-8 -*-
"""
config/login_styles.py

تكوين الأنماط والألوان الاحترافية لنافذة تسجيل الدخول
Professional Styles Configuration for Login Window
"""

# لوحة الألوان الاحترافية
PROFESSIONAL_THEMES = {
    'light': {
        # الألوان الأساسية
        'primary': '#2563eb',           # أزرق احترافي
        'primary_hover': '#1d4ed8',     # أزرق داكن
        'primary_light': '#dbeafe',     # أزرق فاتح جداً

        # الألوان الثانوية
        'secondary': '#64748b',         # رمادي أنيق
        'secondary_hover': '#475569',   # رمادي داكن
        'secondary_light': '#e2e8f0',   # رمادي فاتح

        # ألوان الحالة
        'success': '#10b981',           # أخضر عصري
        'success_hover': '#059669',     # أخضر داكن
        'success_light': '#d1fae5',     # أخضر فاتح

        'danger': '#ef4444',            # أحمر حديث
        'danger_hover': '#dc2626',      # أحمر داكن
        'danger_light': '#fee2e2',      # أحمر فاتح

        'warning': '#f59e0b',           # برتقالي
        'warning_hover': '#d97706',     # برتقالي داكن
        'warning_light': '#fef3c7',     # برتقالي فاتح

        'info': '#3b82f6',              # أزرق معلوماتي
        'info_hover': '#2563eb',        # أزرق معلوماتي داكن
        'info_light': '#dbeafe',        # أزرق معلوماتي فاتح

        # ألوان الخلفية والسطح
        'background': '#f8fafc',        # خلفية رئيسية
        'surface': '#ffffff',           # سطح البطاقات
        'surface_hover': '#f9fafb',     # سطح عند المرور

        # الحدود والظلال
        'border': '#e2e8f0',            # حدود عادية
        'border_focus': '#2563eb',      # حدود عند التركيز
        'shadow': 'rgba(0, 0, 0, 0.1)', # لون الظل
        'shadow_hover': 'rgba(0, 0, 0, 0.15)', # ظل عند المرور

        # النصوص
        'text_primary': '#1e293b',      # نص أساسي
        'text_secondary': '#64748b',    # نص ثانوي
        'text_tertiary': '#94a3b8',     # نص ثالثي
        'text_disabled': '#cbd5e1',     # نص معطل
        'text_inverse': '#ffffff',      # نص معكوس
    },

    'dark': {
        # الألوان الأساسية
        'primary': '#3b82f6',           # أزرق لامع
        'primary_hover': '#2563eb',     # أزرق أكثر لمعاناً
        'primary_light': '#1e3a8a',     # أزرق داكن

        # الألوان الثانوية
        'secondary': '#6b7280',         # رمادي متوسط
        'secondary_hover': '#9ca3af',   # رمادي فاتح
        'secondary_light': '#374151',   # رمادي داكن

        # ألوان الحالة
        'success': '#10b981',           # أخضر لامع
        'success_hover': '#34d399',     # أخضر فاتح
        'success_light': '#064e3b',     # أخضر داكن

        'danger': '#f87171',            # أحمر لامع
        'danger_hover': '#fca5a5',      # أحمر فاتح
        'danger_light': '#7f1d1d',      # أحمر داكن

        'warning': '#fbbf24',           # أصفر لامع
        'warning_hover': '#fcd34d',     # أصفر فاتح
        'warning_light': '#78350f',     # أصفر داكن

        'info': '#60a5fa',              # أزرق معلوماتي لامع
        'info_hover': '#93bbfc',        # أزرق معلوماتي فاتح
        'info_light': '#1e3a8a',        # أزرق معلوماتي داكن

        # ألوان الخلفية والسطح
        'background': '#0f172a',        # خلفية داكنة
        'surface': '#1e293b',           # سطح البطاقات
        'surface_hover': '#334155',     # سطح عند المرور

        # الحدود والظلال
        'border': '#334155',            # حدود داكنة
        'border_focus': '#3b82f6',      # حدود عند التركيز
        'shadow': 'rgba(0, 0, 0, 0.5)', # لون الظل
        'shadow_hover': 'rgba(0, 0, 0, 0.7)', # ظل عند المرور

        # النصوص
        'text_primary': '#f1f5f9',      # نص أساسي فاتح
        'text_secondary': '#cbd5e1',    # نص ثانوي
        'text_tertiary': '#94a3b8',     # نص ثالثي
        'text_disabled': '#475569',     # نص معطل
        'text_inverse': '#0f172a',      # نص معكوس
    }
}

# تأثيرات الظلال
SHADOW_EFFECTS = {
    'sm': '0 1px 2px 0 rgba(0, 0, 0, 0.05)',
    'md': '0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -1px rgba(0, 0, 0, 0.06)',
    'lg': '0 10px 15px -3px rgba(0, 0, 0, 0.1), 0 4px 6px -2px rgba(0, 0, 0, 0.05)',
    'xl': '0 20px 25px -5px rgba(0, 0, 0, 0.1), 0 10px 10px -5px rgba(0, 0, 0, 0.04)',
    '2xl': '0 25px 50px -12px rgba(0, 0, 0, 0.25)',
    'inner': 'inset 0 2px 4px 0 rgba(0, 0, 0, 0.06)',
    'none': 'none'
}

# تكوينات الخطوط
FONT_CONFIG = {
    'primary_family': 'Segoe UI',      # الخط الأساسي لـ Windows
    'secondary_family': 'Helvetica',   # خط احتياطي
    'arabic_family': 'Tahoma',         # خط عربي

    'sizes': {
        'xs': 10,
        'sm': 12,
        'base': 14,
        'lg': 16,
        'xl': 18,
        'xxl': 24,
        'xxxl': 30
    },

    'weights': {
        'normal': 'normal',
        'medium': 'normal',
        'bold': 'bold'
    }
}

# تكوينات الانتقالات والحركات
ANIMATION_CONFIG = {
    'durations': {
        'fast': 150,      # ميلي ثانية
        'normal': 300,
        'slow': 500
    },

    'easing': {
        'linear': 'linear',
        'ease_in': 'ease-in',
        'ease_out': 'ease-out',
        'ease_in_out': 'ease-in-out'
    }
}

# تكوينات الأبعاد والمسافات
SPACING_CONFIG = {
    'padding': {
        'xs': 5,
        'sm': 10,
        'md': 15,
        'lg': 20,
        'xl': 30
    },

    'margin': {
        'xs': 5,
        'sm': 10,
        'md': 15,
        'lg': 20,
        'xl': 30
    },

    'border_radius': {
        'none': 0,
        'sm': 5,
        'md': 10,
        'lg': 15,
        'xl': 20,
        'full': 9999  # للدوائر الكاملة
    },

    'border_width': {
        'thin': 1,
        'normal': 2,
        'thick': 3
    }
}

# دالة للحصول على موضوع حسب الوضع
def get_theme_colors(mode='light'):
    """الحصول على ألوان الموضوع حسب الوضع"""
    return PROFESSIONAL_THEMES.get(mode, PROFESSIONAL_THEMES['light'])

# دالة لتطبيق الظل على عنصر
def apply_shadow(widget, shadow_type='md'):
    """تطبيق تأثير الظل على عنصر"""
    # ملاحظة: customtkinter لا يدعم الظلال مباشرة
    # هذه الدالة للتوثيق والاستخدام المستقبلي
    return SHADOW_EFFECTS.get(shadow_type, SHADOW_EFFECTS['md'])

# دالة للحصول على حجم الخط
def get_font_size(size='base', is_small_window=False):
    """الحصول على حجم الخط المناسب"""
    base_size = FONT_CONFIG['sizes'].get(size, 14)
    if is_small_window:
        return max(base_size - 2, 10)  # تقليل الحجم للشاشات الصغيرة
    return base_size

# دالة لإنشاء تكوين خط كامل
def get_font_config(size='base', weight='normal', is_small_window=False):
    """الحصول على تكوين خط كامل"""
    return {
        'family': FONT_CONFIG['primary_family'],
        'size': get_font_size(size, is_small_window),
        'weight': FONT_CONFIG['weights'].get(weight, 'normal')
    }

============================================================
FILE: config\modern_color_palettes.py
SIZE: 5867 characters
============================================================

# -*- coding: utf-8 -*-
"""
config/modern_color_palettes.py

لوحات ألوان عصرية إضافية لنافذة تسجيل الدخول
Additional Modern Color Palettes for Login Window
"""

# لوحات الألوان العصرية
MODERN_PALETTES = {
    # اللوحة الحالية - بنفسجية عصرية
    'modern_purple': {
        'primary': '#5B5FFF',
        'primary_hover': '#4B4FEF',
        'secondary': '#6B7280',
        'success': '#10B981',
        'danger': '#F43F5E',
        'danger_hover': '#E11D48',
        'background': '#F9FAFB',
        'surface': '#FFFFFF',
        'input_bg': '#F3F4F6',
        'input_border': '#D1D5DB',
        'input_focus': '#5B5FFF',
        'border': '#E5E7EB',
        'text_primary': '#111827',
        'text_secondary': '#6B7280',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة أزرق كحلي عصري
    'modern_blue': {
        'primary': '#0EA5E9',
        'primary_hover': '#0284C7',
        'secondary': '#64748B',
        'success': '#22C55E',
        'danger': '#EF4444',
        'danger_hover': '#DC2626',
        'background': '#F8FAFC',
        'surface': '#FFFFFF',
        'input_bg': '#F1F5F9',
        'input_border': '#CBD5E1',
        'input_focus': '#0EA5E9',
        'border': '#E2E8F0',
        'text_primary': '#0F172A',
        'text_secondary': '#64748B',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة خضراء زمردية
    'modern_emerald': {
        'primary': '#10B981',
        'primary_hover': '#059669',
        'secondary': '#6B7280',
        'success': '#34D399',
        'danger': '#F87171',
        'danger_hover': '#EF4444',
        'background': '#F9FAFB',
        'surface': '#FFFFFF',
        'input_bg': '#F3F4F6',
        'input_border': '#D1D5DB',
        'input_focus': '#10B981',
        'border': '#E5E7EB',
        'text_primary': '#111827',
        'text_secondary': '#6B7280',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة وردية عصرية
    'modern_pink': {
        'primary': '#EC4899',
        'primary_hover': '#DB2777',
        'secondary': '#6B7280',
        'success': '#10B981',
        'danger': '#F43F5E',
        'danger_hover': '#E11D48',
        'background': '#FEF3F2',
        'surface': '#FFFFFF',
        'input_bg': '#FEE2E2',
        'input_border': '#FCA5A5',
        'input_focus': '#EC4899',
        'border': '#FBBF24',
        'text_primary': '#1F2937',
        'text_secondary': '#6B7280',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة داكنة احترافية
    'modern_dark': {
        'primary': '#6366F1',
        'primary_hover': '#4F46E5',
        'secondary': '#9CA3AF',
        'success': '#34D399',
        'danger': '#F87171',
        'danger_hover': '#EF4444',
        'background': '#111827',
        'surface': '#1F2937',
        'input_bg': '#374151',
        'input_border': '#4B5563',
        'input_focus': '#6366F1',
        'border': '#374151',
        'text_primary': '#F9FAFB',
        'text_secondary': '#D1D5DB',
        'shadow': 'rgba(0, 0, 0, 0.3)'
    },

    # لوحة برتقالية دافئة
    'modern_orange': {
        'primary': '#F97316',
        'primary_hover': '#EA580C',
        'secondary': '#6B7280',
        'success': '#22C55E',
        'danger': '#EF4444',
        'danger_hover': '#DC2626',
        'background': '#FFFBEB',
        'surface': '#FFFFFF',
        'input_bg': '#FEF3C7',
        'input_border': '#FDE68A',
        'input_focus': '#F97316',
        'border': '#FCD34D',
        'text_primary': '#1F2937',
        'text_secondary': '#6B7280',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة أرجوانية أنيقة
    'modern_indigo': {
        'primary': '#7C3AED',
        'primary_hover': '#6D28D9',
        'secondary': '#6B7280',
        'success': '#10B981',
        'danger': '#F43F5E',
        'danger_hover': '#E11D48',
        'background': '#FAF5FF',
        'surface': '#FFFFFF',
        'input_bg': '#F3E8FF',
        'input_border': '#DDD6FE',
        'input_focus': '#7C3AED',
        'border': '#C4B5FD',
        'text_primary': '#1F2937',
        'text_secondary': '#6B7280',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    },

    # لوحة كلاسيكية زرقاء
    'classic_blue': {
        'primary': '#2563EB',
        'primary_hover': '#1D4ED8',
        'secondary': '#64748B',
        'success': '#16A34A',
        'danger': '#DC2626',
        'danger_hover': '#B91C1C',
        'background': '#F0F9FF',
        'surface': '#FFFFFF',
        'input_bg': '#E0F2FE',
        'input_border': '#BAE6FD',
        'input_focus': '#2563EB',
        'border': '#93C5FD',
        'text_primary': '#1E293B',
        'text_secondary': '#64748B',
        'shadow': 'rgba(0, 0, 0, 0.05)'
    }
}

# دالة للحصول على لوحة ألوان
def get_color_palette(palette_name='modern_purple'):
    """
    الحصول على لوحة ألوان محددة

    Args:
        palette_name: اسم اللوحة المطلوبة

    Returns:
        dict: لوحة الألوان المطلوبة
    """
    return MODERN_PALETTES.get(palette_name, MODERN_PALETTES['modern_purple'])

# دالة لعرض جميع اللوحات المتاحة
def get_available_palettes():
    """الحصول على قائمة بأسماء جميع اللوحات المتاحة"""
    return list(MODERN_PALETTES.keys())

# دالة لمعاينة لوحة ألوان
def preview_palette(palette_name):
    """طباعة معاينة للوحة ألوان"""
    palette = get_color_palette(palette_name)
    print(f"\n=== {palette_name.upper()} PALETTE ===")
    for key, value in palette.items():
        print(f"{key}: {value}")
    print("=" * 30)

# مثال لكيفية استخدام لوحة ألوان مختلفة في login_window.py:
"""
# في بداية ملف login_window.py
from config.modern_color_palettes import get_color_palette

# اختيار لوحة الألوان المطلوبة
PROFESSIONAL_COLORS = get_color_palette('modern_blue')  # أو أي لوحة أخرى

# أو يمكن جعلها قابلة للتخصيص من خلال الإعدادات
theme_palette = config_manager.get('color_palette', 'modern_purple')
PROFESSIONAL_COLORS = get_color_palette(theme_palette)
"""

============================================================
FILE: config\settings.yaml
SIZE: 1027 characters
============================================================

language: en
appearance_mode: light
color_theme: blue
view_name: Sales App
window_size:
  width: 1024
  height: 768
views_settings:
  allow_view_switching: true
  show_current_view_in_status: true
  default_views:
    admin: All Records
    manager: Manager View
    editor: Team View
    viewer: My Bookings
  role_views:
    admin:
    - All Records
    - Today's Bookings
    - This Week
    - This Month
    manager:
    - Manager View
    - Team View
    - Today's Bookings
    - This Week
    editor:
    - Team View
    - My Bookings
    - Today's Bookings
    viewer:
    - My Bookings
cache_settings:
  enable_cache: true
  default_cache_duration: 15
  view_cache_duration:
    All Records: 30
    Today's Bookings: 5
    This Week: 15
    This Month: 60
performance_settings:
  records_per_page: 100
  enable_lazy_loading: true
  show_loading_indicator: true
  background_loading: true
airtable_users_table: users
airtable_booking_table: List V2
main_window_state:
  fullscreen: true
  geometry: null
  state: zoomed


============================================================
FILE: controllers\app_controller.py
SIZE: 38637 characters
============================================================

# -*- coding: utf-8 -*-
"""
controllers/app_controller.py - نسخة محسنة ومبسطة

وحدة التحكم المحسّنة مع:
- كود مبسط ومنظم
- دعم اختياري لربط القوائم المنسدلة بـ Airtable
- إدارة الصلاحيات والمستخدمين
- عمليات CRUD محسنة
- نظام ثيمات موحد
- دعم توليد رقم الحجز التلقائي
- حل مشكلة double JSON encoding في حقل Assigned To
"""

from typing import Any, Dict, List, Optional, Tuple
from datetime import datetime
from tkinter import messagebox
import threading
import json
import time
import tkinter as tk
import customtkinter as ctk

from core.config_manager import ConfigManager
from core.db_manager import DatabaseManager
from core.language_manager import LanguageManager
from core.theme_manager import ThemeManager
from core.user_manager import UserManager
from core.airtable_manager import AirtableModel
from core.logger import logger
from utils.threading_utils import initialize_threading, shutdown_threading
from views.login_window import LoginWindow
from views.main_window import MainWindow

# إخفاء نافذة tk الافتراضية
if tk._default_root:
    tk._default_root.withdraw()

# استيراد مكونات القوائم المنسدلة
try:
    from core.airtable_dropdown_manager import AirtableDropdownManager
    from views.add_edit_window import AddEditWindow
    HAS_AIRTABLE_DROPDOWNS = True
    logger.info("تم تحميل مكونات القوائم المنسدلة")
except ImportError as e:
    logger.warning(f"مكونات القوائم المنسدلة غير متوفرة: {e}")
    HAS_AIRTABLE_DROPDOWNS = False
    AirtableDropdownManager = None
    AddEditWindow = None


class AppController:
    """وحدة التحكم المحسنة والمبسطة"""

    def __init__(self, config_mgr: ConfigManager, db_mgr: DatabaseManager,
                 airtable_users: AirtableModel, airtable_booking: AirtableModel,
                 user_mgr: UserManager) -> None:

        # إخفاء نوافذ tk إضافية
        self._hide_default_tk_windows()

        # المتغيرات الأساسية
        self.config_mgr = config_mgr
        self.db_mgr = db_mgr
        self.airtable_users = airtable_users
        self.airtable_booking = airtable_booking
        self.user_mgr = user_mgr

        # إدارة اللغة والثيم
        self.lang_manager = LanguageManager(self.config_mgr)
        self.theme_manager = ThemeManager(self.config_mgr)

        # نوافذ التطبيق
        self.login_window = None
        self.main_window = None
        self.open_edit_windows = []

        # معلومات المستخدم الحالي
        self.current_username: Optional[str] = None
        self.current_user_info: Optional[Dict[str, Any]] = None
        self.current_user_collaborator: Optional[Any] = None
        self.selected_record: Optional[Dict[str, Any]] = None

        # حالة التطبيق
        self.is_loading = False
        self.loading_operations = set()

        # كاش أرقام الحجز المستخدمة (للتحقق من عدم التكرار)
        self.used_booking_numbers = set()

        # تهيئة مدير القوائم المنسدلة
        self.dropdown_manager = self._initialize_dropdown_manager()

    def _hide_default_tk_windows(self):
        """إخفاء نوافذ tk الافتراضية"""
        try:
            if tk._default_root:
                tk._default_root.withdraw()
            for widget in tk._default_root.winfo_children() if tk._default_root else []:
                if widget.winfo_class() == 'Tk':
                    widget.withdraw()
        except:
            pass

    def _initialize_dropdown_manager(self):
        """تهيئة مدير القوائم المنسدلة"""
        if not HAS_AIRTABLE_DROPDOWNS:
            return None

        try:
            dropdown_manager = AirtableDropdownManager(
                config_manager=self.config_mgr,
                db_manager=self.db_mgr
            )

            if dropdown_manager.has_errors():
                self._handle_dropdown_errors(dropdown_manager.get_all_errors())

            logger.info("تم تهيئة مدير القوائم المنسدلة بنجاح")
            return dropdown_manager

        except Exception as e:
            logger.error(f"خطأ في تهيئة مدير القوائم المنسدلة: {e}")
            return None

    def _handle_dropdown_errors(self, errors):
        """معالجة أخطاء القوائم المنسدلة"""
        error_msg = "تعذر تحميل بعض القوائم المنسدلة:\n\n"
        for key, msg in errors.items():
            error_msg += f"• {msg}\n"

        if hasattr(self, 'main_window') and self.main_window:
            self.main_window.after(1000, lambda: messagebox.showerror(
                "خطأ في القوائم المنسدلة",
                error_msg + "\n\nلن تتمكن من إضافة أو تعديل السجلات."
            ))

    def run(self) -> None:
        """تشغيل التطبيق"""
        logger.info("بدء تشغيل التطبيق")

        self.login_window = LoginWindow(
            controller=self,
            lang_manager=self.lang_manager,
            theme_manager=self.theme_manager,
            airtable_model=self.airtable_users,
            user_mgr=self.user_mgr,
            enable_encryption=True,
            enable_rate_limiting=True,
            enable_2fa=False,
            parent_window=self
        )

        initialize_threading(self.login_window)
        self.login_window.mainloop()

    def on_login_success(self, user_info: Dict[str, str]) -> None:
        """معالج نجاح تسجيل الدخول مع معالجة مبسطة"""
        self.current_username = user_info.get('username', 'Unknown')
        self.current_user_info = user_info

        # معالجة مبسطة لـ Airtable Collaborator - بدون تنظيف معقد
        collaborator_raw = user_info.get('airtable_collaborator')
        if collaborator_raw:
            self.current_user_collaborator = collaborator_raw  # ← استخدام القيمة كما هي
            logger.info(f"تسجيل دخول ناجح: {self.current_username}")
            logger.debug(f"Collaborator: {type(self.current_user_collaborator)} = {self.current_user_collaborator}")
        else:
            logger.warning(f"لا يوجد Airtable Collaborator للمستخدم: {self.current_username}")
            self.current_user_collaborator = None

        # تعيين View للمستخدم
        user_view = user_info.get('view')
        if user_view:
            self.airtable_booking.set_view(user_view)
            logger.info(f"تم تعيين View: {user_view}")

        # إغلاق نافذة تسجيل الدخول
        try:
            if self.login_window:
                self.login_window.destroy()
        except Exception as e:
            logger.warning(f"فشل في إغلاق نافذة تسجيل الدخول: {e}")

        # فتح النافذة الرئيسية
        self._open_main_window(user_info)

    def _open_main_window(self, user_info: Dict[str, str]) -> None:
        """فتح النافذة الرئيسية"""
        try:
            user_record = {
                'id': user_info.get('record_id', ''),
                'fields': {
                    'Username': user_info.get('username', ''),
                    'Airtable View': user_info.get('view'),
                    'Role': user_info.get('role', 'viewer'),
                    'Airtable Collaborator': user_info.get('airtable_collaborator')
                }
            }

            self.main_window = MainWindow(
                lang_manager=self.lang_manager,
                theme_manager=self.theme_manager,
                airtable_model=self.airtable_booking,
                controller=self,
                user_record=user_record
            )

            # تحديث GUI updater
            from utils.threading_utils import get_gui_updater
            get_gui_updater().set_root_widget(self.main_window)

            # تحميل أرقام الحجز المستخدمة للتحقق من عدم التكرار
            self._load_existing_booking_numbers()

            # فحص القوائم المنسدلة بعد الفتح
            if not self.dropdown_manager:
                self.main_window.after(2000, self._show_dropdown_unavailable_message)

            self.main_window.mainloop()

        except Exception as e:
            logger.error(f"خطأ في إنشاء النافذة الرئيسية: {e}")

    def _load_existing_booking_numbers(self):
        """تحميل أرقام الحجز الموجودة للتحقق من عدم التكرار"""
        try:
            records = self.airtable_booking.fetch_records(use_cache=True)
            for record in records:
                booking_nr = record.get('fields', {}).get('Booking Nr.')
                if booking_nr:
                    self.used_booking_numbers.add(booking_nr)

            logger.info(f"تم تحميل {len(self.used_booking_numbers)} رقم حجز موجود")
        except Exception as e:
            logger.warning(f"فشل في تحميل أرقام الحجز: {e}")

    def _show_dropdown_unavailable_message(self):
        """عرض رسالة عدم توفر القوائم المنسدلة"""
        messagebox.showerror(
            "خطأ حرج",
            "لا يمكن تحميل القوائم المنسدلة من Airtable.\n"
            "لن تتمكن من إضافة أو تعديل السجلات.\n\n"
            "تأكد من:\n"
            "- وجود الجداول المطلوبة في Airtable\n"
            "- صحة إعدادات الاتصال في ملف .env"
        )

    # =============== إدارة البيانات ===============

    def fetch_all_records(self, force_refresh: bool = False) -> List[Dict[str, Any]]:
        """جلب جميع السجلات من Airtable"""
        try:
            records = self.airtable_booking.fetch_records(use_cache=False)
            logger.info(f"تم جلب {len(records)} سجل")

            # تحديث كاش أرقام الحجز
            self.used_booking_numbers.clear()
            for record in records:
                booking_nr = record.get('fields', {}).get('Booking Nr.')
                if booking_nr:
                    self.used_booking_numbers.add(booking_nr)

            # طباعة أسماء الحقول (للتطوير)
            if records:
                field_names = list(records[0].get('fields', {}).keys())
                logger.debug(f"الحقول المتاحة: {len(field_names)} حقل")

            return records
        except Exception as e:
            logger.error(f"خطأ في جلب السجلات: {e}")
            return []

    def refresh_data(self) -> List[Dict[str, Any]]:
        """تحديث البيانات"""
        logger.info("تحديث البيانات من Airtable")
        return self.fetch_all_records()

    def set_selected_record(self, record: Dict[str, Any]) -> None:
        """تعيين السجل المحدد"""
        self.selected_record = record
        logger.debug(f"تم تحديد السجل: {record.get('id')}")

    # =============== إدارة الصلاحيات ===============

    def _check_record_permission(self, record: Dict[str, Any], action: str = "تعديل") -> bool:
        """التحقق من صلاحية العمل على السجل"""
        if not record:
            return False

        # الحصول على معلومات السجل والمستخدم
        record_fields = record.get("fields", {})
        record_assigned_to = record_fields.get("Assigned To")
        current_user_id = self._get_current_user_id()
        is_admin = self.current_user_info.get('role', '').lower() == 'admin'

        # السماح للمشرفين
        if is_admin:
            return True

        # منع العمل على السجلات القديمة
        if not record_assigned_to:
            logger.warning(f"السجل قديم (بدون Assigned To) - منع {action}")
            return False

        # التحقق من تطابق المستخدم
        if current_user_id:
            assigned_to_id = record_assigned_to.get('id') if isinstance(record_assigned_to, dict) else record_assigned_to
            return assigned_to_id == current_user_id

        return False

    def _get_current_user_id(self):
        """الحصول على معرف المستخدم الحالي بتنظيف أساسي فقط"""
        if self.current_user_collaborator:
            if isinstance(self.current_user_collaborator, dict):
                user_id = self.current_user_collaborator.get('id')
            else:
                user_id = self.current_user_collaborator

            # تنظيف أساسي فقط - إزالة مسافات زائدة
            if user_id:
                cleaned_id = str(user_id).strip()
                logger.debug(f"معرف المستخدم: {cleaned_id}")
                return cleaned_id

        return None

    def _get_permission_error_message(self, record: Dict[str, Any], action: str) -> Tuple[str, str]:
        """الحصول على رسالة الخطأ المناسبة"""
        record_assigned_to = record.get("fields", {}).get("Assigned To")

        if not record_assigned_to:
            return ("سجل قديم", f"عذراً، لا يمكن {action} هذا السجل.\n\nهذا السجل قديم وغير مرتبط بأي مستخدم.")
        else:
            return ("عدم وجود صلاحية", f"عذراً، لا يمكنك {action} هذا السجل.\n\nيمكنك فقط {action} السجلات التي قمت بإنشائها.")

    # =============== إدارة النماذج ===============

    def open_add_form(self):
        """فتح نافذة إضافة حجز جديد"""
        if not self._can_open_form():
            return

        self._open_form_with_checks("add")

    def open_edit_form(self) -> None:
        """فتح نافذة تعديل السجل المحدد"""
        if not self.selected_record:
            messagebox.showwarning("تنبيه", "يرجى تحديد سجل للتعديل")
            return

        if not self._can_open_form():
            return

        # التحقق من الصلاحية
        if not self._check_record_permission(self.selected_record, "تعديل"):
            title, message = self._get_permission_error_message(self.selected_record, "تعديل")
            messagebox.showerror(title, message)
            return

        self._open_form_with_checks("edit")

    def _can_open_form(self) -> bool:
        """التحقق من إمكانية فتح النموذج"""
        if self.is_loading:
            messagebox.showinfo(
                "جاري التحميل",
                "يرجى انتظار انتهاء تحميل البيانات قبل فتح النموذج."
            )
            return False

        if not HAS_AIRTABLE_DROPDOWNS or not self.dropdown_manager:
            messagebox.showerror(
                "خطأ",
                "لا يمكن فتح النموذج.\nالقوائم المنسدلة من Airtable غير متوفرة."
            )
            return False

        return True

    def _open_form_with_checks(self, mode: str):
        """فتح النموذج مع التحقق من القوائم المنسدلة"""
        operation_id = f"open_form_{mode}_{datetime.now().timestamp()}"
        self.loading_operations.add(operation_id)

        loading_dialog = self._create_loading_dialog("جاري التحقق من البيانات...")

        def check_and_open():
            try:
                # التحقق من حالة القوائم المنسدلة
                status = self.dropdown_manager.get_status() if self.dropdown_manager else {'errors': {'general': 'غير متاح'}}

                # إغلاق مؤشر التحميل
                self.main_window.after(0, lambda: loading_dialog.destroy())
                self.loading_operations.discard(operation_id)

                if status.get('errors'):
                    self.main_window.after(100, lambda: self._show_dropdown_errors(status['errors']))
                    return

                # فتح النموذج
                self.main_window.after(100, lambda: self._create_form(mode))

            except Exception as e:
                self.main_window.after(0, lambda: loading_dialog.destroy())
                self.loading_operations.discard(operation_id)
                self.main_window.after(100, lambda: messagebox.showerror("خطأ", f"فشل التحقق: {str(e)}"))

        threading.Thread(target=check_and_open, daemon=True).start()

    def _create_form(self, mode: str):
        """إنشاء نموذج إضافة أو تعديل - دالة موحدة"""
        try:
            # التحقق من وجود نافذة مفتوحة لنفس السجل (في وضع التعديل)
            if mode == "edit":
                record_id = self.selected_record.get("id")
                for window in self.open_edit_windows:
                    if (window.winfo_exists() and hasattr(window, 'record_id') and
                        window.record_id == record_id):
                        window.focus_force()
                        return

            # مجموعات وأنواع الحقول
            field_groups, field_type_map = self._get_form_configuration()

            # إعداد المعاملات
            form_params = {
                "parent": self.main_window,
                "config_mgr": self.config_mgr,
                "db_mgr": self.db_mgr,
                "airtable_model": self.airtable_booking,
                "controller": self,
                "dropdown_manager": self.dropdown_manager,
                "lang_manager": self.lang_manager,
                "field_groups": field_groups,
                "field_type_map": field_type_map,
                "mode": mode
            }

            # إضافة معاملات التعديل
            if mode == "edit":
                form_params.update({
                    "record_id": self.selected_record.get("id"),
                    "initial_fields": self.selected_record.get("fields", {})
                })

            # إنشاء النافذة
            form_window = AddEditWindow(**form_params)

            logger.info(f"تم فتح نافذة {mode} بنجاح")
            self.open_edit_windows.append(form_window)

            # إزالة النافذة عند الإغلاق
            def on_close():
                if form_window in self.open_edit_windows:
                    self.open_edit_windows.remove(form_window)

            form_window.protocol("WM_DELETE_WINDOW", lambda: [on_close(), form_window.destroy()])

        except Exception as e:
            logger.error(f"خطأ في إنشاء نموذج {mode}: {e}")
            messagebox.showerror("خطأ", f"فشل إنشاء النافذة: {str(e)}")

    def _get_form_configuration(self) -> Tuple[Dict, Dict]:
        """الحصول على تكوين مجموعات وأنواع الحقول"""
        field_groups = {
            "معلومات أساسية": [
                "Customer Name", "Hotel Name", "Agency", "Booking Nr."
            ],
            "تفاصيل الرحلة": [
                "trip Name", "Date Trip", "Option", "des", "Guide", "Product ID"
            ],
            "معلومات الركاب": [
                "ADT", "CHD", "STD", "Youth", "CHD Age"
            ],
            "معلومات الاتصال": [
                "Customer Phone", "Customer Email"
            ],
            "معلومات الأسعار": [
                "Total price USD", "Collecting on date Trip"
            ]
        }

        field_type_map = {
            "Customer Name": "text", "Hotel Name": "text", "Agency": "dropdown",
            "Booking Nr.": "readonly", "trip Name": "dropdown", "Date Trip": "date",
            "Option": "dropdown", "des": "dropdown", "Guide": "dropdown",
            "Product ID": "text", "ADT": "number", "CHD": "number", "STD": "number",
            "Youth": "number", "CHD Age": "text", "Customer Phone": "phone",
            "Customer Email": "email", "Total price USD": "currency",
            "Collecting on date Trip": "text"
        }

        return field_groups, field_type_map

    def _show_dropdown_errors(self, errors):
        """عرض أخطاء القوائم المنسدلة"""
        error_msg = "تعذر جلب البيانات من Airtable:\n\n"
        for table, error in errors.items():
            error_msg += f"• {error}\n"
        error_msg += "\n⛔ لن تتمكن من إضافة أو تعديل السجلات."

        messagebox.showerror("خطأ في القوائم المنسدلة", error_msg)

    # =============== عمليات CRUD ===============

    def create_record(self, fields: Dict[str, Any]) -> Dict[str, Any]:
        """إنشاء سجل جديد مع إضافة Assigned To تلقائياً والتحقق من رقم الحجز"""
        try:
            logger.info("جاري إنشاء سجل جديد...")

            # إضافة Assigned To تلقائياً مع التنسيق الصحيح للـ User field
            collaborator_id = self._get_current_user_id()
            if collaborator_id:
                # إرسال القيمة مباشرة بدون معالجة إضافية
                fields['Assigned To'] = {"id": collaborator_id}  # object
                logger.info(f"تم إضافة Assigned To: {collaborator_id}")

            # التحقق من رقم الحجز وضمان عدم التكرار
            booking_nr = fields.get('Booking Nr.')
            if booking_nr:
                # التحقق من عدم وجود رقم الحجز مسبقاً
                if booking_nr in self.used_booking_numbers:
                    logger.warning(f"رقم الحجز {booking_nr} موجود مسبقاً، سيتم إنشاء رقم جديد")
                    # يمكن إضافة منطق لتوليد رقم جديد هنا إذا لزم الأمر
                else:
                    # إضافة رقم الحجز إلى الكاش
                    self.used_booking_numbers.add(booking_nr)
                    logger.info(f"تم إضافة رقم الحجز الجديد: {booking_nr}")

            # تنظيف الحقول - بدون معالجة خاصة لـ Assigned To
            cleaned_fields = self._clean_fields_for_save_simple(fields)

            if not cleaned_fields:
                raise ValueError("لا توجد بيانات لحفظها")

            # إنشاء السجل
            result = self.airtable_booking.create_record(cleaned_fields)

            if result:
                logger.info(f"تم إنشاء السجل بنجاح: {result.get('id')}")
                self._refresh_main_window()
                return result
            else:
                logger.error("فشل إنشاء السجل")
                return None

        except Exception as e:
            logger.error(f"خطأ في إنشاء السجل: {e}")
            raise

    def update_record(self, record_id: str, fields: Dict[str, Any]) -> Dict[str, Any]:
        """تحديث سجل موجود مع ضمان عدم تعديل رقم الحجز"""
        try:
            logger.info(f"جاري تحديث السجل: {record_id}")

            # تنظيف الحقول (مع منع تعديل Assigned To و Booking Nr.)
            cleaned_fields = self._clean_fields_for_save(fields, exclude_assigned_to=True, exclude_booking_nr=True)

            if not cleaned_fields:
                logger.warning("لا توجد حقول للتحديث")
                return None

            # تحديث السجل
            result = self.airtable_booking.update_record(record_id, cleaned_fields)

            if result:
                logger.info(f"تم تحديث السجل بنجاح: {record_id}")
                self._refresh_main_window()
                return result
            else:
                logger.error(f"فشل تحديث السجل: {record_id}")
                return None

        except Exception as e:
            logger.error(f"خطأ في تحديث السجل: {e}")
            raise

    def delete_record(self) -> bool:
        """حذف السجل المحدد"""
        if not self.selected_record:
            return False

        record_id = self.selected_record.get("id")

        try:
            # التحقق من الصلاحية
            if not self._check_record_permission(self.selected_record, "حذف"):
                title, message = self._get_permission_error_message(self.selected_record, "حذف")
                messagebox.showerror(title, message)
                return False

            # إزالة رقم الحجز من الكاش قبل الحذف
            booking_nr = self.selected_record.get('fields', {}).get('Booking Nr.')
            if booking_nr and booking_nr in self.used_booking_numbers:
                self.used_booking_numbers.remove(booking_nr)
                logger.info(f"تم إزالة رقم الحجز {booking_nr} من الكاش")

            # حذف السجل
            success = self.airtable_booking.delete_record(record_id)

            if success:
                logger.info(f"تم حذف السجل: {record_id}")
                self.selected_record = None
                self._refresh_main_window()

            return success

        except Exception as e:
            logger.error(f"خطأ في حذف السجل: {e}")
            return False

    def batch_delete_records(self, record_ids: List[str]) -> Tuple[int, int]:
        """حذف عدة سجلات"""
        success_count = 0
        unauthorized_count = 0
        old_records_count = 0

        # جلب السجلات للتحقق من الصلاحيات
        all_records = self.fetch_all_records()
        records_dict = {record['id']: record for record in all_records}

        for record_id in record_ids:
            try:
                record = records_dict.get(record_id)
                if not record:
                    continue

                # التحقق من الصلاحية
                if not self._check_record_permission(record, "حذف"):
                    if not record.get("fields", {}).get("Assigned To"):
                        old_records_count += 1
                    else:
                        unauthorized_count += 1
                    continue

                # إزالة رقم الحجز من الكاش
                booking_nr = record.get('fields', {}).get('Booking Nr.')
                if booking_nr and booking_nr in self.used_booking_numbers:
                    self.used_booking_numbers.remove(booking_nr)

                # حذف السجل
                if self.airtable_booking.delete_record(record_id):
                    success_count += 1

            except Exception as e:
                logger.error(f"خطأ في حذف السجل {record_id}: {e}")

        # عرض النتيجة
        self._show_batch_delete_result(success_count, len(record_ids), unauthorized_count, old_records_count)

        if success_count > 0:
            self._refresh_main_window()

        return success_count, len(record_ids)

    def _clean_fields_for_save_simple(self, fields: Dict[str, Any]) -> Dict[str, Any]:
        """تنظيف بسيط للحقول بدون معالجة معقدة لحقل Assigned To"""
        # الحقول المحسوبة والمحظورة
        computed_fields = [
            'Created By', 'Last Modified By', 'Created Date', 'Last Modified',
            'Modified By', 'Modified Date'
        ]

        cleaned = {}
        for key, value in fields.items():
            if key in computed_fields:
                continue

            # تنظيف بسيط للقيم النصية العادية
            if value is not None and value != "":
                if isinstance(value, str):
                    cleaned_value = value.strip()
                    if cleaned_value:
                        cleaned[key] = cleaned_value
                else:
                    cleaned[key] = value

        logger.debug(f"تنظيف بسيط: {len(fields)} → {len(cleaned)} حقل")
        return cleaned

    def _clean_fields_for_save(self, fields: Dict[str, Any], exclude_assigned_to: bool = False, exclude_booking_nr: bool = False) -> Dict[str, Any]:
        """تنظيف الحقول قبل الحفظ مع خيارات إضافية ومعالجة خاصة لحقول User"""
        # الحقول المحسوبة والمحظورة
        computed_fields = [
            'Created By', 'Last Modified By', 'Created Date', 'Last Modified',
            'Modified By', 'Modified Date'
        ]

        if exclude_assigned_to:
            computed_fields.append('Assigned To')

        # ← إضافة خيار منع تعديل رقم الحجز في وضع التعديل
        if exclude_booking_nr:
            computed_fields.append('Booking Nr.')
            logger.info("تم استبعاد رقم الحجز من التحديث (محمي من التعديل)")

        # إزالة الحقول المحسوبة والفارغة مع معالجة خاصة لحقول User
        cleaned = {}
        for key, value in fields.items():
            if key in computed_fields:
                continue

            # معالجة خاصة لحقل Assigned To (User field)
            if key == 'Assigned To' and not exclude_assigned_to:
                cleaned_value = self._clean_user_field_value(value)
                if cleaned_value:
                    cleaned[key] = cleaned_value
                    logger.debug(f"تنظيف حقل المستخدم '{key}': {value} → {cleaned_value}")

            # معالجة الحقول العادية
            elif value is not None and value != "":
                # تنظيف القيم النصية من escape characters إضافية
                if isinstance(value, str):
                    cleaned_value = value.strip()
                    if cleaned_value:
                        cleaned[key] = cleaned_value
                else:
                    cleaned[key] = value

        # تسجيل المعلومات للتشخيص
        excluded_count = len(fields) - len(cleaned)
        if excluded_count > 0:
            logger.debug(f"تم استبعاد {excluded_count} حقل من الحفظ")

        return cleaned

    def _clean_user_field_value(self, value) -> Optional[str]:
        """دالة مبسطة لتنظيف حقل المستخدم"""
        if not value:
            return None

        # تنظيف بسيط
        if isinstance(value, dict):
            user_id = value.get('id')
            if user_id:
                return str(user_id).strip()
        elif isinstance(value, str):
            return value.strip()

        return None

    def _show_batch_delete_result(self, success: int, total: int, unauthorized: int, old: int):
        """عرض نتيجة الحذف الدفعي"""
        message = f"تم حذف {success} سجل من أصل {total}\n\n"

        if unauthorized > 0:
            message += f"• {unauthorized} سجل لم يتم حذفه (مملوك لمستخدمين آخرين)\n"

        if old > 0:
            message += f"• {old} سجل قديم (يرجى الاتصال بالدعم الفني)\n"

        if unauthorized > 0:
            message += "\nيمكنك فقط حذف السجلات التي قمت بإنشائها"

        messagebox.showinfo("نتيجة الحذف", message)

    def _refresh_main_window(self):
        """تحديث النافذة الرئيسية"""
        if self.main_window and hasattr(self.main_window, '_refresh_data'):
            self.main_window.after(100, self.main_window._refresh_data)

    # =============== إدارة المستخدمين والجلسة ===============

    def get_current_user_collaborator(self):
        """الحصول على Airtable Collaborator للمستخدم الحالي مع تشخيص محسن"""
        if self.current_user_collaborator:
            logger.debug(f"المستخدم الحالي موجود: {type(self.current_user_collaborator)} = {self.current_user_collaborator}")
            return self.current_user_collaborator

        # محاولة جلبها من قاعدة البيانات
        if self.current_username and self.airtable_users:
            try:
                logger.info(f"محاولة جلب معلومات المستخدم: {self.current_username}")
                users = self.airtable_users.fetch_records()
                for user in users:
                    username = user.get('fields', {}).get('Username', '')
                    if username.lower() == self.current_username.lower():
                        collaborator = user.get('fields', {}).get('Airtable Collaborator')
                        if collaborator:
                            self.current_user_collaborator = collaborator
                            logger.info(f"تم العثور على Collaborator: {type(collaborator)} = {collaborator}")
                            return collaborator
                        else:
                            logger.warning(f"لم يتم العثور على Airtable Collaborator للمستخدم: {username}")

                logger.warning(f"لم يتم العثور على المستخدم: {self.current_username}")
            except Exception as e:
                logger.error(f"خطأ في جلب معلومات المستخدم: {e}")

        return None

    def on_logout(self) -> None:
        """معالج تسجيل الخروج"""
        logger.info("بدء عملية تسجيل الخروج...")

        # إغلاق النوافذ المفتوحة
        for window in self.open_edit_windows:
            try:
                if window.winfo_exists():
                    window.destroy()
            except:
                pass

        self.open_edit_windows.clear()

        # إعادة تعيين المتغيرات
        self.current_username = None
        self.current_user_info = None
        self.current_user_collaborator = None
        self.selected_record = None
        self.is_loading = False
        self.loading_operations.clear()

        # مسح كاش أرقام الحجز
        self.used_booking_numbers.clear()

        # إعادة تعيين الـ View
        self.airtable_booking.set_view(None)

        logger.info("تم تسجيل الخروج بنجاح")

    # =============== الأدوات المساعدة ===============

    def _create_loading_dialog(self, message: str = "جاري التحميل...") -> ctk.CTkToplevel:
        """إنشاء نافذة حوار التحميل"""
        dialog = ctk.CTkToplevel()
        dialog.title("جاري التحميل...")
        dialog.geometry("350x150")

        # توسيط النافذة
        dialog.update_idletasks()
        x = (dialog.winfo_screenwidth() // 2) - 175
        y = (dialog.winfo_screenheight() // 2) - 75
        dialog.geometry(f"350x150+{x}+{y}")

        dialog.grab_set()
        dialog.transient(self.main_window if self.main_window else None)

        # المحتوى
        frame = ctk.CTkFrame(dialog)
        frame.pack(fill="both", expand=True, padx=20, pady=20)

        ctk.CTkLabel(frame, text=f"⏳ {message}", font=ctk.CTkFont(size=16)).pack(pady=10)

        progress = ctk.CTkProgressBar(frame)
        progress.pack(fill="x", pady=10)
        progress.configure(mode="indeterminate")
        progress.start()

        ctk.CTkLabel(frame, text="يرجى الانتظار", font=ctk.CTkFont(size=12), text_color="gray").pack()

        return dialog

    def update_all_windows_language(self):
        """تحديث لغة جميع النوافذ المفتوحة"""
        logger.info("تحديث لغة جميع النوافذ...")

        for window in self.open_edit_windows:
            try:
                if window.winfo_exists() and hasattr(window, 'update_language'):
                    window.update_language(self.lang_manager)
            except Exception as e:
                logger.error(f"خطأ في تحديث لغة النافذة: {e}")

    def update_all_windows_theme(self):
        """تحديث الثيم في جميع النوافذ المفتوحة"""
        logger.info("تحديث الثيم في جميع النوافذ...")

        # تحديث النافذة الرئيسية
        if self.main_window and hasattr(self.main_window, 'refresh_theme'):
            try:
                self.main_window.refresh_theme()
            except Exception as e:
                logger.error(f"خطأ في تحديث ثيم النافذة الرئيسية: {e}")

        # تحديث نوافذ التعديل/الإضافة
        for window in self.open_edit_windows:
            try:
                if window.winfo_exists() and hasattr(window, 'refresh_theme'):
                    window.refresh_theme()
            except Exception as e:
                logger.error(f"خطأ في تحديث ثيم النافذة: {e}")

    def cleanup(self):
        """تنظيف الموارد عند إغلاق التطبيق"""
        logger.info("بدء تنظيف موارد التطبيق...")

        # إغلاق النوافذ المفتوحة
        for window in self.open_edit_windows:
            try:
                if window.winfo_exists():
                    window.destroy()
            except:
                pass

        # إيقاف العمليات
        self.is_loading = False
        self.loading_operations.clear()

        # مسح الكاش
        self.used_booking_numbers.clear()

        # إيقاف الخيوط
        shutdown_threading()

        logger.info("تم تنظيف موارد التطبيق")

    # =============== إدارة القوائم المنسدلة ===============

    def refresh_dropdown_manager(self):
        """إعادة تهيئة مدير القوائم المنسدلة"""
        if HAS_AIRTABLE_DROPDOWNS:
            try:
                self.dropdown_manager = AirtableDropdownManager(
                    config_manager=self.config_mgr,
                    db_manager=self.db_mgr
                )
                logger.info("تم إعادة تهيئة مدير القوائم المنسدلة")
                return True
            except Exception as e:
                logger.error(f"فشل في إعادة تهيئة مدير القوائم المنسدلة: {e}")
                self.dropdown_manager = None
                return False
        return False

    def get_dropdown_status(self) -> Dict[str, Any]:
        """الحصول على حالة مدير القوائم المنسدلة"""
        if self.dropdown_manager:
            return self.dropdown_manager.get_status()
        return {
            "available": HAS_AIRTABLE_DROPDOWNS,
            "initialized": False,
            "errors": {"general": "مدير القوائم المنسدلة غير مهيأ"}
        }

    # =============== دوال مساعدة إضافية لأرقام الحجز ===============

    def is_booking_number_unique(self, booking_number: str) -> bool:
        """التحقق من عدم تكرار رقم الحجز"""
        return booking_number not in self.used_booking_numbers

    def add_booking_number_to_cache(self, booking_number: str):
        """إضافة رقم حجز إلى الكاش"""
        if booking_number:
            self.used_booking_numbers.add(booking_number)
            logger.debug(f"تم إضافة رقم الحجز {booking_number} إلى الكاش")

    def remove_booking_number_from_cache(self, booking_number: str):
        """إزالة رقم حجز من الكاش"""
        if booking_number and booking_number in self.used_booking_numbers:
            self.used_booking_numbers.remove(booking_number)
            logger.debug(f"تم إزالة رقم الحجز {booking_number} من الكاش")

    def get_booking_numbers_count(self) -> int:
        """الحصول على عدد أرقام الحجز المحفوظة"""
        return len(self.used_booking_numbers)

    # =============== دوال التشخيص والمساعدة ===============

    def debug_user_info(self):
        """دالة تشخيص مبسطة لفحص معلومات المستخدم الحالي"""
        logger.info("=" * 50)
        logger.info("تشخيص معلومات المستخدم")
        logger.info("=" * 50)

        logger.info(f"اسم المستخدم: {self.current_username}")
        logger.info(f"معلومات المستخدم: {self.current_user_info}")
        logger.info(f"Collaborator (نوع): {type(self.current_user_collaborator)}")
        logger.info(f"Collaborator (قيمة): {self.current_user_collaborator}")
        logger.info(f"Collaborator (repr): {repr(self.current_user_collaborator)}")

        # اختبار الحصول على معرف المستخدم
        user_id = self._get_current_user_id()
        logger.info(f"معرف المستخدم النهائي: '{user_id}'")
        logger.info(f"معرف المستخدم (repr): {repr(user_id)}")

        logger.info("=" * 50)

    def test_user_field_creation(self) -> bool:
        """اختبار مبسط لحقل Assigned To"""
        try:
            user_id = self._get_current_user_id()
            if not user_id:
                logger.error("❌ لا يوجد معرف مستخدم")
                return False

            logger.info(f"✅ اختبار ناجح - معرف المستخدم: '{user_id}'")
            logger.info(f"طول المعرف: {len(user_id)}")
            logger.info(f"يبدأ بـ usr: {user_id.startswith('usr')}")
            return True

        except Exception as e:
            logger.error(f"❌ خطأ في اختبار معرف المستخدم: {e}")
            return False
            # -*- coding: utf-8 -*-


============================================================
FILE: core\airtable_dropdown_manager.py
SIZE: 24117 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/airtable_dropdown_manager.py - نسخة محسنة للأداء ومنع التجمد

مدير القوائم المنسدلة المحسن مع:
- تحميل متوازي للقوائم
- تخزين مؤقت ذكي
- معالجة أفضل للأخطاء
- منع التجمد أثناء التحميل
"""

import os
import logging
import threading
import time
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError
from typing import Dict, List, Optional, Tuple
from datetime import datetime, timedelta
import json

from core.airtable_manager import AirtableModel

logger = logging.getLogger(__name__)


class AirtableDropdownManager:
    """مدير القوائم المنسدلة المحسن للأداء ومنع التجمد"""

    # ملف التخزين المؤقت
    CACHE_FILE = "cache/dropdown_cache.json"
    CACHE_DURATION = timedelta(hours=1)  # مدة الكاش ساعة واحدة
    LOADING_TIMEOUT = 30  # مهلة زمنية للتحميل (30 ثانية)
    MAX_WORKERS = 3  # عدد الخيوط المتوازية

    def __init__(self, config_manager, db_manager):
        self.config_mgr = config_manager
        self.db_mgr = db_manager
        self.tables = {}
        self.field_names = {}
        self.errors = {}
        self._cache = {}
        self._cache_timestamps = {}
        self._loading = False
        self._load_lock = threading.RLock()
        self._loading_start_time = None
        self._active_futures = set()

        # إنشاء مجلد الكاش
        os.makedirs("cache", exist_ok=True)

        # تحميل الكاش من الملف
        self._load_cache_from_file()

        # تهيئة الجداول
        self._setup_tables()

        # تحميل القوائم في الخلفية
        self._start_background_loading()

    def _load_cache_from_file(self):
        """تحميل الكاش من الملف"""
        try:
            if os.path.exists(self.CACHE_FILE):
                with open(self.CACHE_FILE, 'r', encoding='utf-8') as f:
                    cache_data = json.load(f)

                # التحقق من صلاحية الكاش
                for key, data in cache_data.items():
                    try:
                        timestamp = datetime.fromisoformat(data.get('timestamp', ''))
                        if datetime.now() - timestamp < self.CACHE_DURATION:
                            self._cache[key] = data.get('values', [])
                            self._cache_timestamps[key] = timestamp
                    except (ValueError, TypeError) as e:
                        logger.warning(f"تعذر تحليل timestamp للمفتاح {key}: {e}")
                        continue

                if self._cache:
                    logger.info(f"تم تحميل {len(self._cache)} قائمة من الكاش")

        except Exception as e:
            logger.warning(f"فشل تحميل الكاش: {e}")

    def _save_cache_to_file(self):
        """حفظ الكاش إلى الملف بطريقة آمنة"""
        try:
            cache_data = {}
            with self._load_lock:
                for key in self._cache:
                    if key in self._cache_timestamps:
                        cache_data[key] = {
                            'values': self._cache[key],
                            'timestamp': self._cache_timestamps[key].isoformat()
                        }

            # كتابة مؤقتة ثم نقل
            temp_file = self.CACHE_FILE + '.tmp'
            with open(temp_file, 'w', encoding='utf-8') as f:
                json.dump(cache_data, f, ensure_ascii=False, indent=2)

            # نقل الملف المؤقت فوق الأصلي
            if os.path.exists(self.CACHE_FILE):
                os.remove(self.CACHE_FILE)
            os.rename(temp_file, self.CACHE_FILE)

        except Exception as e:
            logger.warning(f"فشل حفظ الكاش: {e}")
            # تنظيف الملف المؤقت
            temp_file = self.CACHE_FILE + '.tmp'
            if os.path.exists(temp_file):
                try:
                    os.remove(temp_file)
                except:
                    pass

    def _setup_tables(self):
        """تهيئة جداول القوائم المنسدلة"""
        dropdown_config = {
            'guides': os.getenv('AIRTABLE_GUIDES_TABLE', 'Guides'),
            'agencies': (os.getenv('AIRTABLE_AGENCIES_TABLE', 'Agencies'), 'Agency Name'),
            'options': (os.getenv('AIRTABLE_OPTIONS_TABLE', 'Trip Options'), 'Option Name'),
            'destinations': (os.getenv('AIRTABLE_DESTINATIONS_TABLE', 'Destinations'), 'Destination'),
            'tripnames': (os.getenv('AIRTABLE_TRIPNAMES_TABLE', 'Trip Names'), 'Trip Name'),
            'management_options': (os.getenv('AIRTABLE_MANAGEMENT_OPTIONS_TABLE', 'Management Option'), 'Option Name'),
            'addons': os.getenv('AIRTABLE_ADDONS_TABLE', 'Add-on'),
        }

        logger.info(f"[Dropdown Manager] تهيئة {len(dropdown_config)} جدول")

        # التحقق من API
        api_key = os.getenv('AIRTABLE_API_KEY')
        base_id = os.getenv('AIRTABLE_BASE_ID')

        if not api_key or not base_id:
            error_msg = "API Key أو Base ID مفقود"
            logger.error(f"[Dropdown Manager] {error_msg}")
            self.errors['config'] = error_msg
            return

        # تهيئة الجداول
        for key, config in dropdown_config.items():
            try:
                if isinstance(config, tuple):
                    table_name, field_name = config
                else:
                    table_name = config
                    field_name = 'Name'

                self.tables[key] = AirtableModel(
                    config_manager=self.config_mgr,
                    db_manager=self.db_mgr,
                    table_name=table_name
                )
                self.field_names[key] = field_name

                logger.debug(f"تم تهيئة جدول {key}: {table_name} (حقل: {field_name})")

            except Exception as e:
                error_msg = f"فشل تهيئة جدول '{key}': {str(e)}"
                logger.error(f"[Dropdown Manager] {error_msg}")
                self.errors[key] = error_msg

    def _start_background_loading(self):
        """بدء تحميل القوائم في الخلفية"""
        def load_all():
            try:
                self._load_all_dropdowns_parallel()
            except Exception as e:
                logger.error(f"خطأ في التحميل الخلفي: {e}")

        thread = threading.Thread(target=load_all, daemon=True, name="DropdownLoader")
        thread.start()

    def _load_all_dropdowns_parallel(self):
        """تحميل جميع القوائم بشكل متوازي مع مهلة زمنية"""
        with self._load_lock:
            if self._loading:
                logger.debug("التحميل جاري بالفعل")
                return
            self._loading = True
            self._loading_start_time = datetime.now()

        start_time = time.time()
        logger.info("[Dropdown Manager] بدء التحميل المتوازي للقوائم")

        # التحقق من وجود جداول للتحميل
        if not self.tables:
            logger.warning("لا توجد جداول للتحميل")
            with self._load_lock:
                self._loading = False
                self._loading_start_time = None
            return

        # تهيئة المتغيرات قبل try block
        completed = 0
        failed = 0
        timeout_count = 0

        try:
            # استخدام ThreadPoolExecutor للتحميل المتوازي
            with ThreadPoolExecutor(max_workers=self.MAX_WORKERS) as executor:
                futures = {}

                # إطلاق مهام التحميل للجداول التي تحتاج تحديث
                for key in self.tables:
                    if self._is_cache_valid(key):
                        logger.debug(f"تخطي {key} - الكاش صالح")
                        continue

                    future = executor.submit(self._load_single_dropdown_with_timeout, key)
                    futures[future] = key
                    self._active_futures.add(future)

                if not futures:
                    logger.info("جميع القوائم محدثة في الكاش")
                    return

                # انتظار اكتمال المهام مع مهلة زمنية

                try:
                    for future in as_completed(futures, timeout=self.LOADING_TIMEOUT):
                        key = futures[future]
                        self._active_futures.discard(future)

                        try:
                            values = future.result(timeout=5)  # مهلة إضافية للحصول على النتيجة
                            if values is not None:
                                with self._load_lock:
                                    self._cache[key] = values
                                    self._cache_timestamps[key] = datetime.now()
                                completed += 1
                                logger.debug(f"✓ تم تحميل {key}: {len(values)} قيمة")

                                # إزالة الخطأ إذا نجح التحميل
                                self.errors.pop(key, None)
                            else:
                                failed += 1
                                logger.warning(f"✗ فشل تحميل {key}: لم يتم إرجاع بيانات")
                        except TimeoutError:
                            timeout_count += 1
                            logger.error(f"✗ انتهت مهلة تحميل {key}")
                            self.errors[key] = "انتهت المهلة الزمنية للتحميل"
                        except Exception as e:
                            failed += 1
                            logger.error(f"✗ فشل تحميل {key}: {e}")
                            self.errors[key] = str(e)

                except TimeoutError:
                    logger.error("انتهت المهلة الزمنية العامة للتحميل")
                    # إلغاء المهام المتبقية
                    for future in futures:
                        if not future.done():
                            future.cancel()
                            key = futures[future]
                            self.errors[key] = "تم إلغاء التحميل بسبب انتهاء المهلة"

                # تنظيف المهام المكتملة
                self._active_futures.clear()

        except Exception as e:
            logger.error(f"خطأ عام في التحميل المتوازي: {e}")
            # تأكد من تهيئة المتغيرات في حالة الخطأ
            if 'completed' not in locals():
                completed = 0
            if 'failed' not in locals():
                failed = len(self.tables)
            if 'timeout_count' not in locals():
                timeout_count = 0

        finally:
            # حفظ الكاش
            if completed > 0:
                self._save_cache_to_file()

            elapsed = time.time() - start_time
            logger.info(f"[Dropdown Manager] اكتمل التحميل في {elapsed:.2f}ث - "
                       f"نجح: {completed}, فشل: {failed}, انتهت مهلة: {timeout_count}")

            with self._load_lock:
                self._loading = False
                self._loading_start_time = None

    def _load_single_dropdown_with_timeout(self, key: str) -> Optional[List[str]]:
        """تحميل قائمة منسدلة واحدة مع مهلة زمنية"""
        start_time = time.time()

        try:
            if key not in self.tables:
                logger.warning(f"الجدول {key} غير موجود")
                return None

            field_name = self.field_names.get(key, 'Name')
            logger.debug(f"بدء تحميل {key} من الحقل {field_name}")

            # تحميل البيانات مع مهلة زمنية
            values = self.tables[key].get_all_values(field_name=field_name, force_refresh=True)

            elapsed = time.time() - start_time

            if not values:
                logger.warning(f"لم يتم العثور على بيانات في {key} (استغرق {elapsed:.2f}ث)")
                self.errors[key] = f"لم يتم العثور على بيانات في الجدول"
                return []

            logger.debug(f"تم تحميل {key} بنجاح: {len(values)} قيمة (استغرق {elapsed:.2f}ث)")
            return values

        except Exception as e:
            elapsed = time.time() - start_time
            logger.error(f"خطأ في تحميل {key} (استغرق {elapsed:.2f}ث): {e}")
            self.errors[key] = str(e)
            raise

    def _is_cache_valid(self, key: str) -> bool:
        """التحقق من صلاحية الكاش"""
        if key not in self._cache or key not in self._cache_timestamps:
            return False

        age = datetime.now() - self._cache_timestamps[key]
        return age < self.CACHE_DURATION

    def _cancel_loading_operations(self):
        """إلغاء جميع عمليات التحميل الجارية"""
        logger.info("إلغاء عمليات التحميل الجارية...")

        # إلغاء المهام النشطة
        for future in list(self._active_futures):
            if not future.done():
                future.cancel()
                logger.debug(f"تم إلغاء مهمة تحميل")

        self._active_futures.clear()

        with self._load_lock:
            self._loading = False
            self._loading_start_time = None

    def get_dropdown_values(self, key: str, force_refresh: bool = False, timeout: float = 20.0) -> List[str]:
        """الحصول على قيم القائمة المنسدلة مع مهلة زمنية"""
        try:
            # التحقق من وجود الجدول
            if key not in self.tables:
                logger.warning(f"الجدول {key} غير موجود في القوائم المنسدلة")
                return []

            # التحقق من الكاش أولاً
            if not force_refresh and self._is_cache_valid(key):
                logger.debug(f"إرجاع قيم {key} من الكاش")
                return self._cache.get(key, [])

            # إذا كان التحميل جارياً، انتظر قليلاً أو أرجع الكاش القديم
            if self._loading:
                logger.debug(f"التحميل جاري - محاولة انتظار {key}")

                # انتظار مع مهلة زمنية
                start_wait = time.time()
                while self._loading and (time.time() - start_wait) < timeout:
                    time.sleep(0.1)

                    # إذا أصبحت القيمة متاحة في الكاش أثناء الانتظار
                    if self._is_cache_valid(key):
                        logger.debug(f"تم الحصول على {key} من الكاش أثناء الانتظار")
                        return self._cache.get(key, [])

                # إذا انتهت المهلة وما زال التحميل جارياً
                if self._loading:
                    logger.warning(f"انتهت مهلة انتظار {key} - إرجاع كاش قديم أو فارغ")
                    return self._cache.get(key, [])

            # تحميل القائمة في خيط منفصل مع مهلة زمنية
            try:
                logger.debug(f"تحميل {key} مباشرة مع مهلة زمنية")

                # استخدام ThreadPoolExecutor لتحميل واحد
                with ThreadPoolExecutor(max_workers=1) as executor:
                    future = executor.submit(self._load_single_dropdown_with_timeout, key)

                    try:
                        values = future.result(timeout=timeout)
                        if values is not None:
                            with self._load_lock:
                                self._cache[key] = values
                                self._cache_timestamps[key] = datetime.now()
                            self._save_cache_to_file()
                            return values
                        return []

                    except TimeoutError:
                        logger.warning(f"انتهت مهلة تحميل {key}")
                        future.cancel()
                        self.errors[key] = "انتهت المهلة الزمنية"
                        # إرجاع الكاش القديم إن وجد
                        return self._cache.get(key, [])

            except Exception as e:
                logger.error(f"خطأ في جلب {key}: {e}")
                self.errors[key] = str(e)
                # إرجاع الكاش القديم إن وجد
                return self._cache.get(key, [])

        except Exception as e:
            logger.error(f"خطأ عام في get_dropdown_values لـ {key}: {e}")
            self.errors[key] = f"خطأ عام: {str(e)}"
            return []

    def add_value_to_dropdown(self, key: str, value: str) -> bool:
        """إضافة قيمة جديدة إلى القائمة المنسدلة"""
        if key not in self.tables:
            logger.warning(f"[Dropdown] جدول غير موجود: {key}")
            return False

        if not value or not value.strip():
            logger.warning(f"[Dropdown] قيمة فارغة لـ {key}")
            return False

        try:
            field_name = self.field_names.get(key, 'Name')
            success = self.tables[key].insert_if_not_exists(value.strip(), field_name=field_name)

            if success:
                # تحديث الكاش
                with self._load_lock:
                    if key in self._cache:
                        if value.strip() not in self._cache[key]:
                            self._cache[key].append(value.strip())
                            self._cache[key].sort()
                            self._save_cache_to_file()

                logger.info(f"[Dropdown] تمت إضافة '{value}' إلى '{key}'")

            return success

        except Exception as e:
            logger.error(f"[Dropdown] فشل إضافة '{value}' إلى '{key}': {e}")
            return False

    def refresh_all(self, force: bool = True):
        """تحديث جميع القوائم المنسدلة"""
        logger.info("[Dropdown] بدء تحديث جميع القوائم")

        # إيقاف أي تحميل جاري
        if self._loading:
            logger.info("إيقاف التحميل الجاري قبل التحديث")
            self._cancel_loading_operations()

            # انتظار قصير للتأكد من الإيقاف
            time.sleep(0.5)

        if force:
            # مسح الكاش
            with self._load_lock:
                self._cache.clear()
                self._cache_timestamps.clear()
                self.errors.clear()

        # إعادة التحميل
        self._start_background_loading()

    def get_all_dropdowns(self, timeout: float = 15.0) -> Dict[str, List[str]]:
        """الحصول على جميع القوائم المنسدلة مع مهلة زمنية"""
        # انتظار اكتمال التحميل إذا كان جارياً
        start_wait = time.time()

        while self._loading and (time.time() - start_wait) < timeout:
            time.sleep(0.2)

        if self._loading:
            logger.warning(f"انتهت مهلة انتظار تحميل جميع القوائم ({timeout}s)")

        result = {}
        for key in self.tables:
            # محاولة الحصول على القيم مع مهلة زمنية قصيرة
            try:
                result[key] = self.get_dropdown_values(key, timeout=3.0)
            except Exception as e:
                logger.error(f"خطأ في جلب {key}: {e}")
                result[key] = []

        return result

    def get_field_mapping(self) -> Dict[str, str]:
        """الحصول على خريطة الحقول"""
        return {
            "Agency": "agencies",
            "Guide": "guides",
            "Option": "options",
            "des": "destinations",
            "trip Name": "tripnames",
            "Management Option": "management_options",
            "Add-on": "addons"
        }

    def get_dropdown_by_field_name(self, field_name: str, timeout: float = 5.0) -> List[str]:
        """الحصول على قيم القائمة المنسدلة بناءً على اسم الحقل"""
        field_mapping = self.get_field_mapping()
        key = field_mapping.get(field_name)

        if key:
            return self.get_dropdown_values(key, timeout=timeout)

        logger.warning(f"[Dropdown] لا يوجد ربط للحقل: {field_name}")
        return []

    def is_connected(self) -> bool:
        """التحقق من الاتصال"""
        return len(self.tables) > 0 and not self.errors.get('config')

    def get_status(self) -> Dict[str, any]:
        """الحصول على حالة المدير بشكل آمن"""
        try:
            with self._load_lock:
                # حساب عدد القوائم المحملة بنجاح
                successful_loads = 0
                if hasattr(self, '_cache') and self._cache:
                    successful_loads = len([k for k in self._cache if k not in self.errors])

                # تقدير وقت التحميل المتبقي
                estimated_time_remaining = None
                if self._loading and self._loading_start_time:
                    elapsed = (datetime.now() - self._loading_start_time).total_seconds()
                    if elapsed < self.LOADING_TIMEOUT:
                        estimated_time_remaining = max(0, self.LOADING_TIMEOUT - elapsed)

                return {
                    'connected': self.is_connected(),
                    'loading': getattr(self, '_loading', False),
                    'tables_count': len(getattr(self, 'tables', {})),
                    'cached_count': len(getattr(self, '_cache', {})),
                    'successful_loads': successful_loads,
                    'tables': list(getattr(self, 'tables', {}).keys()),
                    'cached_tables': list(getattr(self, '_cache', {}).keys()),
                    'api_configured': bool(os.getenv('AIRTABLE_API_KEY') and os.getenv('AIRTABLE_BASE_ID')),
                    'errors': getattr(self, 'errors', {}).copy(),
                    'loading_start_time': self._loading_start_time.isoformat() if getattr(self, '_loading_start_time', None) else None,
                    'estimated_time_remaining': estimated_time_remaining,
                    'active_futures_count': len(getattr(self, '_active_futures', set()))
                }
        except Exception as e:
            logger.error(f"خطأ في الحصول على حالة مدير القوائم المنسدلة: {e}")
            return {
                'connected': False,
                'loading': False,
                'tables_count': 0,
                'cached_count': 0,
                'successful_loads': 0,
                'tables': [],
                'cached_tables': [],
                'api_configured': False,
                'errors': {'status_error': str(e)},
                'loading_start_time': None,
                'estimated_time_remaining': None,
                'active_futures_count': 0
            }

    def get_error_for_key(self, key: str) -> str:
        """الحصول على رسالة الخطأ"""
        return self.errors.get(key, "")

    def has_errors(self) -> bool:
        """التحقق من وجود أخطاء"""
        return len(self.errors) > 0

    def get_all_errors(self) -> Dict[str, str]:
        """الحصول على جميع الأخطاء"""
        return self.errors.copy()

    def clear_errors(self):
        """مسح جميع الأخطاء"""
        with self._load_lock:
            self.errors.clear()

    def get_cache_info(self) -> Dict[str, any]:
        """الحصول على معلومات الكاش"""
        with self._load_lock:
            cache_info = {}
            for key in self._cache:
                timestamp = self._cache_timestamps.get(key)
                cache_info[key] = {
                    'count': len(self._cache[key]),
                    'timestamp': timestamp.isoformat() if timestamp else None,
                    'age_seconds': (datetime.now() - timestamp).total_seconds() if timestamp else None,
                    'is_valid': self._is_cache_valid(key)
                }
            return cache_info

    def force_stop_loading(self):
        """إيقاف التحميل بالقوة"""
        logger.warning("إيقاف تحميل القوائم المنسدلة بالقوة")
        self._cancel_loading_operations()

        # إضافة رسالة خطأ للجداول التي لم يتم تحميلها
        for key in self.tables:
            if key not in self._cache:
                self.errors[key] = "تم إيقاف التحميل بالقوة"

    def __del__(self):
        """تنظيف الموارد عند التدمير"""
        try:
            if hasattr(self, '_loading') and self._loading:
                self._cancel_loading_operations()
        except:
            pass

============================================================
FILE: core\airtable_manager.py
SIZE: 36988 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/airtable_manager.py - الملف الموحد لإدارة Airtable

يجمع وظائف:
- airtable_manager.py (العمليات الأساسية والمتقدمة)
- airtable_model.py (النموذج البسيط والكاش)
- airtable_integration_helper.py (الجداول المرتبطة)

مع إزالة التكرار وتحسين الأداء وإصلاح مشكلة حقل Assigned To
"""

import os
import json
import time
import logging
import threading
from concurrent.futures import ThreadPoolExecutor, as_completed, TimeoutError
from typing import Dict, List, Any, Optional, Tuple, Callable, Union
from datetime import datetime, timedelta
import requests
import re

logger = logging.getLogger(__name__)


class AirtableManager:
    """
    مدير موحد لجميع عمليات Airtable
    يجمع العمليات الأساسية والمتقدمة والجداول المرتبطة
    مع إصلاح مشكلة حقل Assigned To
    """

    # إعدادات الكاش والأداء
    CACHE_DURATION = timedelta(minutes=30)
    REQUEST_TIMEOUT = 30
    MAX_RETRIES = 3
    RETRY_DELAY = 1.5
    MAX_WORKERS = 3

    def __init__(self,
                 config_manager=None,
                 db_manager=None,
                 table_name: str = "",
                 view_name: str = None):
        """
        تهيئة مدير Airtable الموحد

        :param config_manager: مدير الإعدادات
        :param db_manager: مدير قاعدة البيانات
        :param table_name: اسم الجدول
        :param view_name: اسم العرض (اختياري)
        """
        self.config = config_manager
        self.db = db_manager
        self.table_name = table_name
        self.view_name = view_name

        # إعدادات API
        self._setup_api_config()

        # إعدادات الكاش
        self.last_fetch = None
        self.cached_data = []
        self.cache_timestamps = {}
        self._cache_lock = threading.RLock()

        # إعدادات الأخطاء
        self.errors = {}
        self._loading = False

        # البيانات المخزنة للجداول المرتبطة
        self.cached_related_data = {
            'add_on_prices': [],
            'management_options': [],
            'trip_names': [],
            'users': []
        }

        logger.info(f"تم تهيئة AirtableManager للجدول: {table_name}")

    def _setup_api_config(self):
        """إعداد معلومات API"""
        if self.config:
            self.api_key = self.config.get("airtable_api_key", "")
            self.base_id = self.config.get("airtable_base_id", "")
        else:
            self.api_key = os.getenv('AIRTABLE_API_KEY', "")
            self.base_id = os.getenv('AIRTABLE_BASE_ID', "")

        if not all([self.api_key, self.base_id]):
            logger.error("إعدادات Airtable غير مكتملة (API Key أو Base ID)")
            return

        # بناء URL والـ headers
        if self.table_name:
            self.endpoint = f"https://api.airtable.com/v0/{self.base_id}/{self.table_name}"

        self.headers = {
            "Authorization": f"Bearer {self.api_key}",
            "Content-Type": "application/json; charset=utf-8"
        }

    def set_table(self, table_name: str, view_name: str = None):
        """تغيير الجدول والعرض"""
        self.table_name = table_name
        self.view_name = view_name
        if self.base_id:
            self.endpoint = f"https://api.airtable.com/v0/{self.base_id}/{table_name}"
        logger.info(f"تم تغيير الجدول إلى: {table_name} (العرض: {view_name or 'الكل'})")

    def set_view(self, view_name: str):
        """تغيير العرض المستخدم"""
        self.view_name = view_name
        logger.info(f"تم تغيير العرض إلى: {view_name}")

    # ========================================
    # 🔧 العمليات الأساسية (CRUD)
    # ========================================

    def fetch_records(self,
                     use_cache: bool = True,
                     force_refresh: bool = False,
                     filter_formula: str = None,
                     view: str = None) -> List[Dict[str, Any]]:
        """
        جلب السجلات مع دعم الكاش والفلترة

        :param use_cache: استخدام الكاش
        :param force_refresh: إجبار التحديث
        :param filter_formula: صيغة الفلتر
        :param view: العرض المطلوب
        :return: قائمة السجلات
        """
        # التحقق من الكاش
        if use_cache and not force_refresh and self._is_cache_valid():
            logger.debug(f"استخدام الكاش للجدول: {self.table_name}")
            return self.cached_data

        logger.info(f"جلب السجلات من Airtable للجدول: {self.table_name}")

        all_records = []
        url = self.endpoint
        params = {"pageSize": 100}

        # إضافة المعاملات
        if view or self.view_name:
            params["view"] = view or self.view_name
        if filter_formula:
            params["filterByFormula"] = filter_formula

        while True:
            try:
                response = requests.get(
                    url,
                    headers=self.headers,
                    params=params,
                    timeout=self.REQUEST_TIMEOUT
                )
                response.raise_for_status()

                payload = response.json()
                records = payload.get("records", [])
                all_records.extend(records)

                logger.debug(f"استلام {len(records)} سجل من {self.table_name}")

                # التحقق من الصفحة التالية
                offset = payload.get("offset")
                if offset:
                    params["offset"] = offset
                    time.sleep(0.2)  # تجنب rate limiting
                else:
                    break

            except requests.RequestException as e:
                logger.error(f"خطأ في جلب السجلات من {self.table_name}: {e}")
                # محاولة إرجاع الكاش القديم
                if self.cached_data:
                    logger.warning("إرجاع الكاش القديم بسبب فشل الطلب")
                    return self.cached_data
                raise

        # تحديث الكاش
        with self._cache_lock:
            self.cached_data = all_records
            self.last_fetch = datetime.now()
            self.cache_timestamps[self.table_name] = datetime.now()

        # حفظ في قاعدة البيانات المحلية
        if self.db:
            self._save_to_local_db(all_records)

        logger.info(f"تم جلب {len(all_records)} سجل من {self.table_name}")
        return all_records

    def fetch_record(self, record_id: str) -> Optional[Dict[str, Any]]:
        """جلب سجل واحد بواسطة ID"""
        url = f"{self.endpoint}/{record_id}"

        for attempt in range(self.MAX_RETRIES):
            try:
                response = requests.get(
                    url,
                    headers=self.headers,
                    timeout=self.REQUEST_TIMEOUT
                )
                response.raise_for_status()

                record = response.json()
                logger.info(f"تم جلب السجل {record_id} من {self.table_name}")
                return record

            except requests.RequestException as e:
                if attempt < self.MAX_RETRIES - 1:
                    logger.warning(f"محاولة {attempt + 1} فشلت لجلب السجل {record_id}: {e}")
                    time.sleep(self.RETRY_DELAY * (attempt + 1))
                else:
                    logger.error(f"فشل جلب السجل {record_id} نهائياً: {e}")
                    return None

    def create_record(self, fields: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """إنشاء سجل جديد مع معالجة صحيحة لحقل Assigned To"""
        # معالجة خاصة للحقول المعقدة
        processed_fields = self._process_fields_for_create(fields)
        payload = {"fields": processed_fields}

        for attempt in range(self.MAX_RETRIES):
            try:
                logger.debug(f"محاولة إنشاء سجل (المحاولة {attempt + 1}): {self.table_name}")
                logger.debug(f"البيانات المرسلة: {json.dumps(payload, indent=2, ensure_ascii=False)}")

                # 🔍 logging خاص لحقل Assigned To
                if 'Assigned To' in processed_fields:
                    assigned_value = processed_fields['Assigned To']
                    logger.info(f"🎯 Assigned To في الـ payload: {type(assigned_value)} = {assigned_value}")

                response = requests.post(
                    self.endpoint,
                    headers=self.headers,
                    json=payload,
                    timeout=self.REQUEST_TIMEOUT
                )

                if response.status_code == 422:
                    logger.error(f"خطأ في بيانات السجل (422): {response.text}")
                    if "Assigned To" in response.text:
                        logger.error("❌ مشكلة في حقل Assigned To")
                        # logging إضافي للتشخيص
                        if 'Assigned To' in processed_fields:
                            assigned_value = processed_fields['Assigned To']
                            logger.error(f"قيمة Assigned To المرسلة: {assigned_value}")
                            logger.error(f"نوع القيمة: {type(assigned_value)}")
                            logger.error(f"محتوى JSON: {json.dumps(assigned_value, ensure_ascii=False)}")
                    return None

                response.raise_for_status()

                # إلغاء الكاش بعد الإنشاء
                self._invalidate_cache()

                created = response.json()
                rec_id = created.get("id")
                logger.info(f"✅ تم إنشاء سجل جديد: {rec_id} في {self.table_name}")
                return created

            except requests.RequestException as e:
                if attempt < self.MAX_RETRIES - 1:
                    logger.warning(f"محاولة إنشاء {attempt + 1} فشلت: {e}")
                    time.sleep(self.RETRY_DELAY * (attempt + 1))
                else:
                    logger.error(f"❌ فشل إنشاء السجل نهائياً: {e}")
                    if hasattr(e, 'response') and e.response:
                        logger.error(f"تفاصيل الخطأ: {e.response.text}")
                    return None

    def update_record(self, record_id: str, fields: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """تحديث سجل موجود"""
        url = f"{self.endpoint}/{record_id}"

        # معالجة الحقول
        processed_fields = self._process_fields_for_update(fields)
        payload = {"fields": processed_fields}

        for attempt in range(self.MAX_RETRIES):
            try:
                logger.debug(f"تحديث السجل {record_id} (المحاولة {attempt + 1})")

                response = requests.patch(
                    url,
                    headers=self.headers,
                    json=payload,
                    timeout=self.REQUEST_TIMEOUT
                )
                response.raise_for_status()

                # إلغاء الكاش
                self._invalidate_cache()

                updated = response.json()
                logger.info(f"تم تحديث السجل {record_id} في {self.table_name}")
                return updated

            except requests.RequestException as e:
                if attempt < self.MAX_RETRIES - 1:
                    logger.warning(f"محاولة تحديث {attempt + 1} فشلت: {e}")
                    time.sleep(self.RETRY_DELAY * (attempt + 1))
                else:
                    logger.error(f"فشل تحديث السجل {record_id}: {e}")
                    return None

    def delete_record(self, record_id: str) -> bool:
        """حذف سجل"""
        url = f"{self.endpoint}/{record_id}"

        for attempt in range(self.MAX_RETRIES):
            try:
                response = requests.delete(
                    url,
                    headers=self.headers,
                    timeout=self.REQUEST_TIMEOUT
                )
                response.raise_for_status()

                # إلغاء الكاش
                self._invalidate_cache()

                logger.info(f"تم حذف السجل {record_id} من {self.table_name}")
                return True

            except requests.RequestException as e:
                if attempt < self.MAX_RETRIES - 1:
                    logger.warning(f"محاولة حذف {attempt + 1} فشلت: {e}")
                    time.sleep(self.RETRY_DELAY * (attempt + 1))
                else:
                    logger.error(f"فشل حذف السجل {record_id}: {e}")
                    return False

    # ========================================
    # 📄 العمليات المتقدمة (Pagination & Search)
    # ========================================

    def get_records_paginated(self, limit=50, offset=None):
        """جلب السجلات مع pagination"""
        url = self.endpoint
        params = {"pageSize": min(limit, 100)}

        if offset:
            params["offset"] = offset
        if self.view_name:
            params["view"] = self.view_name

        try:
            response = requests.get(
                url,
                headers=self.headers,
                params=params,
                timeout=self.REQUEST_TIMEOUT
            )
            response.raise_for_status()

            data = response.json()
            records = data.get("records", [])
            next_offset = data.get("offset", None)

            logger.info(f"جلب {len(records)} سجل في هذه الصفحة من {self.table_name}")
            return records, next_offset

        except requests.RequestException as e:
            logger.error(f"خطأ في جلب الصفحة: {e}")
            return [], None

    def search_records(self, formula: str) -> List[Dict[str, Any]]:
        """البحث باستخدام Airtable formula"""
        try:
            params = {"filterByFormula": formula}
            if self.view_name:
                params["view"] = self.view_name

            response = requests.get(
                self.endpoint,
                headers=self.headers,
                params=params,
                timeout=self.REQUEST_TIMEOUT
            )
            response.raise_for_status()

            records = response.json().get('records', [])
            logger.info(f"وجد {len(records)} سجل مطابق للبحث في {self.table_name}")
            return records

        except requests.RequestException as e:
            logger.error(f"خطأ في البحث: {e}")
            return []

    # ========================================
    # 📋 دوال القوائم المنسدلة
    # ========================================

    def get_all_values(self, field_name: str = "Name", force_refresh: bool = False) -> List[str]:
        """جلب جميع القيم الفريدة من حقل معين"""
        records = self.fetch_records(force_refresh=force_refresh)
        values = []

        for record in records:
            fields = record.get('fields', {})
            value = fields.get(field_name)
            if value and value not in values:
                # تنظيف القيمة
                clean_value = str(value).strip()
                if clean_value and clean_value not in values:
                    values.append(clean_value)

        return sorted(values)

    def insert_if_not_exists(self, value: str, field_name: str = "Name") -> bool:
        """إضافة قيمة جديدة إذا لم تكن موجودة"""
        if not value or not value.strip():
            logger.warning(f"قيمة فارغة للحقل {field_name}")
            return False

        existing_values = self.get_all_values(field_name)
        clean_value = str(value).strip()

        if clean_value not in existing_values:
            result = self.create_record({field_name: clean_value})
            if result:
                logger.info(f"تم إضافة '{clean_value}' إلى {self.table_name}")
                return True
            return False

        logger.debug(f"القيمة '{clean_value}' موجودة بالفعل في {self.table_name}")
        return False

    # دوال متخصصة للجداول المختلفة
    def fetch_agencies(self, field_name: str = "Agency Name") -> List[str]:
        """جلب قائمة الوكالات"""
        return self._fetch_dropdown_values(field_name, ["Agency Name", "Name", "Agency"])

    def fetch_guides(self, field_name: str = "Name") -> List[str]:
        """جلب قائمة المرشدين"""
        return self._fetch_dropdown_values(field_name, ["Guide Name", "Name", "Language"])

    def fetch_destinations(self, field_name: str = "Destination") -> List[str]:
        """جلب قائمة الوجهات"""
        return self._fetch_dropdown_values(field_name, ["Destination", "Name", "City", "Location"])

    def get_dropdown_values(self, field_name: str, default_field: str = "Name") -> List[str]:
        """دالة عامة لجلب قيم أي قائمة منسدلة"""
        return self._fetch_dropdown_values(field_name, [field_name, default_field])

    def _fetch_dropdown_values(self, primary_field: str, fallback_fields: List[str]) -> List[str]:
        """دالة مساعدة لجلب قيم القوائم المنسدلة"""
        try:
            records = self.fetch_records()
            values = []

            for record in records:
                fields = record.get('fields', {})
                value = None

                # البحث في الحقول المحتملة
                for field in fallback_fields:
                    if field in fields and fields[field]:
                        value = fields[field]
                        break

                if value:
                    clean_value = str(value).strip()
                    if clean_value and clean_value not in values:
                        values.append(clean_value)

            values.sort()
            logger.info(f"تم جلب {len(values)} قيمة من {primary_field} في {self.table_name}")
            return values

        except Exception as e:
            logger.error(f"خطأ في جلب قيم {primary_field}: {e}")
            return []

    # ========================================
    # 🔗 الجداول المرتبطة (من integration_helper)
    # ========================================

    def fetch_all_related_data(self, callback=None, error_callback=None):
        """جلب جميع البيانات من الجداول المرتبطة"""
        def fetch_task():
            try:
                # جلب البيانات من كل جدول
                self._fetch_add_on_prices()
                self._fetch_management_options()
                self._fetch_trip_names()
                self._fetch_users()

                logger.info("تم جلب جميع البيانات من الجداول المرتبطة")

                if callback:
                    callback(self.cached_related_data)

                return self.cached_related_data

            except Exception as e:
                logger.error(f"خطأ في جلب البيانات المرتبطة: {e}")
                if error_callback:
                    error_callback(str(e))
                raise

        # تشغيل في خيط منفصل
        threading.Thread(target=fetch_task, daemon=True).start()

    def _fetch_add_on_prices(self):
        """جلب بيانات الإضافات"""
        original_table = self.table_name
        try:
            self.set_table("Add-on prices")
            records = self.fetch_records(use_cache=False)
            add_ons = []

            for record in records:
                fields = record.get('fields', {})
                add_on_name = fields.get('Add-ons', '')
                if add_on_name:
                    add_ons.append(add_on_name)

            self.cached_related_data['add_on_prices'] = sorted(list(set(add_ons)))
            logger.info(f"تم جلب {len(add_ons)} إضافة")

        except Exception as e:
            logger.error(f"خطأ في جلب Add-on prices: {e}")
        finally:
            self.set_table(original_table)

    def _fetch_management_options(self):
        """جلب بيانات خيارات الإدارة"""
        original_table = self.table_name
        try:
            self.set_table("Management Option")
            records = self.fetch_records(use_cache=False)
            options = []

            for record in records:
                fields = record.get('fields', {})
                option_name = fields.get('Main Option', '')
                if option_name:
                    options.append(option_name)

            self.cached_related_data['management_options'] = sorted(list(set(options)))
            logger.info(f"تم جلب {len(options)} خيار إدارة")

        except Exception as e:
            logger.error(f"خطأ في جلب Management Option: {e}")
        finally:
            self.set_table(original_table)

    def _fetch_trip_names(self):
        """جلب أسماء الرحلات"""
        original_table = self.table_name
        try:
            self.set_table("Trip Name Correction")
            records = self.fetch_records(use_cache=False)
            trip_names = []

            for record in records:
                fields = record.get('fields', {})
                old_name = fields.get('Old Name', '')
                new_name = fields.get('New Name', '')

                trip_name = new_name if new_name else old_name
                if trip_name:
                    trip_names.append(trip_name)

            self.cached_related_data['trip_names'] = sorted(list(set(trip_names)))
            logger.info(f"تم جلب {len(trip_names)} اسم رحلة")

        except Exception as e:
            logger.error(f"خطأ في جلب Trip Name Correction: {e}")
        finally:
            self.set_table(original_table)

    def _fetch_users(self):
        """جلب بيانات المستخدمين"""
        original_table = self.table_name
        try:
            self.set_table("Users")
            records = self.fetch_records(use_cache=False)
            users = []

            for record in records:
                fields = record.get('fields', {})
                username = fields.get('Username', '')
                collaborator = fields.get('Airtable Collaborator')

                if username:
                    users.append(username)
                elif collaborator and isinstance(collaborator, dict):
                    user_name = collaborator.get('name', '')
                    if user_name:
                        users.append(user_name)

            self.cached_related_data['users'] = sorted(list(set(users)))
            logger.info(f"تم جلب {len(users)} مستخدم")

        except Exception as e:
            logger.error(f"خطأ في جلب Users: {e}")
        finally:
            self.set_table(original_table)

    def get_cached_related_data(self) -> Dict[str, List[str]]:
        """الحصول على البيانات المرتبطة المخزنة"""
        return self.cached_related_data

    def refresh_related_data(self, table_name: Optional[str] = None):
        """تحديث البيانات المرتبطة"""
        if table_name:
            if table_name == "Add-on prices":
                self._fetch_add_on_prices()
            elif table_name == "Management Option":
                self._fetch_management_options()
            elif table_name == "Trip Name Correction":
                self._fetch_trip_names()
            elif table_name == "Users":
                self._fetch_users()
        else:
            self.fetch_all_related_data()

    # ========================================
    # 🛠️ دوال مساعدة وكاش
    # ========================================

    def _process_fields_for_create(self, fields: Dict[str, Any]) -> Dict[str, Any]:
        """معالجة الحقول قبل الإنشاء - محدثة لحقل Assigned To"""
        processed = {}

        for key, value in fields.items():
            if key == 'Assigned To':
                # معالجة خاصة لحقل Assigned To - إرجاع object
                processed_value = self._process_assigned_to_field(value)
                if processed_value:  # فقط إذا كان هناك قيمة صالحة
                    processed[key] = processed_value
                    logger.debug(f"✅ Assigned To processed: {processed_value}")
            elif value is not None and str(value).strip():
                processed[key] = value

        return processed

    def _process_fields_for_update(self, fields: Dict[str, Any]) -> Dict[str, Any]:
        """معالجة الحقول قبل التحديث - محدثة لحقل Assigned To"""
        processed = {}

        for key, value in fields.items():
            if key == 'Assigned To':
                # معالجة خاصة لحقل Assigned To
                processed_value = self._process_assigned_to_field(value)
                if processed_value:
                    processed[key] = processed_value
            else:
                processed[key] = value

        return processed

    def _process_assigned_to_field(self, value: Any) -> Optional[Dict[str, str]]:
        """معالجة خاصة محسنة لحقل Assigned To - إرجاع object بدلاً من string"""
        if value is None:
            return None

        # إذا كان dict بالفعل، تحقق من وجود id أو email
        if isinstance(value, dict):
            if 'id' in value:
                user_id = str(value['id']).strip()
                logger.debug(f"Dict with id found: {user_id}")
                return {"id": user_id}
            elif 'email' in value:
                email = str(value['email']).strip()
                logger.debug(f"Dict with email found: {email}")
                return {"email": email}
            else:
                # البحث عن أي قيمة مفيدة في الـ dict
                for k, v in value.items():
                    if v and str(v).strip():
                        clean_val = str(v).strip()
                        if '@' in clean_val:
                            return {"email": clean_val}
                        elif clean_val.startswith(('usr', 'rec')) or len(clean_val) > 10:
                            return {"id": clean_val}
                return None

        # تحويل إلى string أولاً
        str_value = str(value)

        # إزالة أي escape characters أو quotes زائدة
        cleaned_value = str_value.strip()

        # إزالة quotes خارجية متعددة إذا وجدت
        while cleaned_value.startswith('"') and cleaned_value.endswith('"'):
            cleaned_value = cleaned_value[1:-1]

        while cleaned_value.startswith("'") and cleaned_value.endswith("'"):
            cleaned_value = cleaned_value[1:-1]

        # إزالة أي backslashes زائدة
        cleaned_value = cleaned_value.replace('\\"', '"').replace("\\'", "'")

        # التأكد من أن القيمة بالتنسيق الصحيح لمعرف Airtable User
        final_value = cleaned_value.strip()

        # logging للتشخيص
        if str_value != final_value:
            logger.debug(f"تنظيف Assigned To: '{str_value}' → '{final_value}'")

        # ✅ إرجاع object بالتنسيق الصحيح لـ Airtable
        if final_value:
            # التحقق من نوع القيمة (ID أم Email)
            if final_value.startswith('usr') or final_value.startswith('rec'):
                # معرف Airtable User/Record
                logger.debug(f"إرجاع User ID: {final_value}")
                return {"id": final_value}
            elif '@' in final_value and '.' in final_value:
                # عنوان بريد إلكتروني
                logger.debug(f"إرجاع Email: {final_value}")
                return {"email": final_value}
            else:
                # افتراض أنه معرف حتى لو لم يبدأ بـ usr
                logger.debug(f"إرجاع ID (افتراضي): {final_value}")
                return {"id": final_value}

        return None

    def _validate_user_field_format(self, value: Any) -> bool:
        """التحقق من صحة تنسيق حقل المستخدم"""
        if not value:
            return False

        if isinstance(value, dict):
            return 'id' in value or 'email' in value

        if isinstance(value, str):
            value = value.strip()
            # التحقق من معرف Airtable أو بريد إلكتروني
            return (value.startswith(('usr', 'rec')) and len(value) >= 10) or ('@' in value and '.' in value)

        return False

    def _is_cache_valid(self) -> bool:
        """التحقق من صلاحية الكاش"""
        if not self.last_fetch or not self.cached_data:
            return False

        age = datetime.now() - self.last_fetch
        return age < self.CACHE_DURATION

    def _invalidate_cache(self):
        """إلغاء الكاش"""
        with self._cache_lock:
            self.last_fetch = None
            self.cached_data = []
            if self.table_name in self.cache_timestamps:
                del self.cache_timestamps[self.table_name]

    def _save_to_local_db(self, records: List[Dict[str, Any]]):
        """حفظ البيانات في قاعدة البيانات المحلية"""
        try:
            if self.db and hasattr(self.db, 'save_records'):
                self.db.save_records(self.table_name, records)
        except Exception as e:
            logger.warning(f"فشل حفظ البيانات محلياً: {e}")

    def get_cache_info(self) -> Dict[str, Any]:
        """معلومات الكاش"""
        with self._cache_lock:
            return {
                'table': self.table_name,
                'cached_records': len(self.cached_data),
                'last_fetch': self.last_fetch.isoformat() if self.last_fetch else None,
                'cache_age_seconds': (datetime.now() - self.last_fetch).total_seconds() if self.last_fetch else None,
                'is_valid': self._is_cache_valid()
            }

    def clear_cache(self):
        """مسح الكاش"""
        self._invalidate_cache()
        logger.info(f"تم مسح كاش {self.table_name}")

    def is_connected(self) -> bool:
        """التحقق من الاتصال"""
        return bool(self.api_key and self.base_id)

    def get_status(self) -> Dict[str, Any]:
        """حالة المدير"""
        return {
            'connected': self.is_connected(),
            'table_name': self.table_name,
            'view_name': self.view_name,
            'loading': self._loading,
            'cached_records': len(self.cached_data),
            'cache_valid': self._is_cache_valid(),
            'errors': self.errors.copy(),
            'related_data_cached': {
                key: len(values) for key, values in self.cached_related_data.items()
            }
        }

    # ========================================
    # 🔧 دوال التشخيص والتصحيح
    # ========================================

    def debug_assigned_to_processing(self, test_values: List[Any]) -> Dict[str, Any]:
        """دالة تشخيص لاختبار معالجة حقل Assigned To"""
        results = {}

        logger.info("🔍 بدء اختبار معالجة حقل Assigned To")
        logger.info("=" * 50)

        for i, test_value in enumerate(test_values):
            try:
                logger.info(f"اختبار {i+1}: {type(test_value)} = {test_value}")

                # معالجة القيمة
                processed = self._process_assigned_to_field(test_value)

                # التحقق من صحة التنسيق
                is_valid = self._validate_user_field_format(processed)

                results[f"test_{i+1}"] = {
                    "input": test_value,
                    "input_type": str(type(test_value)),
                    "processed": processed,
                    "processed_type": str(type(processed)),
                    "is_valid": is_valid,
                    "success": processed is not None
                }

                logger.info(f"✅ النتيجة: {processed} (صحيح: {is_valid})")

            except Exception as e:
                logger.error(f"❌ خطأ في المعالجة: {e}")
                results[f"test_{i+1}"] = {
                    "input": test_value,
                    "error": str(e),
                    "success": False
                }

            logger.info("-" * 30)

        logger.info("=" * 50)
        return results

    def test_user_field_creation(self, user_id: str) -> bool:
        """اختبار إنشاء سجل تجريبي مع حقل Assigned To"""
        try:
            logger.info(f"🧪 اختبار إنشاء سجل مع Assigned To: {user_id}")

            # تجهيز بيانات تجريبية
            test_fields = {
                "Customer Name": f"Test User {datetime.now().strftime('%H%M%S')}",
                "Assigned To": user_id,
                "Agency": "Test Agency"
            }

            # معالجة الحقول
            processed = self._process_fields_for_create(test_fields)

            logger.info(f"الحقول المعالجة: {json.dumps(processed, ensure_ascii=False, indent=2)}")

            # التحقق من تنسيق Assigned To
            if 'Assigned To' in processed:
                assigned_to = processed['Assigned To']
                is_valid = self._validate_user_field_format(assigned_to)
                logger.info(f"تنسيق Assigned To صحيح: {is_valid}")
                return is_valid

            return False

        except Exception as e:
            logger.error(f"❌ خطأ في اختبار المستخدم: {e}")
            return False

    def validate_record_fields(self, fields: Dict[str, Any]) -> Tuple[bool, List[str]]:
        """التحقق من صحة حقول السجل قبل الإرسال"""
        errors = []

        # التحقق من الحقول المطلوبة
        required_fields = ['Customer Name']  # يمكن تخصيصها حسب الجدول

        for field in required_fields:
            if field not in fields or not fields[field]:
                errors.append(f"الحقل المطلوب '{field}' مفقود أو فارغ")

        # التحقق من تنسيق حقل Assigned To
        if 'Assigned To' in fields:
            assigned_to = fields['Assigned To']
            if not self._validate_user_field_format(assigned_to):
                errors.append(f"تنسيق حقل 'Assigned To' غير صحيح: {assigned_to}")

        return len(errors) == 0, errors

    def create_record_with_validation(self, fields: Dict[str, Any]) -> Optional[Dict[str, Any]]:
        """إنشاء سجل مع التحقق المسبق من صحة البيانات"""
        # التحقق من صحة الحقول
        is_valid, errors = self.validate_record_fields(fields)

        if not is_valid:
            logger.error("❌ فشل التحقق من صحة الحقول:")
            for error in errors:
                logger.error(f"  - {error}")
            return None

        # إنشاء السجل إذا كانت البيانات صحيحة
        return self.create_record(fields)


# ========================================
# 🏭 دوال Factory للجداول المختلفة
# ========================================

def create_airtable_manager(config_manager=None, db_manager=None, table_name: str = "") -> AirtableManager:
    """إنشاء مدير Airtable عام"""
    return AirtableManager(config_manager, db_manager, table_name)

def create_bookings_manager(config_manager=None, db_manager=None, view_name: str = None) -> AirtableManager:
    """إنشاء مدير لجدول الحجوزات"""
    return AirtableManager(config_manager, db_manager, "Bookings", view_name)

def create_agencies_manager(config_manager=None, db_manager=None) -> AirtableManager:
    """إنشاء مدير لجدول الوكالات"""
    return AirtableManager(config_manager, db_manager, "Agencies")

def create_guides_manager(config_manager=None, db_manager=None) -> AirtableManager:
    """إنشاء مدير لجدول المرشدين"""
    return AirtableManager(config_manager, db_manager, "Guides")

def create_destinations_manager(config_manager=None, db_manager=None) -> AirtableManager:
    """إنشاء مدير لجدول الوجهات"""
    return AirtableManager(config_manager, db_manager, "Destinations")

def create_users_manager(config_manager=None, db_manager=None) -> AirtableManager:
    """إنشاء مدير لجدول المستخدمين"""
    return AirtableManager(config_manager, db_manager, "Users")


# ========================================
# 🔄 دالة التوافق مع الكود القديم
# ========================================

class AirtableModel(AirtableManager):
    """كلاس للتوافق مع الكود القديم - وراثة من AirtableManager"""

    def __init__(self, config_manager, db_manager, table_name: str, view_name: str = None):
        super().__init__(config_manager, db_manager, table_name, view_name)
        logger.info(f"تم إنشاء AirtableModel (توافق) للجدول: {table_name}")

    # دوال التوافق
    def fetch_all_records(self, view: Optional[str] = None, force_refresh: bool = False) -> List[Dict[str, Any]]:
        """دالة توافق - استخدام fetch_records"""
        return self.fetch_records(force_refresh=force_refresh, view=view)

    def get_record_by_id(self, record_id: str) -> Optional[Dict[str, Any]]:
        """دالة توافق - استخدام fetch_record"""
        return self.fetch_record(record_id)

============================================================
FILE: core\app_state_manager.py
SIZE: 14840 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/app_state_manager.py

مدير حالة التطبيق لمنع التداخل والتجمد
"""

import threading
import time
from datetime import datetime, timedelta
from typing import Dict, Set, Optional, Any
from enum import Enum
from core.logger import logger


class OperationType(Enum):
    """أنواع العمليات في التطبيق"""
    DATA_LOADING = "data_loading"
    DROPDOWN_LOADING = "dropdown_loading"
    RECORD_SAVING = "record_saving"
    RECORD_DELETING = "record_deleting"
    USER_AUTHENTICATION = "user_authentication"
    EXPORT_DATA = "export_data"
    UI_UPDATE = "ui_update"


class OperationState(Enum):
    """حالات العمليات"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    COMPLETED = "completed"
    FAILED = "failed"
    CANCELLED = "cancelled"
    TIMEOUT = "timeout"


class Operation:
    """كلاس لتمثيل عملية واحدة"""

    def __init__(self, operation_id: str, operation_type: OperationType,
                 description: str = "", timeout: float = 30.0):
        self.id = operation_id
        self.type = operation_type
        self.description = description
        self.state = OperationState.PENDING
        self.start_time = None
        self.end_time = None
        self.timeout = timeout
        self.progress = 0.0
        self.error_message = None
        self.result = None
        self.metadata = {}

    def start(self):
        """بدء العملية"""
        self.state = OperationState.IN_PROGRESS
        self.start_time = datetime.now()
        logger.debug(f"بدء العملية: {self.id} ({self.type.value})")

    def complete(self, result: Any = None):
        """إكمال العملية بنجاح"""
        self.state = OperationState.COMPLETED
        self.end_time = datetime.now()
        self.progress = 100.0
        self.result = result
        logger.debug(f"اكتملت العملية: {self.id} ({self.type.value})")

    def fail(self, error_message: str):
        """فشل العملية"""
        self.state = OperationState.FAILED
        self.end_time = datetime.now()
        self.error_message = error_message
        logger.warning(f"فشلت العملية: {self.id} ({self.type.value}) - {error_message}")

    def cancel(self):
        """إلغاء العملية"""
        self.state = OperationState.CANCELLED
        self.end_time = datetime.now()
        logger.info(f"تم إلغاء العملية: {self.id} ({self.type.value})")

    def timeout_operation(self):
        """انتهت مهلة العملية"""
        self.state = OperationState.TIMEOUT
        self.end_time = datetime.now()
        logger.warning(f"انتهت مهلة العملية: {self.id} ({self.type.value})")

    def update_progress(self, progress: float):
        """تحديث تقدم العملية"""
        self.progress = max(0.0, min(100.0, progress))

    def is_active(self) -> bool:
        """التحقق من كون العملية نشطة"""
        return self.state in [OperationState.PENDING, OperationState.IN_PROGRESS]

    def is_completed(self) -> bool:
        """التحقق من اكتمال العملية"""
        return self.state == OperationState.COMPLETED

    def is_timed_out(self) -> bool:
        """التحقق من انتهاء مهلة العملية"""
        if not self.start_time or not self.is_active():
            return False

        elapsed = (datetime.now() - self.start_time).total_seconds()
        return elapsed > self.timeout

    def get_elapsed_time(self) -> float:
        """الحصول على الوقت المنقضي"""
        if not self.start_time:
            return 0.0

        end_time = self.end_time or datetime.now()
        return (end_time - self.start_time).total_seconds()


class AppStateManager:
    """مدير حالة التطبيق"""

    def __init__(self):
        self._operations: Dict[str, Operation] = {}
        self._lock = threading.RLock()
        self._operation_counter = 0
        self._global_state = {
            'is_busy': False,
            'current_user': None,
            'last_activity': datetime.now(),
            'session_start': datetime.now()
        }

        # إعدادات المهلة الزمنية
        self._default_timeouts = {
            OperationType.DATA_LOADING: 45.0,
            OperationType.DROPDOWN_LOADING: 30.0,
            OperationType.RECORD_SAVING: 15.0,
            OperationType.RECORD_DELETING: 10.0,
            OperationType.USER_AUTHENTICATION: 20.0,
            OperationType.EXPORT_DATA: 60.0,
            OperationType.UI_UPDATE: 5.0
        }

        # بدء مراقب المهلة الزمنية
        self._start_timeout_monitor()

    def _generate_operation_id(self, operation_type: OperationType) -> str:
        """توليد معرف فريد للعملية"""
        with self._lock:
            self._operation_counter += 1
            timestamp = int(datetime.now().timestamp() * 1000)
            return f"{operation_type.value}_{timestamp}_{self._operation_counter}"

    def start_operation(self, operation_type: OperationType,
                       description: str = "", timeout: float = None) -> str:
        """بدء عملية جديدة"""
        with self._lock:
            # تحديد المهلة الزمنية
            if timeout is None:
                timeout = self._default_timeouts.get(operation_type, 30.0)

            # إنشاء العملية
            operation_id = self._generate_operation_id(operation_type)
            operation = Operation(operation_id, operation_type, description, timeout)

            # بدء العملية
            operation.start()
            self._operations[operation_id] = operation

            # تحديث الحالة العامة
            self._update_global_state()

            logger.info(f"بدء عملية جديدة: {operation_id} - {description}")
            return operation_id

    def complete_operation(self, operation_id: str, result: Any = None) -> bool:
        """إكمال عملية"""
        with self._lock:
            operation = self._operations.get(operation_id)
            if not operation:
                logger.warning(f"العملية غير موجودة: {operation_id}")
                return False

            if not operation.is_active():
                logger.warning(f"العملية غير نشطة: {operation_id}")
                return False

            operation.complete(result)
            self._update_global_state()

            # تنظيف العمليات القديمة
            self._cleanup_old_operations()

            return True

    def fail_operation(self, operation_id: str, error_message: str) -> bool:
        """فشل عملية"""
        with self._lock:
            operation = self._operations.get(operation_id)
            if not operation:
                logger.warning(f"العملية غير موجودة: {operation_id}")
                return False

            operation.fail(error_message)
            self._update_global_state()

            return True

    def cancel_operation(self, operation_id: str) -> bool:
        """إلغاء عملية"""
        with self._lock:
            operation = self._operations.get(operation_id)
            if not operation:
                logger.warning(f"العملية غير موجودة: {operation_id}")
                return False

            if operation.is_active():
                operation.cancel()
                self._update_global_state()
                return True

            return False

    def update_operation_progress(self, operation_id: str, progress: float) -> bool:
        """تحديث تقدم العملية"""
        with self._lock:
            operation = self._operations.get(operation_id)
            if not operation:
                return False

            operation.update_progress(progress)
            return True

    def get_operation(self, operation_id: str) -> Optional[Operation]:
        """الحصول على عملية"""
        with self._lock:
            return self._operations.get(operation_id)

    def get_active_operations(self, operation_type: OperationType = None) -> List[Operation]:
        """الحصول على العمليات النشطة"""
        with self._lock:
            active_ops = [op for op in self._operations.values() if op.is_active()]

            if operation_type:
                active_ops = [op for op in active_ops if op.type == operation_type]

            return active_ops

    def is_busy(self, operation_types: List[OperationType] = None) -> bool:
        """التحقق من انشغال التطبيق"""
        with self._lock:
            if operation_types:
                # التحقق من أنواع محددة من العمليات
                for op in self._operations.values():
                    if op.is_active() and op.type in operation_types:
                        return True
                return False
            else:
                # التحقق من أي عمليات نشطة
                return any(op.is_active() for op in self._operations.values())

    def can_start_operation(self, operation_type: OperationType) -> tuple[bool, str]:
        """التحقق من إمكانية بدء عملية جديدة"""
        with self._lock:
            # قواعد التداخل
            blocking_combinations = {
                OperationType.DATA_LOADING: [OperationType.DATA_LOADING, OperationType.EXPORT_DATA],
                OperationType.DROPDOWN_LOADING: [OperationType.DROPDOWN_LOADING],
                OperationType.RECORD_SAVING: [OperationType.RECORD_SAVING, OperationType.DATA_LOADING],
                OperationType.RECORD_DELETING: [OperationType.RECORD_DELETING, OperationType.DATA_LOADING],
                OperationType.EXPORT_DATA: [OperationType.EXPORT_DATA, OperationType.DATA_LOADING],
                OperationType.USER_AUTHENTICATION: [OperationType.USER_AUTHENTICATION]
            }

            blocking_types = blocking_combinations.get(operation_type, [])

            for op in self._operations.values():
                if op.is_active() and op.type in blocking_types:
                    return False, f"عملية أخرى من نوع {op.type.value} جارية بالفعل"

            return True, ""

    def cancel_operations_by_type(self, operation_type: OperationType) -> int:
        """إلغاء جميع العمليات من نوع معين"""
        with self._lock:
            cancelled_count = 0

            for operation in self._operations.values():
                if operation.is_active() and operation.type == operation_type:
                    operation.cancel()
                    cancelled_count += 1

            self._update_global_state()
            logger.info(f"تم إلغاء {cancelled_count} عملية من نوع {operation_type.value}")

            return cancelled_count

    def force_cancel_all_operations(self) -> int:
        """إلغاء جميع العمليات بالقوة"""
        with self._lock:
            cancelled_count = 0

            for operation in self._operations.values():
                if operation.is_active():
                    operation.cancel()
                    cancelled_count += 1

            self._update_global_state()
            logger.warning(f"تم إلغاء {cancelled_count} عملية بالقوة")

            return cancelled_count

    def _update_global_state(self):
        """تحديث الحالة العامة للتطبيق"""
        self._global_state['is_busy'] = self.is_busy()
        self._global_state['last_activity'] = datetime.now()

    def _start_timeout_monitor(self):
        """بدء مراقب المهلة الزمنية"""
        def monitor():
            while True:
                try:
                    time.sleep(5)  # فحص كل 5 ثوان
                    self._check_timeouts()
                except Exception as e:
                    logger.error(f"خطأ في مراقب المهلة الزمنية: {e}")

        thread = threading.Thread(target=monitor, daemon=True, name="TimeoutMonitor")
        thread.start()

    def _check_timeouts(self):
        """فحص المهلات الزمنية للعمليات"""
        with self._lock:
            timed_out_operations = []

            for operation in self._operations.values():
                if operation.is_timed_out():
                    operation.timeout_operation()
                    timed_out_operations.append(operation.id)

            if timed_out_operations:
                logger.warning(f"انتهت مهلة {len(timed_out_operations)} عملية")
                self._update_global_state()

    def _cleanup_old_operations(self):
        """تنظيف العمليات القديمة المكتملة"""
        with self._lock:
            # إبقاء العمليات لمدة ساعة بعد اكتمالها
            cutoff_time = datetime.now() - timedelta(hours=1)

            operations_to_remove = []
            for op_id, operation in self._operations.items():
                if (not operation.is_active() and
                    operation.end_time and
                    operation.end_time < cutoff_time):
                    operations_to_remove.append(op_id)

            for op_id in operations_to_remove:
                del self._operations[op_id]

            if operations_to_remove:
                logger.debug(f"تم تنظيف {len(operations_to_remove)} عملية قديمة")

    def get_status_summary(self) -> Dict[str, Any]:
        """الحصول على ملخص حالة التطبيق"""
        with self._lock:
            active_ops = self.get_active_operations()

            # تجميع العمليات حسب النوع
            ops_by_type = {}
            for op in active_ops:
                op_type = op.type.value
                if op_type not in ops_by_type:
                    ops_by_type[op_type] = []
                ops_by_type[op_type].append({
                    'id': op.id,
                    'description': op.description,
                    'progress': op.progress,
                    'elapsed_time': op.get_elapsed_time()
                })

            return {
                'is_busy': self._global_state['is_busy'],
                'total_operations': len(self._operations),
                'active_operations': len(active_ops),
                'operations_by_type': ops_by_type,
                'current_user': self._global_state.get('current_user'),
                'session_duration': (datetime.now() - self._global_state['session_start']).total_seconds(),
                'last_activity': self._global_state['last_activity'].isoformat()
            }

    def set_current_user(self, username: str):
        """تعيين المستخدم الحالي"""
        with self._lock:
            self._global_state['current_user'] = username
            logger.info(f"تم تعيين المستخدم الحالي: {username}")

    def clear_current_user(self):
        """مسح المستخدم الحالي"""
        with self._lock:
            self._global_state['current_user'] = None
            logger.info("تم مسح المستخدم الحالي")


# مثيل عام للاستخدام في التطبيق
app_state_manager = AppStateManager()

============================================================
FILE: core\config_manager.py
SIZE: 18851 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/config_manager.py

تدير هذه الفئة قراءة وكتابة إعدادات التطبيق من/إلى ملف YAML.
تدعم أيضاً قراءة المتغيرات الحساسة من ملف .env
ودعم شامل لإعدادات Views والأداء
"""

import os
import yaml
from dotenv import load_dotenv
from core.logger import logger
from typing import Dict  # إذا لم يكن موجوداً
from typing import Dict, Any, Optional, List

class ConfigManager:
    """
    فئة ConfigManager تتولى:
    - تحميل المتغيرات من ملف .env
    - تحميل الإعدادات من ملف YAML
    - دمج الإعدادات مع إعطاء الأولوية لمتغيرات البيئة
    - حفظ التغييرات (غير الحساسة) في ملف YAML
    - إدارة إعدادات Views والأداء
    """

    def __init__(self, config_path: str = "config/settings.yaml") -> None:
        """
        تهيئة ConfigManager.

        :param config_path: المسار إلى ملف الإعدادات YAML
        """
        self.config_path: str = config_path
        self.config_data: Dict[str, Any] = {}
        self.env_data: Dict[str, str] = {}

        # تحميل متغيرات البيئة أولاً
        self._load_env()

        # ثم تحميل إعدادات YAML
        self._load_config()

        # دمج الإعدادات
        self._merge_settings()

    def _load_env(self) -> None:
        """
        تحميل المتغيرات من ملف .env
        """
        # البحث عن ملف .env في المجلد الحالي أو المجلد الأعلى
        env_paths = ['.env', '../.env', os.path.join(os.path.dirname(__file__), '..', '.env')]

        env_loaded = False
        for env_path in env_paths:
            if os.path.exists(env_path):
                load_dotenv(env_path)
                env_loaded = True
                logger.info(f"ConfigManager: تم تحميل متغيرات البيئة من '{env_path}'")
                break

        if not env_loaded:
            logger.warning("ConfigManager: لم يتم العثور على ملف .env - استخدام القيم الافتراضية")

        # حفظ متغيرات البيئة المهمة
        self.env_data = {
            'airtable_api_key': os.getenv('AIRTABLE_API_KEY', ''),
            'airtable_base_id': os.getenv('AIRTABLE_BASE_ID', ''),
            'airtable_users_table': os.getenv('AIRTABLE_USERS_TABLE', 'Users'),
            'airtable_booking_table': os.getenv('AIRTABLE_BOOKING_TABLE', 'List V2'),
            'default_language': os.getenv('DEFAULT_LANGUAGE', 'ar'),
            'default_theme': os.getenv('DEFAULT_THEME', 'light'),
            'db_path': os.getenv('DB_PATH', 'fts_sales_cache.db'),
        }

        # إضافة جداول القوائم المنسدلة
        self.env_data.update({
            'airtable_guides_table': os.getenv('AIRTABLE_GUIDES_TABLE', 'Guides'),
            'airtable_agencies_table': os.getenv('AIRTABLE_AGENCIES_TABLE', 'Agencies'),
            'airtable_options_table': os.getenv('AIRTABLE_OPTIONS_TABLE', 'Trip Options'),
            'airtable_destinations_table': os.getenv('AIRTABLE_DESTINATIONS_TABLE', 'Destinations'),
                })

        # إضافة جداول القوائم المنسدلة الإضافية
        self.env_data.update({
            'airtable_tripnames_table': os.getenv('AIRTABLE_TRIPNAMES_TABLE', 'Trip Names'),
            'airtable_management_options_table': os.getenv('AIRTABLE_MANAGEMENT_OPTIONS_TABLE', 'Management Options'),
            'airtable_addons_table': os.getenv('AIRTABLE_ADDONS_TABLE', 'Add-ons'),
                })

    def _load_config(self) -> None:
        """
        تحميل الإعدادات من ملف YAML
        """
        if not os.path.exists(self.config_path):
            logger.warning(f"ConfigManager: ملف الإعدادات '{self.config_path}' غير موجود. سيتم إنشاء ملف جديد.")
            parent_dir = os.path.dirname(self.config_path)
            if parent_dir and not os.path.isdir(parent_dir):
                try:
                    os.makedirs(parent_dir, exist_ok=True)
                    logger.info(f"ConfigManager: تم إنشاء المجلد '{parent_dir}'.")
                except Exception as exc:
                    logger.error(f"ConfigManager: فشل إنشاء المجلد '{parent_dir}': {exc}", exc_info=True)

            # إنشاء ملف إعدادات افتراضي
            self._create_default_config()
        else:
            try:
                with open(self.config_path, "r", encoding="utf-8") as f:
                    self.config_data = yaml.safe_load(f) or {}
                logger.info(f"ConfigManager: تم تحميل الإعدادات من '{self.config_path}'.")
            except Exception as exc:
                logger.error(f"ConfigManager: خطأ أثناء قراءة ملف الإعدادات '{self.config_path}': {exc}", exc_info=True)
                self.config_data = {}

    def _create_default_config(self) -> None:
        """
        إنشاء ملف إعدادات افتراضي مع دعم Views
        """
        self.config_data = {
            'language': self.env_data.get('default_language', 'ar'),
            'appearance_mode': self.env_data.get('default_theme', 'light'),
            'color_theme': 'blue',
            'view_name': 'Sales App',
            'window_size': {
                'width': 1024,
                'height': 768
            },
            # إضافة الإعدادات الافتراضية لـ Views
            'views_settings': {
                'allow_view_switching': True,
                'show_current_view_in_status': True,
                'default_views': {
                    'admin': 'All Records',
                    'manager': 'Manager View',
                    'editor': 'Team View',
                    'viewer': 'My Bookings'
                },
                'role_views': {
                    'admin': ['All Records', 'Today\'s Bookings', 'This Week', 'This Month'],
                    'manager': ['Manager View', 'Team View', 'Today\'s Bookings', 'This Week'],
                    'editor': ['Team View', 'My Bookings', 'Today\'s Bookings'],
                    'viewer': ['My Bookings']
                }
            },
            'cache_settings': {
                'enable_cache': True,
                'default_cache_duration': 15,
                'view_cache_duration': {
                    'All Records': 30,
                    'Today\'s Bookings': 5,
                    'This Week': 15,
                    'This Month': 60
                }
            },
            'performance_settings': {
                'records_per_page': 100,
                'enable_lazy_loading': True,
                'show_loading_indicator': True,
                'background_loading': True
            }
        }
        self._save_config()

    def _merge_settings(self) -> None:
        """
        دمج الإعدادات مع إعطاء الأولوية لمتغيرات البيئة
        """
        # المتغيرات الحساسة من .env تأخذ الأولوية دائماً
        if self.env_data.get('airtable_api_key'):
            self.config_data['airtable_api_key'] = self.env_data['airtable_api_key']
        if self.env_data.get('airtable_base_id'):
            self.config_data['airtable_base_id'] = self.env_data['airtable_base_id']
        if self.env_data.get('airtable_users_table'):
            self.config_data['airtable_users_table'] = self.env_data['airtable_users_table']
        if self.env_data.get('airtable_booking_table'):
            self.config_data['airtable_booking_table'] = self.env_data['airtable_booking_table']

    def get(self, key: str, default: Optional[Any] = None) -> Any:
        """
        إرجاع قيمة الإعداد، مع التحقق من متغيرات البيئة أولاً

        :param key: اسم الإعداد
        :param default: القيمة الافتراضية
        :return: قيمة الإعداد
        """
        # التحقق من متغيرات البيئة أولاً للمفاتيح الحساسة
        if key in ['airtable_api_key', 'airtable_base_id']:
            env_value = self.env_data.get(key)
            if env_value:
                return env_value

        return self.config_data.get(key, default)

    def set(self, key: str, value: Any) -> None:
        """
        تعيين قيمة جديدة في الإعدادات
        ملاحظة: لا يتم حفظ المعلومات الحساسة في YAML

        :param key: اسم الإعداد
        :param value: القيمة الجديدة
        """
        # منع حفظ المعلومات الحساسة في YAML
        sensitive_keys = ['airtable_api_key', 'airtable_base_id', 'password', 'secret']

        if key not in sensitive_keys:
            self.config_data[key] = value
            logger.debug(f"ConfigManager: تم تعيين key='{key}' إلى القيمة: {value!r}.")
            self._save_config()
        else:
            logger.warning(f"ConfigManager: محاولة حفظ معلومات حساسة '{key}' - تم التجاهل")

    def _save_config(self) -> None:
        """
        حفظ الإعدادات غير الحساسة إلى ملف YAML
        """
        # إنشاء نسخة من البيانات بدون المعلومات الحساسة
        safe_data = {}
        sensitive_keys = ['airtable_api_key', 'airtable_base_id', 'password', 'secret']

        for key, value in self.config_data.items():
            if key not in sensitive_keys:
                safe_data[key] = value

        try:
            with open(self.config_path, "w", encoding="utf-8") as f:
                yaml.safe_dump(safe_data, f, default_flow_style=False, sort_keys=False, allow_unicode=True)
            logger.info(f"ConfigManager: تم حفظ الإعدادات في '{self.config_path}'.")
        except Exception as exc:
            logger.error(f"ConfigManager: فشل حفظ الإعدادات إلى '{self.config_path}': {exc}", exc_info=True)

    def reload(self) -> None:
        """
        إعادة تحميل جميع الإعدادات
        """
        logger.debug("ConfigManager: إعادة تحميل الإعدادات.")
        self._load_env()
        self._load_config()
        self._merge_settings()

    # ============ دوال جديدة لدعم Views ============

    def get_all_settings(self) -> Dict[str, Any]:
        """الحصول على جميع الإعدادات"""
        return self.config_data.copy()

    def get_setting(self, key: str, default: Any = None) -> Any:
        """الحصول على إعداد محدد (مرادف لـ get)"""
        return self.get(key, default)

    def get_nested_setting(self, keys: List[str], default: Any = None) -> Any:
        """
        الحصول على إعداد متداخل

        :param keys: قائمة المفاتيح للوصول للقيمة المتداخلة
        :param default: القيمة الافتراضية
        :return: القيمة المطلوبة أو القيمة الافتراضية
        """
        value = self.config_data
        for key in keys:
            if isinstance(value, dict):
                value = value.get(key)
            else:
                return default
        return value if value is not None else default

    # دوال خاصة بـ Views
    def get_views_settings(self) -> Dict[str, Any]:
        """الحصول على جميع إعدادات Views"""
        return self.get_setting('views_settings', {
            'allow_view_switching': True,
            'default_views': {'viewer': 'My Bookings'}
        })

    def get_role_views(self, role: str) -> List[str]:
        """
        الحصول على Views المسموحة لدور معين

        :param role: دور المستخدم (admin, manager, editor, viewer)
        :return: قائمة أسماء Views المسموحة
        """
        return self.get_nested_setting(
            ['views_settings', 'role_views', role],
            ['My Bookings']  # القيمة الافتراضية
        )

    def get_default_view(self, role: str) -> str:
        """
        الحصول على View الافتراضي لدور معين

        :param role: دور المستخدم
        :return: اسم View الافتراضي
        """
        return self.get_nested_setting(
            ['views_settings', 'default_views', role],
            'My Bookings'
        )

    def is_view_switching_allowed(self) -> bool:
        """التحقق من السماح بتبديل Views"""
        return self.get_nested_setting(
            ['views_settings', 'allow_view_switching'],
            True
        )

    def get_view_cache_duration(self, view_name: str) -> int:
        """
        الحصول على مدة الكاش لـ View معين بالدقائق

        :param view_name: اسم View
        :return: مدة الكاش بالدقائق
        """
        duration = self.get_nested_setting(
            ['cache_settings', 'view_cache_duration', view_name]
        )
        if duration is None:
            duration = self.get_nested_setting(
                ['cache_settings', 'default_cache_duration'],
                15
            )
        return duration

    def get_view_specific_settings(self, view_name: str) -> Dict[str, Any]:
        """
        الحصول على الإعدادات الخاصة بـ View معين

        :param view_name: اسم View
        :return: قاموس بالإعدادات الخاصة
        """
        return self.get_nested_setting(
            ['views_settings', 'view_specific_settings', view_name],
            {}
        )

    def get_performance_settings(self) -> Dict[str, Any]:
        """الحصول على إعدادات الأداء"""
        return self.get_setting('performance_settings', {
            'records_per_page': 100,
            'enable_lazy_loading': True,
            'show_loading_indicator': True,
            'background_loading': True
        })

    def get_export_settings(self) -> Dict[str, Any]:
        """الحصول على إعدادات التصدير"""
        return self.get_setting('export_settings', {
            'allowed_formats': ['excel', 'pdf', 'csv'],
            'max_export_records': 5000,
            'include_timestamp': True
        })

    def get_cache_settings(self) -> Dict[str, Any]:
        """الحصول على جميع إعدادات الكاش"""
        return self.get_setting('cache_settings', {
            'enable_cache': True,
            'default_cache_duration': 15,
            'max_cache_size': 1000,
            'clear_on_logout': True
        })

    def is_cache_enabled(self) -> bool:
        """التحقق من تفعيل الكاش"""
        return self.get_nested_setting(['cache_settings', 'enable_cache'], True)

    def get_security_settings(self) -> Dict[str, Any]:
        """الحصول على إعدادات الأمان"""
        return self.get_setting('security_settings', {
            'session_timeout': 60,
            'log_failed_attempts': True,
            'max_failed_attempts': 5,
            'lockout_duration': 15
        })

    def get_logging_settings(self) -> Dict[str, Any]:
        """الحصول على إعدادات السجلات"""
        return self.get_setting('logging_settings', {
            'level': 'INFO',
            'log_to_file': True,
            'log_file_path': 'logs/app.log',
            'max_log_size': 10,
            'backup_count': 5
        })

    def update_setting(self, key: str, value: Any) -> bool:
        """
        تحديث إعداد معين (مرادف لـ set مع إرجاع نتيجة)

        :param key: اسم الإعداد
        :param value: القيمة الجديدة
        :return: True إذا نجح التحديث
        """
        try:
            self.set(key, value)
            return True
        except Exception as e:
            logger.error(f"Error updating setting {key}: {e}")
            return False

    def save_settings(self) -> bool:
        """
        حفظ الإعدادات إلى الملف (مرادف لـ _save_config)

        :return: True إذا نجح الحفظ
        """
        try:
            self._save_config()
            return True
        except Exception:
            return False

    # ============ دوال إعدادات المستخدم ============
    USER_SETTINGS_FILE = "user_settings.yaml"

    def _load_user_settings(self):
        """تحميل إعدادات المستخدم الشخصية"""
        try:
            with open(self.USER_SETTINGS_FILE, "r", encoding="utf-8") as f:
                self.user_settings = yaml.safe_load(f) or {}
        except FileNotFoundError:
            self.user_settings = {
                "language": "ar",
                "theme": "light",
                "window_size": {"width": 1024, "height": 768},
                "last_filter": "",
                "last_view": "",  # إضافة آخر View مستخدم
                "favorites_views": []  # Views المفضلة
            }
            with open(self.USER_SETTINGS_FILE, "w", encoding="utf-8") as f:
                yaml.dump(self.user_settings, f, allow_unicode=True)

    def save_user_setting(self, key: str, value: Any):
        """حفظ إعداد مستخدم معين"""
        if not hasattr(self, 'user_settings'):
            self._load_user_settings()

        self.user_settings[key] = value
        with open(self.USER_SETTINGS_FILE, "w", encoding="utf-8") as f:
            yaml.dump(self.user_settings, f, allow_unicode=True)

    def get_user_setting(self, key: str, default: Any = None) -> Any:
        """الحصول على إعداد مستخدم معين"""
        if not hasattr(self, 'user_settings'):
            self._load_user_settings()

        return self.user_settings.get(key, default)

    def get_last_used_view(self) -> Optional[str]:
        """الحصول على آخر View استخدمه المستخدم"""
        return self.get_user_setting('last_view')

    def save_last_used_view(self, view_name: str):
        """حفظ آخر View استخدمه المستخدم"""
        self.save_user_setting('last_view', view_name)

    def get_favorite_views(self) -> List[str]:
        """الحصول على Views المفضلة للمستخدم"""
        return self.get_user_setting('favorites_views', [])

    def add_favorite_view(self, view_name: str):
        """إضافة View للمفضلة"""
        favorites = self.get_favorite_views()
        if view_name not in favorites:
            favorites.append(view_name)
            self.save_user_setting('favorites_views', favorites)

    def remove_favorite_view(self, view_name: str):
        """إزالة View من المفضلة"""
        favorites = self.get_favorite_views()
        if view_name in favorites:
            favorites.remove(view_name)
            self.save_user_setting('favorites_views', favorites)

    def get_airtable_config(self) -> Dict[str, str]:
        """
        الحصول على إعدادات Airtable من متغيرات البيئة

        :return: قاموس يحتوي على api_key و base_id
        """
        return {
            'api_key': self.env_data.get('airtable_api_key', ''),
            'base_id': self.env_data.get('airtable_base_id', ''),
            'users_table': self.env_data.get('airtable_users_table', 'users'),
            'booking_table': self.env_data.get('airtable_booking_table', 'List V2')
        }

    def get_dropdown_tables_config(self) -> Dict[str, str]:
        """
        الحصول على أسماء جداول القوائم المنسدلة

        :return: قاموس بأسماء الجداول
        """
        return {
            'guides': self.env_data.get('airtable_guides_table', 'Guides'),
            'agencies': self.env_data.get('airtable_agencies_table', 'Agencies'),
            'options': self.env_data.get('airtable_options_table', 'Trip Options'),
            'destinations': self.env_data.get('airtable_destinations_table', 'Destinations'),
            'tripnames': self.env_data.get('airtable_tripnames_table', 'Trip Names'),
            'management_options': self.env_data.get('airtable_management_options_table', 'Management Options'),
            'addons': self.env_data.get('airtable_addons_table', 'Add-ons')
        }

============================================================
FILE: core\constants.py
SIZE: 8556 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/constants.py

ثوابت التطبيق
Application Constants
"""

from enum import Enum
from typing import Dict, List, Tuple


class LoginConstants:
    """ثوابت تسجيل الدخول"""

    # Password requirements
    MIN_PASSWORD_LENGTH = 8
    MAX_PASSWORD_LENGTH = 128
    PASSWORD_SPECIAL_CHARS = "!@#$%^&*()_+-=[]{}|;:,.<>?"

    # Security settings
    MAX_LOGIN_ATTEMPTS = 5
    LOGIN_TIMEOUT = 30  # seconds
    SESSION_TIMEOUT = 1800  # 30 minutes
    LOCKOUT_DURATION = 300  # 5 minutes

    # Rate limiting
    RATE_LIMIT_WINDOW = 300  # 5 minutes
    RATE_LIMIT_MAX_ATTEMPTS = 5

    # Session management
    SESSION_COOKIE_NAME = "fts_session"
    SESSION_COOKIE_SECURE = True
    SESSION_COOKIE_HTTPONLY = True
    SESSION_COOKIE_SAMESITE = "Strict"

    # Token settings
    TOKEN_LENGTH = 32
    CSRF_TOKEN_LENGTH = 32
    REFRESH_TOKEN_EXPIRY = 604800  # 7 days

    # Validation
    USERNAME_MIN_LENGTH = 3
    USERNAME_MAX_LENGTH = 50
    USERNAME_PATTERN = r'^[a-zA-Z0-9_.-]+$'

    # 2FA settings
    OTP_LENGTH = 6
    OTP_VALIDITY = 300  # 5 minutes
    BACKUP_CODES_COUNT = 10


class WindowConstants:
    """ثوابت النوافذ"""

    # Login window
    LOGIN_WINDOW_SIZE = "450x700"
    MIN_WINDOW_WIDTH = 450
    MIN_WINDOW_HEIGHT = 700
    MAX_WINDOW_WIDTH = 600
    MAX_WINDOW_HEIGHT = 800

    # Animations
    ANIMATION_DURATION = 300
    FLASH_INTERVAL = 300
    FADE_DURATION = 200
    SLIDE_DURATION = 250

    # UI elements
    BUTTON_HEIGHT = 45
    BUTTON_CORNER_RADIUS = 22
    ENTRY_HEIGHT = 45
    ENTRY_CORNER_RADIUS = 10

    # Spacing
    PADDING_X = 25
    PADDING_Y = 25
    ELEMENT_SPACING = 10
    SECTION_SPACING = 20


class ThemeConstants:
    """ثوابت الثيمات"""

    # Color schemes
    THEMES = {
        "blue": {
            "primary": "#3498db",
            "primary_hover": "#2980b9",
            "secondary": "#2c3e50",
            "secondary_hover": "#1a252f",
            "success": "#27ae60",
            "error": "#e74c3c",
            "warning": "#f39c12",
            "info": "#3498db"
        },
        "green": {
            "primary": "#27ae60",
            "primary_hover": "#229954",
            "secondary": "#16a085",
            "secondary_hover": "#138d75",
            "success": "#27ae60",
            "error": "#e74c3c",
            "warning": "#f39c12",
            "info": "#3498db"
        },
        "dark": {
            "primary": "#34495e",
            "primary_hover": "#2c3e50",
            "secondary": "#7f8c8d",
            "secondary_hover": "#707b7c",
            "success": "#27ae60",
            "error": "#e74c3c",
            "warning": "#f39c12",
            "info": "#3498db"
        }
    }

    # Gradients
    GRADIENTS = {
        "primary": ["#3498db", "#2980b9"],
        "success": ["#27ae60", "#229954"],
        "error": ["#e74c3c", "#c0392b"],
        "warning": ["#f39c12", "#d68910"],
        "info": ["#3498db", "#2980b9"]
    }

    # Font settings
    FONT_FAMILY = "Segoe UI"
    FONT_FAMILY_ARABIC = "Arial"
    FONT_SIZE_BASE = 14
    FONT_SIZE_SMALL = 12
    FONT_SIZE_LARGE = 16
    FONT_SIZE_TITLE = 28
    FONT_SIZE_SUBTITLE = 18


class SecurityLevel(Enum):
    """مستويات الأمان"""
    LOW = "low"
    MEDIUM = "medium"
    HIGH = "high"
    CRITICAL = "critical"


class AuthenticationMethod(Enum):
    """طرق المصادقة"""
    PASSWORD = "password"
    TWO_FACTOR = "two_factor"
    BIOMETRIC = "biometric"
    SSO = "sso"
    MAGIC_LINK = "magic_link"
    HARDWARE_KEY = "hardware_key"


class LoginStatus(Enum):
    """حالات تسجيل الدخول"""
    PENDING = "pending"
    IN_PROGRESS = "in_progress"
    SUCCESS = "success"
    FAILED = "failed"
    LOCKED = "locked"
    TIMEOUT = "timeout"
    CANCELLED = "cancelled"


class PasswordStrength(Enum):
    """قوة كلمة المرور"""
    VERY_WEAK = (0, "very_weak", "#e74c3c")
    WEAK = (1, "weak", "#e74c3c")
    FAIR = (2, "fair", "#f39c12")
    GOOD = (3, "good", "#f1c40f")
    STRONG = (4, "strong", "#27ae60")
    VERY_STRONG = (5, "very_strong", "#27ae60")

    def __init__(self, level: int, name: str, color: str):
        self.level = level
        self.strength_name = name
        self.color = color


class ErrorCode(Enum):
    """رموز الأخطاء"""
    NONE = 0
    INVALID_CREDENTIALS = 1001
    ACCOUNT_LOCKED = 1002
    SESSION_EXPIRED = 1003
    NETWORK_ERROR = 1004
    SERVER_ERROR = 1005
    RATE_LIMIT_EXCEEDED = 1006
    INVALID_2FA = 1007
    PERMISSION_DENIED = 1008
    MAINTENANCE_MODE = 1009
    UNKNOWN_ERROR = 9999


class MessageType(Enum):
    """أنواع الرسائل"""
    INFO = "info"
    SUCCESS = "success"
    WARNING = "warning"
    ERROR = "error"
    DEBUG = "debug"


# API Endpoints
API_ENDPOINTS = {
    "auth": {
        "login": "/api/v1/auth/login",
        "logout": "/api/v1/auth/logout",
        "refresh": "/api/v1/auth/refresh",
        "verify": "/api/v1/auth/verify",
        "forgot_password": "/api/v1/auth/forgot-password",
        "reset_password": "/api/v1/auth/reset-password",
        "change_password": "/api/v1/auth/change-password",
        "verify_2fa": "/api/v1/auth/verify-2fa",
        "setup_2fa": "/api/v1/auth/setup-2fa"
    },
    "user": {
        "profile": "/api/v1/user/profile",
        "update_profile": "/api/v1/user/update-profile",
        "sessions": "/api/v1/user/sessions",
        "devices": "/api/v1/user/devices",
        "security_log": "/api/v1/user/security-log"
    }
}


# Regular expressions
REGEX_PATTERNS = {
    "username": r'^[a-zA-Z0-9_.-]+$',
    "email": r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$',
    "phone": r'^\+?[0-9\s\-\(\)]+$',
    "strong_password": r'^(?=.*[a-z])(?=.*[A-Z])(?=.*\d)(?=.*[@$!%*?&])[A-Za-z\d@$!%*?&]{8,}$',
    "url": r'^https?://(?:www\.)?[-a-zA-Z0-9@:%._\+~#=]{1,256}\.[a-zA-Z0-9()]{1,6}\b(?:[-a-zA-Z0-9()@:%_\+.~#?&\/=]*)$',
    "ipv4": r'^(?:(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)\.){3}(?:25[0-5]|2[0-4][0-9]|[01]?[0-9][0-9]?)$',
    "ipv6": r'^(([0-9a-fA-F]{1,4}:){7,7}[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,7}:|([0-9a-fA-F]{1,4}:){1,6}:[0-9a-fA-F]{1,4}|([0-9a-fA-F]{1,4}:){1,5}(:[0-9a-fA-F]{1,4}){1,2}|([0-9a-fA-F]{1,4}:){1,4}(:[0-9a-fA-F]{1,4}){1,3}|([0-9a-fA-F]{1,4}:){1,3}(:[0-9a-fA-F]{1,4}){1,4}|([0-9a-fA-F]{1,4}:){1,2}(:[0-9a-fA-F]{1,4}){1,5}|[0-9a-fA-F]{1,4}:((:[0-9a-fA-F]{1,4}){1,6})|:((:[0-9a-fA-F]{1,4}){1,7}|:)|fe80:(:[0-9a-fA-F]{0,4}){0,4}%[0-9a-zA-Z]{1,}|::(ffff(:0{1,4}){0,1}:){0,1}((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])|([0-9a-fA-F]{1,4}:){1,4}:((25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9])\.){3,3}(25[0-5]|(2[0-4]|1{0,1}[0-9]){0,1}[0-9]))$'
}


# Default messages
DEFAULT_MESSAGES = {
    "en": {
        "welcome": "Welcome to FTS Sales Manager",
        "login_prompt": "Please enter your credentials to continue",
        "login_success": "Login successful! Redirecting...",
        "login_failed": "Login failed. Please check your credentials.",
        "account_locked": "Your account has been locked. Please contact support.",
        "session_expired": "Your session has expired. Please login again.",
        "password_changed": "Your password has been changed successfully.",
        "profile_updated": "Your profile has been updated successfully.",
        "logout_success": "You have been logged out successfully.",
        "maintenance_mode": "System is under maintenance. Please try again later."
    },
    "ar": {
        "welcome": "مرحباً بك في مدير مبيعات FTS",
        "login_prompt": "يرجى إدخال بياناتك للمتابعة",
        "login_success": "تم تسجيل الدخول بنجاح! جاري التحويل...",
        "login_failed": "فشل تسجيل الدخول. يرجى التحقق من بياناتك.",
        "account_locked": "تم قفل حسابك. يرجى الاتصال بالدعم.",
        "session_expired": "انتهت صلاحية جلستك. يرجى تسجيل الدخول مرة أخرى.",
        "password_changed": "تم تغيير كلمة المرور بنجاح.",
        "profile_updated": "تم تحديث ملفك الشخصي بنجاح.",
        "logout_success": "تم تسجيل الخروج بنجاح.",
        "maintenance_mode": "النظام تحت الصيانة. يرجى المحاولة لاحقاً."
    }
}


# Icons
ICONS = {
    "user": "👤",
    "lock": "🔒",
    "eye": "👁",
    "eye_closed": "👁‍🗨",
    "key": "🔑",
    "shield": "🛡️",
    "warning": "⚠️",
    "error": "❌",
    "success": "✅",
    "info": "ℹ️",
    "language": "🌐",
    "theme": "🌓",
    "help": "❓",
    "settings": "⚙️",
    "logout": "🚪",
    "fingerprint": "👆",
    "face": "😊",
    "email": "📧",
    "phone": "📱",
    "clock": "🕐",
    "calendar": "📅",
    "location": "📍",
    "device": "💻"
}

============================================================
FILE: core\db_manager.py
SIZE: 10852 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/db_manager.py

تدير هذه الفئة الاتصال بقاعدة بيانات SQLite المحلية لاستخدامها ككاش (Cache) للبيانات
المستخرجة من Airtable. توفر واجهات لحفظ واسترجاع السجلات المؤقتة مع دعم جداول متعددة.
"""

# ------------------------------------------------------------
# استيرادات المكتبات القياسية
# ------------------------------------------------------------
import sqlite3
import threading
from typing import Any, Dict, List, Optional

# ------------------------------------------------------------
# استيرادات وحدات المشروع
# ------------------------------------------------------------
from core.logger import logger


class DatabaseManager:
    """
    فئة DatabaseManager تتولى:
    - إنشاء اتصال بقاعدة بيانات SQLite (ملف db_path).
    - تهيئة جداول الكاش المتعددة (users_cache, bookings_cache, records_cache).
    - إتاحة طرق للحفظ والاسترجاع من الكاش لكل جدول.
    """

    def __init__(self, db_path: str) -> None:
        """
        تهيئة DatabaseManager.

        :param db_path: مسار ملف قاعدة بيانات SQLite (مثل "fts_sales_cache.db").
        """
        self.db_path: str = db_path
        self._conn: Optional[sqlite3.Connection] = None
        self._lock: threading.Lock = threading.Lock()
        self._connect_and_init()

    def _connect_and_init(self) -> None:
        """
        إنشاء اتصال بقاعدة البيانات وتهيئة جداول الكاش لكل جدول Airtable.
        """
        try:
            self._conn = sqlite3.connect(self.db_path, check_same_thread=False)
            cursor = self._conn.cursor()

            # إنشاء جدول منفصل لكل نوع من البيانات
            # جدول للمستخدمين
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS users_cache (
                    id TEXT PRIMARY KEY,
                    data TEXT NOT NULL,
                    table_name TEXT DEFAULT 'Users'
                );
            """)

            # جدول للحجوزات
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS bookings_cache (
                    id TEXT PRIMARY KEY,
                    data TEXT NOT NULL,
                    table_name TEXT DEFAULT 'List V2'
                );
            """)

            # جدول عام للكاش (للتوافق مع الكود القديم)
            cursor.execute("""
                CREATE TABLE IF NOT EXISTS records_cache (
                    id TEXT PRIMARY KEY,
                    data TEXT NOT NULL,
                    table_name TEXT
                );
            """)

            self._conn.commit()
            logger.info(f"DatabaseManager: متصل بقاعدة البيانات '{self.db_path}' وتم تهيئة جداول الكاش.")
        except Exception as exc:
            logger.error(f"DatabaseManager: فشل في إنشاء/تهيئة قاعدة البيانات '{self.db_path}': {exc}", exc_info=True)

    def get_cached_record(self, record_id: str, table_name: str = None) -> Optional[str]:
        """
        استرجاع السجل المؤقت المخزن في الكاش من الجدول المناسب.
        :param record_id: معرف السجل الذي نبحث عنه.
        :param table_name: اسم الجدول (اختياري)
        :return: البيانات (json) كسلسلة نصية إذا وُجدت، وإلا None.
        """
        if not self._conn:
            logger.warning("DatabaseManager: محاولة استرجاع سجل قبل وجود اتصال بقاعدة البيانات.")
            return None

        try:
            with self._lock:
                cursor = self._conn.cursor()

                # تحديد الجدول المناسب بناءً على table_name
                if table_name == "Users":
                    cursor.execute("SELECT data FROM users_cache WHERE id = ?;", (record_id,))
                elif table_name == "List V2":
                    cursor.execute("SELECT data FROM bookings_cache WHERE id = ?;", (record_id,))
                else:
                    cursor.execute("SELECT data FROM records_cache WHERE id = ?;", (record_id,))

                result = cursor.fetchone()

            if result:
                logger.debug(f"DatabaseManager: وجد السجل '{record_id}' في الكاش (جدول: {table_name}).")
                return result[0]
            logger.debug(f"DatabaseManager: السجل '{record_id}' غير موجود في الكاش.")
            return None
        except Exception as exc:
            logger.error(f"DatabaseManager: خطأ أثناء استرجاع السجل '{record_id}' من الكاش: {exc}", exc_info=True)
            return None

    def set_cached_record(self, record_id: str, data: str, table_name: str = None) -> None:
        """
        تخزين السجل المؤقت في جدول الكاش المناسب.
        :param record_id: معرف السجل.
        :param data: البيانات المراد تخزينها كسلسلة نصية (عادة JSON).
        :param table_name: اسم الجدول (اختياري)
        """
        if not self._conn:
            logger.warning("DatabaseManager: محاولة تخزين سجل قبل وجود اتصال بقاعدة البيانات.")
            return

        try:
            with self._lock:
                cursor = self._conn.cursor()

                # تحديد الجدول المناسب
                if table_name == "Users":
                    cursor.execute("""
                        INSERT INTO users_cache (id, data) VALUES (?, ?)
                        ON CONFLICT(id) DO UPDATE SET data=excluded.data;
                    """, (record_id, data))
                elif table_name == "List V2":
                    cursor.execute("""
                        INSERT INTO bookings_cache (id, data) VALUES (?, ?)
                        ON CONFLICT(id) DO UPDATE SET data=excluded.data;
                    """, (record_id, data))
                else:
                    cursor.execute("""
                        INSERT INTO records_cache (id, data, table_name) VALUES (?, ?, ?)
                        ON CONFLICT(id) DO UPDATE SET data=excluded.data, table_name=excluded.table_name;
                    """, (record_id, data, table_name))

                self._conn.commit()
            logger.debug(f"DatabaseManager: تم تخزين/تحديث السجل '{record_id}' في الكاش (جدول: {table_name}).")
        except Exception as exc:
            logger.error(f"DatabaseManager: خطأ أثناء تخزين السجل '{record_id}' في الكاش: {exc}", exc_info=True)

    def get_all_cached_ids(self, table_name: str = None) -> List[str]:
        """
        إرجاع قائمة بجميع معرفات السجلات المخزنة في جدول الكاش المحدد.
        :param table_name: اسم الجدول (اختياري)
        :return: قائمة معرفات كسلاسل نصية.
        """
        if not self._conn:
            logger.warning("DatabaseManager: محاولة جلب جميع معرفات قبل وجود اتصال بقاعدة البيانات.")
            return []

        try:
            with self._lock:
                cursor = self._conn.cursor()

                if table_name == "Users":
                    cursor.execute("SELECT id FROM users_cache;")
                elif table_name == "List V2":
                    cursor.execute("SELECT id FROM bookings_cache;")
                else:
                    cursor.execute("SELECT id FROM records_cache;")

                rows = cursor.fetchall()

            ids = [row[0] for row in rows]
            logger.debug(f"DatabaseManager: جُلبت جميع المعرفات من الكاش ({len(ids)} سجلاً) - جدول: {table_name}.")
            return ids
        except Exception as exc:
            logger.error(f"DatabaseManager: خطأ أثناء جلب جميع المعرفات من الكاش: {exc}", exc_info=True)
            return []

    def clear_cache(self, table_name: str = None) -> None:
        """
        حذف جميع السجلات من جدول الكاش المحدد.
        :param table_name: اسم الجدول (None = حذف الكل)
        """
        if not self._conn:
            logger.warning("DatabaseManager: محاولة مسح الكاش قبل وجود اتصال بقاعدة البيانات.")
            return

        try:
            with self._lock:
                cursor = self._conn.cursor()

                if table_name == "Users":
                    cursor.execute("DELETE FROM users_cache;")
                elif table_name == "List V2":
                    cursor.execute("DELETE FROM bookings_cache;")
                elif table_name is None:
                    # حذف جميع الجداول
                    cursor.execute("DELETE FROM users_cache;")
                    cursor.execute("DELETE FROM bookings_cache;")
                    cursor.execute("DELETE FROM records_cache;")
                else:
                    cursor.execute("DELETE FROM records_cache WHERE table_name = ?;", (table_name,))

                self._conn.commit()
            logger.info(f"DatabaseManager: تم مسح السجلات من الكاش (جدول: {table_name or 'الكل'}).")
        except Exception as exc:
            logger.error(f"DatabaseManager: خطأ أثناء مسح الكاش: {exc}", exc_info=True)

    def delete_cached_record(self, record_id: str, table_name: str = None) -> bool:
        """
        حذف سجل محدد من جدول الكاش.
        :param record_id: معرف السجل المراد حذفه.
        :param table_name: اسم الجدول (اختياري)
        :return: True إذا تم الحذف بنجاح، False خلاف ذلك.
        """
        if not self._conn:
            logger.warning("DatabaseManager: محاولة حذف سجل قبل وجود اتصال بقاعدة البيانات.")
            return False

        try:
            with self._lock:
                cursor = self._conn.cursor()

                # تحديد الجدول المناسب وحذف السجل
                if table_name == "Users":
                    cursor.execute("DELETE FROM users_cache WHERE id = ?;", (record_id,))
                elif table_name == "List V2":
                    cursor.execute("DELETE FROM bookings_cache WHERE id = ?;", (record_id,))
                else:
                    cursor.execute("DELETE FROM records_cache WHERE id = ?;", (record_id,))

                self._conn.commit()

                # التحقق من أن السجل تم حذفه فعلاً
                if cursor.rowcount > 0:
                    logger.debug(f"DatabaseManager: تم حذف السجل '{record_id}' من الكاش (جدول: {table_name}).")
                    return True
                else:
                    logger.debug(f"DatabaseManager: السجل '{record_id}' لم يكن موجوداً في الكاش.")
                    return False

        except Exception as exc:
            logger.error(f"DatabaseManager: خطأ أثناء حذف السجل '{record_id}' من الكاش: {exc}", exc_info=True)
            return False

    def close(self) -> None:
        """
        إغلاق اتصال قاعدة البيانات عند إنهاء التطبيق.
        """
        if self._conn:
            try:
                self._conn.close()
                logger.info("DatabaseManager: تم إغلاق اتصال قاعدة البيانات.")
            except Exception as exc:
                logger.error(f"DatabaseManager: خطأ أثناء إغلاق اتصال قاعدة البيانات: {exc}", exc_info=True)
            finally:
                self._conn = None

============================================================
FILE: core\event_system.py
SIZE: 1015 characters
============================================================

# core/event_system.py
from typing import Callable, Dict, List, Any
import threading
from datetime import datetime
import queue

class EventBus:
    """ناقل الأحداث المركزي"""

    def __init__(self):
        self._subscribers: Dict[str, List[Callable]] = {}
        self._lock = threading.Lock()

    def emit(self, event_name: str, data: Any = None):
        """إطلاق حدث"""
        subscribers = self._subscribers.get(event_name, [])
        for callback in subscribers:
            try:
                threading.Thread(
                    target=lambda: callback(data),
                    daemon=True
                ).start()
            except Exception as e:
                print(f"Error in event callback: {e}")

    def subscribe(self, event_name: str, callback: Callable):
        """الاشتراك في حدث"""
        with self._lock:
            if event_name not in self._subscribers:
                self._subscribers[event_name] = []
            self._subscribers[event_name].append(callback)

============================================================
FILE: core\language_manager.py
SIZE: 6614 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/language_manager.py

تدير هذه الفئة تحميل الترجمات (locale) بناءً على اختيار المستخدم للغة (عربي أو إنجليزي).
تعتمد على ملفات YAML داخل مجلد locales/ للحصول على النصوص المترجمة حسب المفاتيح.
يمكن تغيير اللغة أثناء تشغيل التطبيق دون إعادة تشغيله.
"""

# ------------------------------------------------------------
# استيرادات المكتبات القياسية
# ------------------------------------------------------------
import os
from typing import Any, Dict

# ------------------------------------------------------------
# استيرادات المكتبات الخارجية
# ------------------------------------------------------------
import yaml

# ------------------------------------------------------------
# استيرادات وحدات المشروع
# ------------------------------------------------------------
from core.config_manager import ConfigManager
from core.logger import logger


class LanguageManager:
    """
    فئة LanguageManager مسؤولة عن:
    - قراءة إعدادات اللغة الحالية من ConfigManager.
    - تحميل ملف الترجمة المناسب (ar.yaml أو en.yaml) إلى قاموس داخلي.
    - توفير واجهة للحصول على النص المترجم حسب المفتاح (text key).
    - تغيير اللغة وتحديث ConfigManager وإعادة تحميل الترجمات.
    """

    def __init__(self, config_manager: ConfigManager) -> None:
        """
        تهيئة LanguageManager.
        :param config_manager: كائن ConfigManager لقراءة/تعديل إعداد اللغة في ملف الإعدادات.
        """
        self.config_manager = config_manager

        # افتراض أن ConfigManager لديه دالة get() أو get_config()
        try:
            # محاولة الحصول على اللغة من ConfigManager
            self.current_lang: str = self.config_manager.get("language", "en")
        except AttributeError:
            try:
                # محاولة بديلة
                config_data = self.config_manager.get_config()
                self.current_lang: str = config_data.get("language", "en")
            except:
                # القيمة الافتراضية
                self.current_lang: str = "en"

        self.translations: Dict[str, Any] = {}
        self._load_translations()

    def _load_translations(self) -> None:
        """
        تحميل ملف الترجمة بناءً على self.current_lang إلى القاموس self.translations.
        يتوقع وجود ملف ضمن مجلد "locales" بالتنسيق "<lang>.yaml"، مثل "ar.yaml" أو "en.yaml".
        """
        lang_code = self.current_lang.lower()
        locales_dir = os.path.join("locales")
        file_name = f"{lang_code}.yaml"
        file_path = os.path.join(locales_dir, file_name)

        if not os.path.isdir(locales_dir):
            logger.warning(f"LanguageManager: مجلد 'locales/' غير موجود. لا يمكن تحميل الترجمات.")
            self.translations = {}
            return

        if not os.path.isfile(file_path):
            logger.error(f"LanguageManager: ملف الترجمة '{file_path}' غير موجود. استخدم المفاتيح الافتراضية (اللغة الإنجليزية).")
            self.translations = {}
            return

        try:
            with open(file_path, "r", encoding="utf-8") as f:
                self.translations = yaml.safe_load(f) or {}
            logger.info(f"LanguageManager: تم تحميل الترجمات من '{file_path}'.")
        except Exception as exc:
            logger.error(f"LanguageManager: خطأ أثناء قراءة ملف الترجمة '{file_path}': {exc}", exc_info=True)
            self.translations = {}

    def get(self, key: str, default: str = "") -> str:
        """
        إرجاع النص المترجم للمفتاح المحدد.
        إذا لم يكن المفتاح موجودًا في القاموس، يُعاد default.

        :param key: المفتاح النصي كما هو موجود في ملفات الترجمة YAML.
        :param default: القيمة الافتراضية إذا لم يُعثر على المفتاح.
        :return: النص المترجم (أو default).
        """
        # في حالة وجود تعشيش في ملفات YAML تكون القيم قد تكون dict؛ ولكن هنا نتوقع قيمة نصية لكل مفتاح.
        value = self.translations.get(key)
        if isinstance(value, str):
            return value
        elif value is None:
            return default
        else:
            # في حال كان المفتاح يشير إلى هيكل معقد (غير نص مباشرة)، نحوله إلى نص
            try:
                return str(value)
            except Exception:
                return default

    def set_language(self, lang_code: str) -> None:
        """
        تغيير اللغة الحالية إلى lang_code (مثل "ar" أو "en").
        يتم تحديث ConfigManager وحفظه، ثم إعادة تحميل الترجمات الجديدة.

        :param lang_code: رمز اللغة الجديد.
        """
        try:
            lang_code = lang_code.lower()
            previous = self.current_lang
            if lang_code == previous:
                logger.debug(f"LanguageManager: اللغة '{lang_code}' هي نفسها اللغة الحالية؛ لا تغيير.")
                return

            # تحديث الإعدادات وحفظها
            self.current_lang = lang_code

            # إصلاح الخطأ: استخدام self.config_manager بدلاً من self.config
            if hasattr(self.config_manager, 'set'):
                self.config_manager.set("language", lang_code)
            elif hasattr(self.config_manager, 'update_config'):
                self.config_manager.update_config({"language": lang_code})
            else:
                logger.warning(f"LanguageManager: لا يمكن حفظ إعداد اللغة. ConfigManager لا يحتوي على دالة set() أو update_config().")

            logger.info(f"LanguageManager: تم تغيير اللغة من '{previous}' إلى '{lang_code}'. إعادة تحميل الترجمات.")
            self._load_translations()

        except Exception as exc:
            logger.error(f"LanguageManager: خطأ أثناء تغيير اللغة إلى '{lang_code}': {exc}", exc_info=True)
            # في حالة الخطأ، نحاول على الأقل إعادة تحميل الترجمات للغة الحالية
            self._load_translations()

    def reload(self) -> None:
        """
        إعادة تحميل الترجمات بناءً على self.current_lang الحالية.
        يمكن استدعاؤه إذا تم تعديل ملفات الترجمة يدويًا أثناء تشغيل التطبيق.
        """
        try:
            logger.debug("LanguageManager: إعادة تحميل الترجمات.")
            self._load_translations()
        except Exception as exc:
            logger.error(f"LanguageManager: خطأ أثناء إعادة تحميل الترجمات: {exc}", exc_info=True)

    def get_current_language(self) -> str:
        """
        إرجاع رمز اللغة الحالية.
        :return: رمز اللغة الحالية (مثل "ar" أو "en").
        """
        return self.current_lang

    def is_rtl(self) -> bool:
        """
        تحديد ما إذا كانت اللغة الحالية تُكتب من اليمين إلى اليسار.
        :return: True إذا كانت اللغة العربية، False للغات الأخرى.
        """
        return self.current_lang.lower() in ["ar", "arabic", "العربية"]

============================================================
FILE: core\logger.py
SIZE: 2118 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/logger.py

تُعد هذه الوحدة مسؤولةً عن تهيئة نظام التدوين (logging) في التطبيق.
تستخدم RotatingFileHandler لتقسيم ملفات السجل (log files) عند بلوغ حجم محدد.
"""

# ------------------------------------------------------------
# استيرادات المكتبات القياسية
# ------------------------------------------------------------
import logging
from logging.handlers import RotatingFileHandler
import os

# ------------------------------------------------------------
# إعداد إعدادات المسار والمجلدات
# ------------------------------------------------------------
LOG_DIR = "logs"
LOG_FILE = "app.log"
MAX_BYTES = 5 * 1024 * 1024   # 5 ميغابايت لكل ملف سجل
BACKUP_COUNT = 3              # الاحتفاظ بثلاث نسخ احتياطية

# ------------------------------------------------------------
# التأكد من وجود مجلد السجلات
# ------------------------------------------------------------
if not os.path.isdir(LOG_DIR):
    try:
        os.makedirs(LOG_DIR, exist_ok=True)
    except Exception:
        # في حال فشل إنشاء مجلد السجلات، نستخدم المجلد الحالي بدلًا منه
        LOG_DIR = "."
        # لا نعالج الخطأ هنا لأنه يحدث قبل تهيئة الـlogger بالكامل
# ------------------------------------------------------------
# تهيئة الـLogger العام
# ------------------------------------------------------------
logger = logging.getLogger("fts_sales_manager")
logger.setLevel(logging.DEBUG)  # سجل كافة المستويات بدءًا من DEBUG

# تنسيق رسائل السجل
formatter = logging.Formatter(
    "%(asctime)s [%(levelname)s] %(name)s: %(message)s",
    datefmt="%Y-%m-%d %H:%M:%S"
)

# معالجة تدوير الملفات (RotatingFileHandler)
file_path = os.path.join(LOG_DIR, LOG_FILE)
file_handler = RotatingFileHandler(
    filename=file_path,
    maxBytes=MAX_BYTES,
    backupCount=BACKUP_COUNT,
    encoding="utf-8"
)
file_handler.setLevel(logging.INFO)
file_handler.setFormatter(formatter)
logger.addHandler(file_handler)

# معالجة الطباعة على الشاشة (StreamHandler) للمرحلة التطويرية
stream_handler = logging.StreamHandler()
stream_handler.setLevel(logging.DEBUG)
stream_handler.setFormatter(formatter)
logger.addHandler(stream_handler)


============================================================
FILE: core\permissions.py
SIZE: 5411 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/permissions.py

نظام إدارة الصلاحيات للمستخدمين
يحدد ما يمكن لكل مستخدم القيام به في التطبيق
"""

from typing import List, Set
from functools import wraps
from tkinter import messagebox
from core.logger import logger


class Permission:
    """تعريف الصلاحيات المتاحة في التطبيق"""
    VIEW_ALL = "view_all"
    CREATE_SALES = "create_sales"
    EDIT_SALES = "edit_sales"
    DELETE_SALES = "delete_sales"
    MANAGE_USERS = "manage_users"
    EXPORT_DATA = "export_data"
    VIEW_REPORTS = "view_reports"
    SETTINGS = "settings"


class PermissionManager:
    """
    مدير الصلاحيات - يحدد ويتحقق من صلاحيات المستخدمين
    """

    def __init__(self):
        """تهيئة مدير الصلاحيات"""
        self.current_user_id: str = ""
        self.current_user_permissions: Set[str] = set()

    def set_current_user(self, user_id: str, permissions: List[str]) -> None:
        """
        تعيين المستخدم الحالي وصلاحياته

        :param user_id: معرف المستخدم
        :param permissions: قائمة صلاحيات المستخدم
        """
        self.current_user_id = user_id
        self.current_user_permissions = set(permissions)

        logger.info(f"تم تعيين المستخدم {user_id} بالصلاحيات: {permissions}")

    def has_permission(self, permission: str) -> bool:
        """
        التحقق من وجود صلاحية معينة للمستخدم

        :param permission: الصلاحية المطلوب التحقق منها
        :return: True إذا كان المستخدم يملك الصلاحية
        """
        return permission in self.current_user_permissions

    def check_permission(self, permission: str, show_message: bool = True) -> bool:
        """
        التحقق من الصلاحية مع إظهار رسالة في حالة الرفض

        :param permission: الصلاحية المطلوبة
        :param show_message: إظهار رسالة خطأ في حالة عدم وجود صلاحية
        :return: True إذا كان المستخدم يملك الصلاحية
        """
        if self.has_permission(permission):
            return True

        if show_message:
            permission_names = {
                Permission.VIEW_ALL: "عرض جميع السجلات",
                Permission.CREATE_SALES: "إضافة سجلات جديدة",
                Permission.EDIT_SALES: "تعديل السجلات",
                Permission.DELETE_SALES: "حذف السجلات",
                Permission.MANAGE_USERS: "إدارة المستخدمين",
                Permission.EXPORT_DATA: "تصدير البيانات",
                Permission.VIEW_REPORTS: "عرض التقارير",
                Permission.SETTINGS: "تغيير الإعدادات"
            }

            permission_name = permission_names.get(permission, permission)

            messagebox.showerror(
                "عدم وجود صلاحية",
                f"ليس لديك صلاحية: {permission_name}"
            )

        logger.warning(
            f"محاولة وصول غير مصرح: المستخدم {self.current_user_id} "
            f"حاول {permission}"
        )

        return False

    def get_user_permissions(self) -> Set[str]:
        """
        الحصول على جميع صلاحيات المستخدم الحالي

        :return: مجموعة الصلاحيات
        """
        return self.current_user_permissions.copy()

    def can_user_modify_record(self, record_owner_id: str = None) -> bool:
        """
        التحقق من إمكانية تعديل سجل

        :param record_owner_id: معرف مالك السجل (غير مستخدم حالياً)
        :return: True إذا كان يمكن التعديل
        """
        return self.has_permission(Permission.EDIT_SALES)

    def can_user_delete_record(self) -> bool:
        """
        التحقق من إمكانية حذف سجل

        :return: True إذا كان يمكن الحذف
        """
        return self.has_permission(Permission.DELETE_SALES)


# Singleton instance
permission_manager = PermissionManager()


def require_permission(permission: str):
    """
    Decorator للتحقق من الصلاحيات قبل تنفيذ دالة

    استخدام:
    @require_permission(Permission.DELETE_SALES)
    def delete_record(self):
        # كود الحذف
    """
    def decorator(func):
        @wraps(func)
        def wrapper(*args, **kwargs):
            if permission_manager.check_permission(permission):
                return func(*args, **kwargs)
            # إذا لم تكن هناك صلاحية، لا تنفذ الدالة
            return None
        return wrapper
    return decorator


# دوال مساعدة للاستخدام السريع
def can_view_all() -> bool:
    """التحقق من صلاحية عرض جميع السجلات"""
    return permission_manager.has_permission(Permission.VIEW_ALL)

def can_create() -> bool:
    """التحقق من صلاحية الإنشاء"""
    return permission_manager.has_permission(Permission.CREATE_SALES)

def can_edit() -> bool:
    """التحقق من صلاحية التعديل"""
    return permission_manager.has_permission(Permission.EDIT_SALES)

def can_delete() -> bool:
    """التحقق من صلاحية الحذف"""
    return permission_manager.has_permission(Permission.DELETE_SALES)

def can_export() -> bool:
    """التحقق من صلاحية التصدير"""
    return permission_manager.has_permission(Permission.EXPORT_DATA)

def can_manage_users() -> bool:
    """التحقق من صلاحية إدارة المستخدمين"""
    return permission_manager.has_permission(Permission.MANAGE_USERS)

def can_view_reports() -> bool:
    """التحقق من صلاحية عرض التقارير"""
    return permission_manager.has_permission(Permission.VIEW_REPORTS)

def can_change_settings() -> bool:
    """التحقق من صلاحية تغيير الإعدادات"""
    return permission_manager.has_permission(Permission.SETTINGS)

============================================================
FILE: core\session_manager.py
SIZE: 14093 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/session_manager.py

مدير الجلسات
Session Manager
"""

import secrets
import json
import os
from datetime import datetime, timedelta
from typing import Dict, Optional, List
import threading
import time

from core.logger import logger
from core.security.encryption import EncryptionManager


class SessionManager:
    """مدير جلسات المستخدمين"""

    def __init__(
        self,
        session_timeout: int = 1800,  # 30 minutes
        max_sessions_per_user: int = 5,
        enable_encryption: bool = True,
        storage_path: str = "data/sessions"
    ):
        """
        Initialize session manager

        Args:
            session_timeout: Session timeout in seconds
            max_sessions_per_user: Maximum concurrent sessions per user
            enable_encryption: Enable session data encryption
            storage_path: Path to store session data
        """
        self.session_timeout = session_timeout
        self.max_sessions_per_user = max_sessions_per_user
        self.enable_encryption = enable_encryption
        self.storage_path = storage_path

        # Storage
        self.sessions: Dict[str, dict] = {}
        self._lock = threading.RLock()

        # Encryption
        if self.enable_encryption:
            self.encryption = EncryptionManager()

        # Create storage directory
        os.makedirs(self.storage_path, exist_ok=True)

        # Load existing sessions
        self._load_sessions()

        # Start cleanup thread
        self._start_cleanup_thread()

    def create_session(
        self,
        user_info: dict,
        ip_address: Optional[str] = None,
        user_agent: Optional[str] = None
    ) -> str:
        """
        Create new session

        Args:
            user_info: User information dictionary
            ip_address: Client IP address
            user_agent: Client user agent

        Returns:
            Session ID
        """
        with self._lock:
            # Generate session ID
            session_id = secrets.token_urlsafe(32)

            # Check concurrent sessions
            username = user_info.get('username')
            if username:
                self._check_concurrent_sessions(username)

            # Create session data
            session_data = {
                'id': session_id,
                'user': user_info,
                'created_at': datetime.now().isoformat(),
                'last_activity': datetime.now().isoformat(),
                'expires_at': (datetime.now() + timedelta(seconds=self.session_timeout)).isoformat(),
                'ip_address': ip_address,
                'user_agent': user_agent,
                'active': True,
                'activity_count': 0
            }

            # Store session
            self.sessions[session_id] = session_data

            # Save to disk
            self._save_session(session_id, session_data)

            logger.info(f"Session created for user: {username} (ID: {session_id[:8]}...)")

            return session_id

    def validate_session(self, session_id: str) -> Optional[dict]:
        """
        Validate session

        Args:
            session_id: Session ID to validate

        Returns:
            Session data if valid, None otherwise
        """
        with self._lock:
            session = self.sessions.get(session_id)

            if not session:
                # Try loading from disk
                session = self._load_session(session_id)
                if session:
                    self.sessions[session_id] = session

            if not session:
                return None

            # Check if active
            if not session.get('active', False):
                logger.warning(f"Inactive session: {session_id[:8]}...")
                return None

            # Check expiration
            expires_at = datetime.fromisoformat(session['expires_at'])
            if datetime.now() > expires_at:
                logger.warning(f"Expired session: {session_id[:8]}...")
                self.invalidate_session(session_id)
                return None

            # Update last activity
            session['last_activity'] = datetime.now().isoformat()
            session['activity_count'] = session.get('activity_count', 0) + 1

            # Extend session if active
            session['expires_at'] = (datetime.now() + timedelta(seconds=self.session_timeout)).isoformat()

            # Save updated session
            self._save_session(session_id, session)

            return session

    def invalidate_session(self, session_id: str) -> bool:
        """
        Invalidate session

        Args:
            session_id: Session ID to invalidate

        Returns:
            True if successful
        """
        with self._lock:
            if session_id in self.sessions:
                session = self.sessions[session_id]
                session['active'] = False
                session['invalidated_at'] = datetime.now().isoformat()

                # Save to disk
                self._save_session(session_id, session)

                # Remove from memory
                del self.sessions[session_id]

                username = session.get('user', {}).get('username', 'Unknown')
                logger.info(f"Session invalidated for user: {username}")

                return True

            return False

    def get_user_sessions(self, username: str) -> List[dict]:
        """
        Get all sessions for a user

        Args:
            username: Username

        Returns:
            List of active sessions
        """
        with self._lock:
            user_sessions = []

            for session_id, session in self.sessions.items():
                if session.get('user', {}).get('username') == username and session.get('active'):
                    user_sessions.append({
                        'id': session_id,
                        'created_at': session['created_at'],
                        'last_activity': session['last_activity'],
                        'ip_address': session.get('ip_address'),
                        'user_agent': session.get('user_agent')
                    })

            return sorted(user_sessions, key=lambda x: x['created_at'], reverse=True)

    def invalidate_user_sessions(self, username: str, except_session: Optional[str] = None) -> int:
        """
        Invalidate all sessions for a user

        Args:
            username: Username
            except_session: Session ID to keep active

        Returns:
            Number of sessions invalidated
        """
        with self._lock:
            count = 0

            for session_id in list(self.sessions.keys()):
                session = self.sessions.get(session_id)
                if session and session.get('user', {}).get('username') == username:
                    if session_id != except_session:
                        self.invalidate_session(session_id)
                        count += 1

            logger.info(f"Invalidated {count} sessions for user: {username}")
            return count

    def extend_session(self, session_id: str, duration: Optional[int] = None) -> bool:
        """
        Extend session timeout

        Args:
            session_id: Session ID
            duration: Extension duration in seconds (default: session_timeout)

        Returns:
            True if successful
        """
        with self._lock:
            session = self.validate_session(session_id)

            if session:
                duration = duration or self.session_timeout
                session['expires_at'] = (datetime.now() + timedelta(seconds=duration)).isoformat()
                self._save_session(session_id, session)
                return True

            return False

    def get_session_info(self, session_id: str) -> Optional[dict]:
        """
        Get session information

        Args:
            session_id: Session ID

        Returns:
            Session info dictionary
        """
        session = self.validate_session(session_id)

        if session:
            return {
                'id': session_id,
                'username': session.get('user', {}).get('username'),
                'created_at': session['created_at'],
                'last_activity': session['last_activity'],
                'expires_at': session['expires_at'],
                'activity_count': session.get('activity_count', 0),
                'ip_address': session.get('ip_address'),
                'active': session.get('active', False)
            }

        return None

    def cleanup_expired_sessions(self):
        """Clean up expired sessions"""
        with self._lock:
            now = datetime.now()
            expired = []

            for session_id, session in self.sessions.items():
                expires_at = datetime.fromisoformat(session['expires_at'])
                if now > expires_at:
                    expired.append(session_id)

            for session_id in expired:
                self.invalidate_session(session_id)

            if expired:
                logger.info(f"Cleaned up {len(expired)} expired sessions")

    def _check_concurrent_sessions(self, username: str):
        """Check and limit concurrent sessions"""
        user_sessions = self.get_user_sessions(username)

        if len(user_sessions) >= self.max_sessions_per_user:
            # Remove oldest session
            oldest = user_sessions[-1]
            self.invalidate_session(oldest['id'])
            logger.warning(f"Removed oldest session for user: {username} (limit: {self.max_sessions_per_user})")

    def _save_session(self, session_id: str, session_data: dict):
        """Save session to disk"""
        try:
            filename = os.path.join(self.storage_path, f"{session_id}.json")

            # Prepare data
            data = json.dumps(session_data, ensure_ascii=False)

            # Encrypt if enabled
            if self.enable_encryption:
                data = self.encryption.encrypt_data(data)
                save_data = {"encrypted": True, "data": data}
            else:
                save_data = session_data

            # Write to file
            with open(filename, 'w', encoding='utf-8') as f:
                json.dump(save_data, f, ensure_ascii=False, indent=2)

        except Exception as e:
            logger.error(f"Error saving session: {e}")

    def _load_session(self, session_id: str) -> Optional[dict]:
        """Load session from disk"""
        try:
            filename = os.path.join(self.storage_path, f"{session_id}.json")

            if not os.path.exists(filename):
                return None

            with open(filename, 'r', encoding='utf-8') as f:
                save_data = json.load(f)

            # Decrypt if needed
            if save_data.get("encrypted") and self.enable_encryption:
                decrypted = self.encryption.decrypt_data(save_data["data"])
                session_data = json.loads(decrypted)
            else:
                session_data = save_data

            return session_data

        except Exception as e:
            logger.error(f"Error loading session: {e}")
            return None

    def _load_sessions(self):
        """Load all sessions from disk"""
        try:
            if not os.path.exists(self.storage_path):
                return

            for filename in os.listdir(self.storage_path):
                if filename.endswith('.json'):
                    session_id = filename[:-5]  # Remove .json
                    session = self._load_session(session_id)

                    if session and session.get('active'):
                        # Check if not expired
                        expires_at = datetime.fromisoformat(session['expires_at'])
                        if datetime.now() <= expires_at:
                            self.sessions[session_id] = session

        except Exception as e:
            logger.error(f"Error loading sessions: {e}")

    def _start_cleanup_thread(self):
        """Start background cleanup thread"""
        def cleanup_loop():
            while True:
                try:
                    time.sleep(300)  # Run every 5 minutes
                    self.cleanup_expired_sessions()
                except Exception as e:
                    logger.error(f"Cleanup thread error: {e}")

        thread = threading.Thread(target=cleanup_loop, daemon=True)
        thread.start()

    def get_statistics(self) -> dict:
        """
        Get session statistics

        Returns:
            Statistics dictionary
        """
        with self._lock:
            total_sessions = len(self.sessions)

            # Count by user
            users = {}
            for session in self.sessions.values():
                username = session.get('user', {}).get('username', 'Unknown')
                users[username] = users.get(username, 0) + 1

            return {
                'total_active_sessions': total_sessions,
                'unique_users': len(users),
                'sessions_per_user': users,
                'session_timeout': self.session_timeout,
                'max_sessions_per_user': self.max_sessions_per_user
            }

============================================================
FILE: core\state_manager.py
SIZE: 2557 characters
============================================================

# core/state_manager.py
from dataclasses import dataclass, field
from typing import List, Dict, Any, Optional, Callable
from datetime import datetime
import threading

@dataclass
class WindowState:
    """حالة النافذة الرئيسية"""
    all_records: List[Dict[str, Any]] = field(default_factory=list)
    filtered_records: List[Dict[str, Any]] = field(default_factory=list)
    selected_records: List[Dict[str, Any]] = field(default_factory=list)
    current_page: int = 1
    records_per_page: int = 50
    is_loading: bool = False
    last_refresh: Optional[datetime] = None
    search_query: str = ""
    sort_column: Optional[str] = None
    sort_order: str = "asc"

    def reset_selection(self):
        """مسح التحديد"""
        self.selected_records.clear()

    def update_records(self, records: List[Dict[str, Any]]):
        """تحديث السجلات"""
        self.all_records = records
        self.filtered_records = records
        self.last_refresh = datetime.now()

    def get_selected_count(self) -> int:
        """عدد السجلات المحددة"""
        return len(self.selected_records)

class StateManager:
    """مدير الحالة المركزي"""

    def __init__(self):
        self._states: Dict[str, Any] = {}
        self._lock = threading.Lock()
        self._observers: Dict[str, List[Callable]] = {}

    def register_state(self, name: str, state: Any):
        """تسجيل حالة جديدة"""
        with self._lock:
            self._states[name] = state

    def get_state(self, name: str) -> Any:
        """الحصول على حالة"""
        with self._lock:
            return self._states.get(name)

    def update_state(self, name: str, updates: Dict[str, Any]):
        """تحديث حالة"""
        with self._lock:
            state = self._states.get(name)
            if state:
                for key, value in updates.items():
                    if hasattr(state, key):
                        setattr(state, key, value)
                self._notify_observers(name, state)

    def subscribe(self, state_name: str, callback: Callable):
        """الاشتراك في تغييرات الحالة"""
        if state_name not in self._observers:
            self._observers[state_name] = []
        self._observers[state_name].append(callback)

    def _notify_observers(self, state_name: str, state: Any):
        """إشعار المراقبين بالتغييرات"""
        for callback in self._observers.get(state_name, []):
            try:
                callback(state)
            except Exception as e:
                print(f"Error notifying observer: {e}")

============================================================
FILE: core\theme_color_manager.py
SIZE: 14000 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/theme_color_manager.py

نظام ثيم موحد لجميع النوافذ
يجمع بين المرونة والموثوقية والألوان المتقدمة
مع دعم محسن للحقول المحمية (readonly fields)
"""

import customtkinter as ctk
from typing import Dict, Optional, Any
from core.logger import logger

class ThemeColorManager:
    """مدير ألوان الثيم الموحد"""

    def __init__(self, theme_manager=None):
        self.theme_manager = theme_manager
        self._color_cache = {}
        self._load_color_palettes()

    def _load_color_palettes(self):
        """تحميل لوحات الألوان"""
        try:
            from config.modern_color_palettes import get_color_palette, get_available_palettes
            self._has_palettes = True
            self._get_color_palette = get_color_palette
            self._get_available_palettes = get_available_palettes
        except ImportError:
            self._has_palettes = False
            logger.debug("Modern color palettes not available")

    def get_current_colors(self) -> Dict[str, str]:
        """الحصول على لوحة الألوان الحالية"""
        mode = self._get_appearance_mode()
        palette_key = self._get_current_palette_key(mode)

        if self._has_palettes:
            try:
                return self._get_color_palette(palette_key)
            except Exception as e:
                logger.warning(f"Error loading palette {palette_key}: {e}")

        return self._get_default_colors(mode)

    def _get_appearance_mode(self) -> str:
        """الحصول على وضع المظهر الحالي"""
        if self.theme_manager:
            try:
                if hasattr(self.theme_manager, 'get_current_appearance_mode'):
                    return self.theme_manager.get_current_appearance_mode()
                elif hasattr(self.theme_manager, 'current_mode'):
                    return self.theme_manager.current_mode
            except:
                pass

        # الحصول من customtkinter مباشرة
        try:
            return ctk.get_appearance_mode().lower()
        except:
            return "light"

    def _get_current_palette_key(self, mode: str) -> str:
        """الحصول على مفتاح لوحة الألوان الحالية"""
        if mode == "dark":
            return "modern_dark"

        # للوضع الفاتح، محاولة الحصول على التفضيل المحفوظ
        if self.theme_manager and hasattr(self.theme_manager, 'config'):
            try:
                return self.theme_manager.config.get('light_color_palette', 'modern_purple')
            except:
                pass

        return "modern_purple"

    def _get_default_colors(self, mode: str) -> Dict[str, str]:
        """الحصول على الألوان الافتراضية"""
        if mode == "dark":
            return {
                'primary': '#5B5FFF',
                'primary_hover': '#4B4FEF',
                'secondary': '#6B7280',
                'success': '#10B981',
                'danger': '#F43F5E',
                'danger_hover': '#E11D48',
                'warning': '#F59E0B',
                'background': '#1a1a1a',
                'surface': '#2b2b2b',
                'input_bg': '#374151',
                'input_border': '#4B5563',
                'input_focus': '#5B5FFF',
                'border': '#374151',
                'text_primary': '#F9FAFB',
                'text_secondary': '#D1D5DB',
                'shadow': 'rgba(0, 0, 0, 0.25)',
                # ألوان الحقول المحمية
                'readonly_bg': '#1f2937',
                'readonly_border': '#374151',
                'readonly_text': '#9CA3AF'
            }
        else:
            return {
                'primary': '#5B5FFF',
                'primary_hover': '#4B4FEF',
                'secondary': '#6B7280',
                'success': '#10B981',
                'danger': '#F43F5E',
                'danger_hover': '#E11D48',
                'warning': '#F59E0B',
                'background': '#F9FAFB',
                'surface': '#FFFFFF',
                'input_bg': '#F3F4F6',
                'input_border': '#D1D5DB',
                'input_focus': '#5B5FFF',
                'border': '#E5E7EB',
                'text_primary': '#111827',
                'text_secondary': '#6B7280',
                'shadow': 'rgba(0, 0, 0, 0.05)',
                # ألوان الحقول المحمية
                'readonly_bg': '#F3F4F6',
                'readonly_border': '#D1D5DB',
                'readonly_text': '#9CA3AF'
            }

    def get_color(self, color_name: str, fallback: str = None) -> str:
        """الحصول على لون محدد بطريقة آمنة"""
        # التحقق من الكاش أولاً
        cache_key = f"{self._get_appearance_mode()}_{color_name}"
        if cache_key in self._color_cache:
            return self._color_cache[cache_key]

        colors = self.get_current_colors()
        color = colors.get(color_name)

        if not color and fallback:
            color = fallback
        elif not color:
            # ألوان احتياطية أساسية
            backup_colors = {
                'primary': '#1f538d',
                'background': 'gray14' if self._get_appearance_mode() == 'dark' else 'white',
                'surface': 'gray16' if self._get_appearance_mode() == 'dark' else '#f8f9fa',
                'text_primary': 'white' if self._get_appearance_mode() == 'dark' else 'black',
                'text_secondary': 'gray',
                'success': '#4caf50',
                'danger': '#f44336',
                'warning': '#ff9800',
                'readonly_bg': '#f5f5f5' if self._get_appearance_mode() == 'light' else '#2a2a2a',
                'readonly_border': '#cccccc' if self._get_appearance_mode() == 'light' else '#444444',
                'readonly_text': '#666666' if self._get_appearance_mode() == 'light' else '#999999'
            }
            color = backup_colors.get(color_name, '#1f538d')

        # حفظ في الكاش
        self._color_cache[cache_key] = color
        return color

    def apply_to_window(self, window):
        """تطبيق الثيم على النافذة"""
        try:
            bg_color = self.get_color('background')
            window.configure(fg_color=bg_color)
        except Exception as e:
            logger.debug(f"Error applying theme to window: {e}")

    def apply_to_frame(self, frame, frame_type='default'):
        """تطبيق الثيم على إطار"""
        try:
            colors = {
                'default': self.get_color('surface'),
                'transparent': 'transparent',
                'header': self.get_color('surface'),
                'sidebar': self.get_color('input_bg'),
                'content': self.get_color('background')
            }

            fg_color = colors.get(frame_type, self.get_color('surface'))
            frame.configure(fg_color=fg_color)
        except Exception as e:
            logger.debug(f"Error applying theme to frame: {e}")

    def apply_to_button(self, button, button_type='primary'):
        """تطبيق الثيم على زر"""
        try:
            configs = {
                'primary': {
                    'fg_color': self.get_color('primary'),
                    'hover_color': self.get_color('primary_hover'),
                    'text_color': 'white'
                },
                'secondary': {
                    'fg_color': self.get_color('input_bg'),
                    'hover_color': self.get_color('border'),
                    'text_color': self.get_color('text_primary'),
                    'border_width': 1,
                    'border_color': self.get_color('input_border')
                },
                'success': {
                    'fg_color': self.get_color('success'),
                    'hover_color': self.get_color('success'),
                    'text_color': 'white'
                },
                'danger': {
                    'fg_color': self.get_color('danger'),
                    'hover_color': self.get_color('danger_hover'),
                    'text_color': 'white'
                },
                'warning': {
                    'fg_color': self.get_color('warning'),
                    'hover_color': self.get_color('warning'),
                    'text_color': 'white'
                }
            }

            config = configs.get(button_type, configs['primary'])
            button.configure(**config)
        except Exception as e:
            logger.debug(f"Error applying theme to button: {e}")

    def apply_to_entry(self, entry, entry_type='normal'):
        """تطبيق الثيم على حقل إدخال"""
        try:
            if entry_type == 'readonly':
                # ألوان خاصة للحقول المحمية
                entry.configure(
                    fg_color=self.get_color('readonly_bg'),
                    border_color=self.get_color('readonly_border'),
                    text_color=self.get_color('readonly_text')
                )
            else:
                # ألوان عادية للحقول القابلة للتحرير
                entry.configure(
                    fg_color=self.get_color('input_bg'),
                    border_color=self.get_color('input_border'),
                    text_color=self.get_color('text_primary')
                )
        except Exception as e:
            logger.debug(f"Error applying theme to entry: {e}")

    def apply_to_combobox(self, combobox):
        """تطبيق الثيم على قائمة منسدلة"""
        try:
            combobox.configure(
                fg_color=self.get_color('input_bg'),
                button_color=self.get_color('primary'),
                button_hover_color=self.get_color('primary_hover'),
                dropdown_fg_color=self.get_color('surface'),
                dropdown_text_color=self.get_color('text_primary'),
                text_color=self.get_color('text_primary')
            )
        except Exception as e:
            logger.debug(f"Error applying theme to combobox: {e}")

    def apply_to_label(self, label, label_type='primary'):
        """تطبيق الثيم على تسمية"""
        try:
            colors = {
                'primary': self.get_color('text_primary'),
                'secondary': self.get_color('text_secondary'),
                'success': self.get_color('success'),
                'danger': self.get_color('danger'),
                'warning': self.get_color('warning'),
                'readonly': self.get_color('readonly_text')  # ← إضافة لون خاص للتسميات المحمية
            }

            text_color = colors.get(label_type, self.get_color('text_primary'))
            label.configure(text_color=text_color)
        except Exception as e:
            logger.debug(f"Error applying theme to label: {e}")

    def get_readonly_colors(self) -> Dict[str, str]:
        """الحصول على ألوان الحقول المحمية"""
        return {
            'bg_color': self.get_color('readonly_bg'),
            'border_color': self.get_color('readonly_border'),
            'text_color': self.get_color('readonly_text')
        }

    def get_themed_colors_tuple(self, color_name: str) -> tuple:
        """الحصول على tuple للألوان (light, dark)"""
        # للتوافق مع الكود الموجود
        light_colors = self._get_default_colors('light')
        dark_colors = self._get_default_colors('dark')

        light_color = light_colors.get(color_name, '#ffffff')
        dark_color = dark_colors.get(color_name, '#1a1a1a')

        return (light_color, dark_color)

    def invalidate_cache(self):
        """إزالة الكاش عند تغيير الثيم"""
        self._color_cache.clear()

    def get_available_palettes(self) -> list:
        """الحصول على قائمة اللوحات المتاحة"""
        if self._has_palettes:
            try:
                all_palettes = self._get_available_palettes()
                return [p for p in all_palettes if p != 'modern_dark']
            except:
                pass
        return ['modern_purple', 'modern_blue', 'modern_emerald']

    def set_palette(self, palette_name: str):
        """تعيين لوحة ألوان جديدة"""
        if self.theme_manager and hasattr(self.theme_manager, 'config'):
            try:
                self.theme_manager.config.set('light_color_palette', palette_name)
                if hasattr(self.theme_manager.config, 'save'):
                    self.theme_manager.config.save()
                self.invalidate_cache()
                logger.info(f"Color palette changed to: {palette_name}")
            except Exception as e:
                logger.error(f"Error setting palette: {e}")


# كلاس مساعد للنوافذ
class ThemedWindow:
    """كلاس مساعد لتطبيق الثيم على النوافذ"""

    def __init__(self, window, theme_manager=None):
        self.window = window
        self.color_manager = ThemeColorManager(theme_manager)

    def apply_theme(self):
        """تطبيق الثيم الكامل على النافذة"""
        self.color_manager.apply_to_window(self.window)

    def get_color(self, color_name: str, fallback: str = None) -> str:
        """الحصول على لون"""
        return self.color_manager.get_color(color_name, fallback)

    def apply_to_widget(self, widget, widget_type: str, sub_type: str = 'normal'):
        """تطبيق الثيم على widget محدد"""
        if widget_type == 'button':
            self.color_manager.apply_to_button(widget, sub_type)
        elif widget_type == 'entry':
            self.color_manager.apply_to_entry(widget, sub_type)
        elif widget_type == 'combobox':
            self.color_manager.apply_to_combobox(widget)
        elif widget_type == 'label':
            self.color_manager.apply_to_label(widget, sub_type)
        elif widget_type == 'frame':
            self.color_manager.apply_to_frame(widget, sub_type)

    def get_readonly_colors(self) -> Dict[str, str]:
        """الحصول على ألوان الحقول المحمية"""
        return self.color_manager.get_readonly_colors()

    def refresh_theme(self):
        """تحديث الثيم"""
        self.color_manager.invalidate_cache()
        self.apply_theme()

============================================================
FILE: core\theme_manager.py
SIZE: 25669 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/theme_manager.py

تدير هذه الفئة إعداد وتطبيق الثيمات (Themes) في واجهة المستخدم باستخدام مكتبة CustomTkinter.
تعتمد على إعدادات ConfigManager لقراءة ثيم الواجهة (فاتح/داكن) والثيم اللوني (Color Theme).
يمكن تغيير الثيم أثناء تشغيل التطبيق دون الحاجة لإعادة التشغيل.

🔵 التحديث الجديد: دعم الألوان الزرقاء للقوائم المنسدلة
"""

# ------------------------------------------------------------
# استيرادات المكتبات القياسية
# ------------------------------------------------------------
from typing import Optional, Dict, Any, Union
import json
import os

# ------------------------------------------------------------
# استيرادات المكتبات الخارجية
# ------------------------------------------------------------
import customtkinter as ctk
import tkinter as tk

# ------------------------------------------------------------
# استيرادات وحدات المشروع
# ------------------------------------------------------------
from core.config_manager import ConfigManager
from core.logger import logger


class ThemeManager:
    """
    فئة ThemeManager مسؤولة عن:
    - قراءة إعدادات الثيم من ConfigManager.
    - تطبيق ثيم الواجهة (Appearance Mode) وثيم الألوان (Color Theme) على CustomTkinter.
    - تغيير الثيم ديناميكيًا وحفظ الإعدادات.
    - دعم ثيمات مخصصة مثل Windows 7
    - 🔵 دعم الألوان الزرقاء للقوائم المنسدلة
    """

    def __init__(self, config_manager: ConfigManager) -> None:
        """
        تهيئة ThemeManager.
        """
        self.config: ConfigManager = config_manager

        # تعريف الثيمات المخصصة
        self.custom_themes = {
            "windows7_aero": self._get_windows7_aero_colors(),
            "windows7_classic": self._get_windows7_classic_colors(),
            "windows7_basic": self._get_windows7_basic_colors()
        }

        # قائمة الثيمات المدمجة - إزالة dark-blue
        self.builtin_themes = ["blue", "green"]  # ⚠️ أزلنا "dark-blue"

        # قراءة الإعدادات
        self.current_mode: str = self.config.get("appearance_mode", "light")

        # التحقق من الثيم وتصحيحه إذا كان dark-blue
        saved_theme = self.config.get("color_theme", "blue")
        if saved_theme == "dark-blue":
            logger.warning("تم اكتشاف dark-blue theme - سيتم التغيير إلى blue")
            saved_theme = "blue"
            self.config.set("color_theme", "blue")

        self.current_color_theme: str = saved_theme

        # تطبيق appearance mode فقط
        self.apply_appearance_mode(self.current_mode)

        # لا تطبق color theme هنا - سيتم تطبيقه في app_controller

    def apply_blue_theme_to_enhanced_combo(self, combo_widget):
        """🔵 تطبيق الثيم الأزرق على القائمة المحسنة"""
        try:
            if hasattr(combo_widget, 'apply_blue_theme'):
                combo_widget.apply_blue_theme(self)
                logger.info("✅ تم تطبيق الثيم الأزرق على القائمة المحسنة")
            elif hasattr(combo_widget, '_get_blue_colors'):
                # إجبار تحديث الألوان
                combo_widget.theme_manager = self
                if hasattr(combo_widget, '_populate_dropdown_simple'):
                    combo_widget._populate_dropdown_simple()
            else:
                logger.warning("⚠️ القائمة لا تدعم الثيم الأزرق")
        except Exception as e:
            logger.error(f"❌ خطأ في تطبيق الثيم الأزرق: {e}")

    def _get_windows7_aero_colors(self) -> Dict[str, Any]:
        """
        ألوان ثيم Windows 7 Aero مع دعم الألوان الزرقاء للقوائم المنسدلة
        """
        return {
            "window_bg": {"light": "#F0F0F0", "dark": "#1E1E1E"},
            "frame_bg": {"light": "#FFFFFF", "dark": "#2D2D30"},
            "button_bg": {"light": "#E1E1E1", "dark": "#3F3F46"},
            "button_hover": {"light": "#B9D7F1", "dark": "#4B7BB1"},
            "button_pressed": {"light": "#7DA2CE", "dark": "#2C5282"},
            "button_text": {"light": "#000000", "dark": "#FFFFFF"},
            "entry_bg": {"light": "#FFFFFF", "dark": "#383838"},
            "entry_border": {"light": "#7DA2CE", "dark": "#555555"},
            "entry_border_focus": {"light": "#569DE5", "dark": "#0078D7"},
            "text_color": {"light": "#000000", "dark": "#E0E0E0"},
            "label_color": {"light": "#000000", "dark": "#CCCCCC"},
            "disabled_color": {"light": "#8B8B8B", "dark": "#6B6B6B"},
            "selection_bg": {"light": "#0078D7", "dark": "#0078D7"},
            "selection_text": {"light": "#FFFFFF", "dark": "#FFFFFF"},
            "scrollbar_bg": {"light": "#F0F0F0", "dark": "#2D2D30"},
            "scrollbar_thumb": {"light": "#CDCDCD", "dark": "#686868"},
            "scrollbar_thumb_hover": {"light": "#A6A6A6", "dark": "#9E9E9E"},
            "menu_bg": {"light": "#F0F0F0", "dark": "#2D2D30"},
            "menu_hover": {"light": "#E3F2FD", "dark": "#094771"},
            # 🔵 ألوان جديدة للقوائم المنسدلة الزرقاء
            "dropdown_hover": {"light": "#E6F3FF", "dark": "#1E90FF"},
            "dropdown_text_hover": {"light": "#000080", "dark": "#FFFFFF"},
            "dropdown_select": {"light": "#ADD8E6", "dark": "#000080"},
            "dropdown_border": {"light": "#0000FF", "dark": "#ADD8E6"},
            "tooltip_bg": {"light": "#FFFFCC", "dark": "#4B4B4B"},
            "tooltip_text": {"light": "#000000", "dark": "#FFFFFF"},
            "progress_bg": {"light": "#E6E6E6", "dark": "#2D2D30"},
            "progress_fill": {"light": "#06B025", "dark": "#06B025"},
            "tab_active": {"light": "#FFFFFF", "dark": "#3F3F46"},
            "tab_inactive": {"light": "#E8E8E8", "dark": "#2D2D30"},
            "border_color": {"light": "#ADADAD", "dark": "#555555"},
            "shadow_color": {"light": "#B0B0B0", "dark": "#000000"}
        }

    def _get_windows7_classic_colors(self) -> Dict[str, Any]:
        """
        ألوان ثيم Windows 7 Classic (بدون شفافية) مع دعم الألوان الزرقاء
        """
        return {
            "window_bg": {"light": "#D4D0C8", "dark": "#3C3C3C"},
            "frame_bg": {"light": "#ECE9D8", "dark": "#404040"},
            "button_bg": {"light": "#D4D0C8", "dark": "#404040"},
            "button_hover": {"light": "#E0DDD7", "dark": "#4A4A4A"},
            "button_pressed": {"light": "#C4C0B8", "dark": "#353535"},
            "button_text": {"light": "#000000", "dark": "#E0E0E0"},
            "entry_bg": {"light": "#FFFFFF", "dark": "#525252"},
            "entry_border": {"light": "#404040", "dark": "#6B6B6B"},
            "entry_border_focus": {"light": "#0054E3", "dark": "#0078D7"},
            "text_color": {"light": "#000000", "dark": "#E0E0E0"},
            "label_color": {"light": "#000000", "dark": "#D0D0D0"},
            "disabled_color": {"light": "#808080", "dark": "#808080"},
            "selection_bg": {"light": "#316AC5", "dark": "#316AC5"},
            "selection_text": {"light": "#FFFFFF", "dark": "#FFFFFF"},
            "scrollbar_bg": {"light": "#D4D0C8", "dark": "#404040"},
            "scrollbar_thumb": {"light": "#A0A0A0", "dark": "#606060"},
            "scrollbar_thumb_hover": {"light": "#808080", "dark": "#808080"},
            "menu_bg": {"light": "#F0F0F0", "dark": "#404040"},
            "menu_hover": {"light": "#316AC5", "dark": "#316AC5"},
            # 🔵 ألوان زرقاء للقوائم المنسدلة
            "dropdown_hover": {"light": "#CCE7FF", "dark": "#4169E1"},
            "dropdown_text_hover": {"light": "#000080", "dark": "#FFFFFF"},
            "dropdown_select": {"light": "#87CEEB", "dark": "#191970"},
            "dropdown_border": {"light": "#0000CD", "dark": "#87CEEB"},
            "tooltip_bg": {"light": "#FFFFE1", "dark": "#4B4B4B"},
            "tooltip_text": {"light": "#000000", "dark": "#FFFFFF"},
            "progress_bg": {"light": "#E0E0E0", "dark": "#404040"},
            "progress_fill": {"light": "#316AC5", "dark": "#316AC5"},
            "tab_active": {"light": "#ECE9D8", "dark": "#525252"},
            "tab_inactive": {"light": "#D4D0C8", "dark": "#404040"},
            "border_color": {"light": "#808080", "dark": "#6B6B6B"},
            "shadow_color": {"light": "#808080", "dark": "#000000"}
        }

    def _get_windows7_basic_colors(self) -> Dict[str, Any]:
        """
        ألوان ثيم Windows 7 Basic (بدون تأثيرات Aero) مع دعم الألوان الزرقاء
        """
        return {
            "window_bg": {"light": "#E8E8E8", "dark": "#2B2B2B"},
            "frame_bg": {"light": "#F5F5F5", "dark": "#363636"},
            "button_bg": {"light": "#DDDDDD", "dark": "#484848"},
            "button_hover": {"light": "#C8E6F5", "dark": "#5A7FA6"},
            "button_pressed": {"light": "#9ECDE7", "dark": "#405F7E"},
            "button_text": {"light": "#000000", "dark": "#FFFFFF"},
            "entry_bg": {"light": "#FFFFFF", "dark": "#404040"},
            "entry_border": {"light": "#999999", "dark": "#5C5C5C"},
            "entry_border_focus": {"light": "#3399FF", "dark": "#0078D7"},
            "text_color": {"light": "#000000", "dark": "#E0E0E0"},
            "label_color": {"light": "#000000", "dark": "#D4D4D4"},
            "disabled_color": {"light": "#999999", "dark": "#7A7A7A"},
            "selection_bg": {"light": "#3399FF", "dark": "#3399FF"},
            "selection_text": {"light": "#FFFFFF", "dark": "#FFFFFF"},
            "scrollbar_bg": {"light": "#E8E8E8", "dark": "#363636"},
            "scrollbar_thumb": {"light": "#B8B8B8", "dark": "#5C5C5C"},
            "scrollbar_thumb_hover": {"light": "#999999", "dark": "#7A7A7A"},
            "menu_bg": {"light": "#F5F5F5", "dark": "#363636"},
            "menu_hover": {"light": "#D8E9F5", "dark": "#4B6983"},
            # 🔵 ألوان زرقاء للقوائم المنسدلة
            "dropdown_hover": {"light": "#E6F7FF", "dark": "#1E90FF"},
            "dropdown_text_hover": {"light": "#003366", "dark": "#FFFFFF"},
            "dropdown_select": {"light": "#B3D9FF", "dark": "#0066CC"},
            "dropdown_border": {"light": "#0066FF", "dark": "#B3D9FF"},
            "tooltip_bg": {"light": "#FFFFC8", "dark": "#525252"},
            "tooltip_text": {"light": "#000000", "dark": "#FFFFFF"},
            "progress_bg": {"light": "#E0E0E0", "dark": "#363636"},
            "progress_fill": {"light": "#3399FF", "dark": "#3399FF"},
            "tab_active": {"light": "#F5F5F5", "dark": "#484848"},
            "tab_inactive": {"light": "#DDDDDD", "dark": "#363636"},
            "border_color": {"light": "#B5B5B5", "dark": "#5C5C5C"},
            "shadow_color": {"light": "#C0C0C0", "dark": "#000000"}
        }

    def get_theme_colors(self, theme_name: str = None) -> Dict[str, str]:
        """
        الحصول على ألوان الثيم الحالي أو ثيم محدد
        """
        if theme_name is None:
            theme_name = self.current_color_theme

        if theme_name in self.custom_themes:
            colors = self.custom_themes[theme_name]
            mode = self.current_mode if self.current_mode in ["light", "dark"] else "light"
            # إرجاع الألوان للوضع الحالي فقط
            return {key: value[mode] for key, value in colors.items()}

        # للثيمات المدمجة، إرجاع ألوان افتراضية مع الألوان الزرقاء
        return self._get_default_colors()

    def _get_default_colors(self) -> Dict[str, str]:
        """
        الحصول على الألوان الافتراضية للثيمات المدمجة مع دعم الألوان الزرقاء
        """
        if self.current_mode == "dark":
            return {
                "window_bg": "#212121",
                "frame_bg": "#2B2B2B",
                "button_bg": "#3F7CAC",
                "button_hover": "#5294C7",
                "text_color": "#E0E0E0",
                "entry_bg": "#3A3A3A",
                "entry_border": "#565B5E",
                # 🔵 ألوان زرقاء افتراضية للوضع الليلي
                "dropdown_hover": "#1E90FF",
                "dropdown_text_hover": "#FFFFFF",
                "dropdown_select": "#000080",
                "dropdown_border": "#ADD8E6"
            }
        else:
            return {
                "window_bg": "#F0F0F0",
                "frame_bg": "#FFFFFF",
                "button_bg": "#1F538D",
                "button_hover": "#2A5F9E",
                "text_color": "#000000",
                "entry_bg": "#FFFFFF",
                "entry_border": "#CCCCCC",
                # 🔵 ألوان زرقاء افتراضية للوضع النهاري
                "dropdown_hover": "#E6F3FF",
                "dropdown_text_hover": "#000080",
                "dropdown_select": "#ADD8E6",
                "dropdown_border": "#0000FF"
            }

    def get_dropdown_hover_color(self) -> str:
        """الحصول على لون التمرير للقوائم المنسدلة - أزرق فاتح"""
        colors = self.get_theme_colors()
        return colors.get("dropdown_hover", "#E6F3FF" if self.current_mode == "light" else "#1E90FF")

    def get_dropdown_text_hover_color(self) -> str:
        """الحصول على لون النص للقوائم المنسدلة عند التمرير"""
        colors = self.get_theme_colors()
        return colors.get("dropdown_text_hover", "#000080" if self.current_mode == "light" else "#FFFFFF")

    def get_dropdown_select_color(self) -> str:
        """الحصول على لون اختيار القوائم المنسدلة بلوحة المفاتيح"""
        colors = self.get_theme_colors()
        return colors.get("dropdown_select", "#ADD8E6" if self.current_mode == "light" else "#000080")

    def get_dropdown_border_color(self) -> str:
        """الحصول على لون حدود القوائم المنسدلة"""
        colors = self.get_theme_colors()
        return colors.get("dropdown_border", "#0000FF" if self.current_mode == "light" else "#ADD8E6")

    def apply_appearance_mode(self, mode: str) -> None:
        """
        تطبيق ثيم الواجهة (Appearance Mode) على CustomTkinter.
        """
        mode = mode.lower()
        if mode not in ("light", "dark", "system"):
            logger.warning(f"ThemeManager: قيمة غير صالحة للـ appearance_mode: '{mode}'. سيتم استخدام 'light'.")
            mode = "light"

        try:
            ctk.set_appearance_mode(mode)
            self.current_mode = mode
            self.config.set("appearance_mode", mode)
            logger.info(f"ThemeManager: تم تطبيق Appearance Mode='{mode}'.")
        except Exception as exc:
            logger.error(f"ThemeManager: خطأ أثناء تطبيق Appearance Mode='{mode}': {exc}", exc_info=True)

    def apply_color_theme(self, color_theme: str) -> None:
        """
        تطبيق ثيم الألوان على CustomTkinter.
        """
        color_theme = color_theme.lower()

        # إذا كان ثيم مخصص
        if color_theme in self.custom_themes:
            # حفظ الثيم فقط دون تطبيقه على CTk
            self.current_color_theme = color_theme
            self.config.set("color_theme", color_theme)
            logger.info(f"ThemeManager: تم اختيار الثيم المخصص '{color_theme}'.")

        # إذا كان ثيم مدمج
        elif color_theme in self.builtin_themes:
            try:
                # ⚠️ لا تستدعي set_default_color_theme هنا!
                # فقط احفظ الإعداد
                self.current_color_theme = color_theme
                self.config.set("color_theme", color_theme)
                logger.info(f"ThemeManager: تم اختيار Color Theme='{color_theme}'.")

                # إظهار تحذير للمستخدم
                logger.warning("تغيير الثيم يتطلب إعادة تشغيل التطبيق ليتم تطبيقه بالكامل")

            except Exception as exc:
                logger.error(f"ThemeManager: خطأ في حفظ Color Theme='{color_theme}': {exc}")
        else:
            logger.warning(f"ThemeManager: ثيم غير معروف '{color_theme}'.")

    def apply_widget_theme(self, widget: Union[tk.Widget, ctk.CTkBaseClass]) -> None:
        """
        تطبيق ألوان الثيم على عنصر واجهة محدد مع دعم الألوان الزرقاء للقوائم المنسدلة
        """
        if self.current_color_theme not in self.custom_themes:
            return

        colors = self.get_theme_colors()

        try:
            # تطبيق الألوان حسب نوع العنصر
            if isinstance(widget, ctk.CTkButton):
                widget.configure(
                    fg_color=colors.get("button_bg"),
                    hover_color=colors.get("button_hover"),
                    text_color=colors.get("button_text"),
                    corner_radius=4,
                    border_width=1,
                    border_color=colors.get("border_color")
                )

            elif isinstance(widget, ctk.CTkEntry):
                widget.configure(
                    fg_color=colors.get("entry_bg"),
                    border_color=colors.get("entry_border"),
                    text_color=colors.get("text_color"),
                    corner_radius=2,
                    border_width=1
                )

            elif isinstance(widget, ctk.CTkFrame):
                widget.configure(
                    fg_color=colors.get("frame_bg"),
                    corner_radius=6,
                    border_width=1,
                    border_color=colors.get("border_color")
                )

            elif isinstance(widget, ctk.CTkLabel):
                widget.configure(
                    text_color=colors.get("label_color")
                )

            elif isinstance(widget, ctk.CTkTextbox):
                widget.configure(
                    fg_color=colors.get("entry_bg"),
                    border_color=colors.get("entry_border"),
                    text_color=colors.get("text_color"),
                    corner_radius=2,
                    border_width=1,
                    scrollbar_button_color=colors.get("scrollbar_thumb"),
                    scrollbar_button_hover_color=colors.get("scrollbar_thumb_hover")
                )

            elif isinstance(widget, ctk.CTkProgressBar):
                widget.configure(
                    fg_color=colors.get("progress_bg"),
                    progress_color=colors.get("progress_fill"),
                    corner_radius=2,
                    border_width=1,
                    border_color=colors.get("border_color")
                )

            elif isinstance(widget, ctk.CTkCheckBox):
                widget.configure(
                    fg_color=colors.get("selection_bg"),
                    hover_color=colors.get("button_hover"),
                    text_color=colors.get("text_color"),
                    border_color=colors.get("entry_border"),
                    checkmark_color=colors.get("selection_text"),
                    corner_radius=2,
                    border_width=1
                )

            elif isinstance(widget, ctk.CTkSwitch):
                widget.configure(
                    fg_color=colors.get("scrollbar_bg"),
                    progress_color=colors.get("selection_bg"),
                    button_color=colors.get("button_bg"),
                    button_hover_color=colors.get("button_hover"),
                    text_color=colors.get("text_color")
                )

            elif isinstance(widget, ctk.CTkOptionMenu):
                widget.configure(
                    fg_color=colors.get("entry_bg"),
                    button_color=colors.get("button_bg"),
                    button_hover_color=colors.get("button_hover"),
                    text_color=colors.get("text_color"),
                    dropdown_fg_color=colors.get("menu_bg"),
                    dropdown_hover_color=self.get_dropdown_hover_color(),  # 🔵 استخدام اللون الأزرق
                    dropdown_text_color=self.get_dropdown_text_hover_color(),  # 🔵 نص أزرق
                    corner_radius=2
                )

            elif isinstance(widget, ctk.CTkComboBox):
                widget.configure(
                    fg_color=colors.get("entry_bg"),
                    border_color=colors.get("entry_border"),
                    button_color=colors.get("button_bg"),
                    button_hover_color=colors.get("button_hover"),
                    text_color=colors.get("text_color"),
                    dropdown_fg_color=colors.get("menu_bg"),
                    dropdown_hover_color=self.get_dropdown_hover_color(),  # 🔵 استخدام اللون الأزرق
                    dropdown_text_color=self.get_dropdown_text_hover_color(),  # 🔵 نص أزرق
                    corner_radius=2,
                    border_width=1
                )

            elif isinstance(widget, ctk.CTkTabview):
                widget.configure(
                    fg_color=colors.get("frame_bg"),
                    segmented_button_fg_color=colors.get("window_bg"),
                    segmented_button_selected_color=colors.get("tab_active"),
                    segmented_button_selected_hover_color=colors.get("button_hover"),
                    segmented_button_unselected_color=colors.get("tab_inactive"),
                    segmented_button_unselected_hover_color=colors.get("scrollbar_thumb_hover"),
                    text_color=colors.get("text_color"),
                    corner_radius=6
                )

            elif isinstance(widget, ctk.CTkScrollbar):
                widget.configure(
                    fg_color=colors.get("scrollbar_bg"),
                    button_color=colors.get("scrollbar_thumb"),
                    button_hover_color=colors.get("scrollbar_thumb_hover")
                )

            # للعناصر العادية من tkinter
            elif hasattr(widget, 'configure'):
                try:
                    widget.configure(bg=colors.get("window_bg"))
                    if hasattr(widget, 'fg'):
                        widget.configure(fg=colors.get("text_color"))
                except:
                    pass

        except Exception as e:
            logger.debug(f"تعذر تطبيق الثيم على {type(widget).__name__}: {e}")

    def apply_blue_dropdown_theme(self, widget) -> None:
        """
        🔵 تطبيق الثيم الأزرق خصيصاً للقوائم المنسدلة المحسنة
        """
        try:
            if hasattr(widget, '_apply_blue_hover_colors'):
                # للقوائم المحسنة التي تدعم الألوان الزرقاء
                widget._apply_blue_hover_colors(
                    hover_color=self.get_dropdown_hover_color(),
                    text_color=self.get_dropdown_text_hover_color(),
                    select_color=self.get_dropdown_select_color(),
                    border_color=self.get_dropdown_border_color()
                )
                logger.debug(f"تم تطبيق الثيم الأزرق على القائمة المحسنة")
            elif hasattr(widget, 'configure'):
                # للقوائم العادية
                widget.configure(
                    dropdown_hover_color=self.get_dropdown_hover_color(),
                    dropdown_text_color=self.get_dropdown_text_hover_color()
                )
                logger.debug(f"تم تطبيق الثيم الأزرق على القائمة العادية")
        except Exception as e:
            logger.debug(f"فشل في تطبيق الثيم الأزرق: {e}")

    def apply_to_all_widgets(self, parent_widget) -> None:
        """
        تطبيق الثيم على جميع العناصر في النافذة مع دعم خاص للألوان الزرقاء
        """
        def apply_recursively(widget):
            self.apply_widget_theme(widget)

            # تطبيق خاص للقوائم المنسدلة المحسنة
            if hasattr(widget, '_apply_blue_hover_colors'):
                self.apply_blue_dropdown_theme(widget)

            for child in widget.winfo_children():
                apply_recursively(child)

        apply_recursively(parent_widget)

    def get_error_color(self) -> str:
        """الحصول على لون الخطأ حسب الثيم الحالي"""
        if self.current_mode == "dark":
            return "#FF6B6B"
        else:
            return "#DC143C"

    def get_success_color(self) -> str:
        """الحصول على لون النجاح حسب الثيم الحالي"""
        if self.current_mode == "dark":
            return "#51CF66"
        else:
            return "#228B22"

    def get_warning_color(self) -> str:
        """الحصول على لون التحذير حسب الثيم الحالي"""
        if self.current_mode == "dark":
            return "#FFD93D"
        else:
            return "#FFA500"

    def get_info_color(self) -> str:
        """الحصول على لون المعلومات حسب الثيم الحالي"""
        if self.current_mode == "dark":
            return "#339AF0"
        else:
            return "#0066CC"

    def is_windows7_theme(self) -> bool:
        """التحقق من استخدام ثيم Windows 7"""
        return self.current_color_theme.startswith("windows7")

    def get_available_themes(self) -> list:
        """الحصول على قائمة بجميع الثيمات المتاحة"""
        return self.builtin_themes + list(self.custom_themes.keys())

    def toggle_appearance_mode(self) -> None:
        """تبديل ثيم الواجهة بين 'light' و 'dark'"""
        new_mode = "dark" if self.current_mode == "light" else "light"
        logger.debug(f"ThemeManager: تبديل Appearance Mode من '{self.current_mode}' إلى '{new_mode}'.")
        self.apply_appearance_mode(new_mode)

    def get_current_appearance_mode(self) -> str:
        """إرجاع الثيم الحالي للواجهة"""
        return self.current_mode

    def get_current_color_theme(self) -> str:
        """إرجاع ثيم الألوان الحالي"""
        return self.current_color_theme

    def reload(self) -> None:
        """إعادة تحميل وتطبيق الثيمات من ConfigManager"""
        mode = self.config.get("appearance_mode", "light")
        color = self.config.get("color_theme", "blue")
        logger.debug("ThemeManager: إعادة تحميل الثيمات من ConfigManager.")
        self.apply_appearance_mode(mode)
        self.apply_color_theme(color)


============================================================
FILE: core\user_manager.py
SIZE: 14899 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/user_manager.py - نسخة محسنة

مدير المستخدمين المحسن مع إصلاح مشكلة get_field_value
"""

from typing import Dict, Optional, Any
import hashlib
import hmac
import secrets
import base64
from datetime import datetime, timedelta

from core.airtable_manager import AirtableModel
from core.db_manager import DatabaseManager
from core.logger import logger


class UserManager:
    """مدير المستخدمين المحسن"""

    def __init__(self, airtable_model: AirtableModel, db_manager: DatabaseManager) -> None:
        self.airtable_model: AirtableModel = airtable_model
        self.db: DatabaseManager = db_manager

        # تخزين المستخدمين في الذاكرة
        self._users_cache: Dict[str, Dict[str, Any]] = {}

        # حماية ضد هجمات القوة الغاشمة
        self._failed_attempts: Dict[str, list] = {}
        self._max_attempts = 5
        self._lockout_duration = timedelta(minutes=15)

        # مفتاح التشفير
        self._salt = b"FTS_SALES_MANAGER_2024"

        # تحميل المستخدمين
        self._load_users()

    def _hash_password(self, password: str, salt: Optional[bytes] = None) -> str:
        """تشفير كلمة المرور باستخدام PBKDF2-HMAC-SHA256"""
        if salt is None:
            salt = secrets.token_bytes(32)

        key = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            100_000
        )

        storage = salt + key
        return base64.b64encode(storage).decode('ascii')

    def _verify_password(self, stored_password: str, provided_password: str) -> bool:
        """التحقق من كلمة المرور"""
        try:
            decoded = base64.b64decode(stored_password)
            if len(decoded) >= 32:
                salt = decoded[:32]
                stored_key = decoded[32:]

                new_key = hashlib.pbkdf2_hmac(
                    'sha256',
                    provided_password.encode('utf-8'),
                    salt,
                    100_000
                )

                return hmac.compare_digest(stored_key, new_key)
        except Exception:
            pass

        # التوافق مع كلمات المرور القديمة
        return stored_password == provided_password

    def _is_account_locked(self, username: str) -> bool:
        """التحقق من قفل الحساب"""
        if username not in self._failed_attempts:
            return False

        cutoff_time = datetime.now() - self._lockout_duration
        self._failed_attempts[username] = [
            attempt for attempt in self._failed_attempts[username]
            if attempt > cutoff_time
        ]

        return len(self._failed_attempts[username]) >= self._max_attempts

    def _record_failed_attempt(self, username: str) -> None:
        """تسجيل محاولة فاشلة"""
        if username not in self._failed_attempts:
            self._failed_attempts[username] = []

        self._failed_attempts[username].append(datetime.now())

        cutoff_time = datetime.now() - self._lockout_duration
        self._failed_attempts[username] = [
            attempt for attempt in self._failed_attempts[username]
            if attempt > cutoff_time
        ]

    def _clear_failed_attempts(self, username: str) -> None:
        """مسح المحاولات الفاشلة"""
        if username in self._failed_attempts:
            del self._failed_attempts[username]

    def _load_users(self) -> None:
        """جلب جميع سجلات المستخدمين من Airtable"""
        logger.info("UserManager: بدء جلب المستخدمين من Airtable")

        try:
            records = self.airtable_model.fetch_records(use_cache=False)
            self._users_cache.clear()

            active_users = 0
            inactive_users = 0

            for rec in records:
                fields = rec.get("fields", {}) or {}

                username = fields.get("Username")
                if not username:
                    continue

                # كلمة المرور - محاولة العثور عليها في حقول مختلفة
                stored_password = fields.get("PasswordHash") or fields.get("Password") or fields.get("password")
                if not stored_password:
                    logger.warning(f"UserManager: المستخدم '{username}' بدون كلمة مرور")
                    continue

                is_active = fields.get("Active", True)
                if not is_active:
                    inactive_users += 1
                    logger.debug(f"UserManager: المستخدم '{username}' غير نشط")
                    continue

                active_users += 1

                # البيانات الإضافية
                airtable_view = fields.get("Airtable View")
                role = fields.get("Role", "viewer")
                airtable_collaborator = fields.get("Airtable Collaborator")

                last_login = fields.get("Last Login")
                login_count = fields.get("Login Count", 0)

                lookup_key = username.lower()
                self._users_cache[lookup_key] = {
                    'username': username,
                    'password': stored_password,
                    'view': airtable_view,
                    'role': role,
                    'airtable_collaborator': airtable_collaborator,
                    'record_id': rec.get("id"),
                    'is_active': is_active,
                    'last_login': last_login,
                    'login_count': login_count
                }

                logger.debug(f"تم تحميل المستخدم: {username} (Role: {role})")

            logger.info(f"UserManager: تم تحميل {active_users} مستخدم نشط ({inactive_users} غير نشط)")

        except Exception as exc:
            logger.error(f"UserManager: خطأ أثناء جلب المستخدمين: {exc}", exc_info=True)
            if not self._users_cache:
                raise Exception("فشل في تحميل بيانات المستخدمين من Airtable")

    def authenticate(self, username: str, password: str) -> Optional[Dict[str, Any]]:
        """التحقق من بيانات تسجيل الدخول"""
        if self._is_account_locked(username):
            logger.warning(f"UserManager: محاولة دخول لحساب مقفل '{username}'")
            return None

        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)

        if not user_info:
            logger.warning(f"UserManager: محاولة دخول باسم مستخدم غير موجود '{username}'")
            self._record_failed_attempt(username)
            return None

        if self._verify_password(user_info['password'], password):
            logger.info(f"UserManager: تسجيل دخول ناجح للمستخدم '{username}'")

            self._clear_failed_attempts(username)

            # تحديث آخر تسجيل دخول
            self._update_last_login(user_info['record_id'])

            # تحديث كلمة المرور إذا كانت نص عادي
            if user_info['password'] == password:
                logger.info(f"UserManager: تحديث كلمة مرور المستخدم '{username}' لتكون مشفرة")
                self._update_password_hash(user_info['record_id'], password)

            return {
                'username': user_info['username'],
                'view': user_info.get('view'),
                'role': user_info.get('role', 'viewer'),
                'airtable_collaborator': user_info.get('airtable_collaborator'),
                'record_id': user_info.get('record_id')
            }
        else:
            logger.warning(f"UserManager: كلمة مرور خاطئة للمستخدم '{username}'")
            self._record_failed_attempt(username)
            return None

    def _update_last_login(self, record_id: str) -> None:
        """تحديث آخر تسجيل دخول للمستخدم"""
        try:
            # الحصول على عدد مرات تسجيل الدخول الحالي
            current_login_count = 0
            for user_data in self._users_cache.values():
                if user_data.get('record_id') == record_id:
                    current_login_count = user_data.get('login_count', 0)
                    break

            fields = {
                "Last Login": datetime.now().isoformat(),
                "Login Count": current_login_count + 1
            }
            self.airtable_model.update_record(record_id, fields)

        except Exception as e:
            logger.error(f"UserManager: فشل تحديث آخر تسجيل دخول: {e}")

    def _update_password_hash(self, record_id: str, password: str) -> None:
        """تحديث كلمة المرور لتكون مشفرة"""
        try:
            hashed = self._hash_password(password)

            # محاولة تحديث في حقول مختلفة
            success = False

            # محاولة 1: حقل PasswordHash
            try:
                fields = {"PasswordHash": hashed}
                self.airtable_model.update_record(record_id, fields)
                success = True
                logger.info("تم تحديث كلمة المرور في حقل PasswordHash")
            except Exception as e1:
                logger.warning(f"فشل تحديث PasswordHash: {e1}")

                # محاولة 2: حقل Password
                try:
                    fields = {"Password": hashed}
                    self.airtable_model.update_record(record_id, fields)
                    success = True
                    logger.info("تم تحديث كلمة المرور في حقل Password")
                except Exception as e2:
                    logger.error(f"فشل تحديث Password أيضاً: {e2}")

            if success:
                # تحديث الكاش
                for user_data in self._users_cache.values():
                    if user_data.get('record_id') == record_id:
                        user_data['password'] = hashed
                        break

        except Exception as e:
            logger.error(f"UserManager: فشل تحديث كلمة المرور المشفرة: {e}")

    def change_password(self, username: str, old_password: str, new_password: str) -> bool:
        """تغيير كلمة مرور المستخدم"""
        if not self.authenticate(username, old_password):
            return False

        if not self._validate_password_strength(new_password):
            logger.warning(f"UserManager: كلمة المرور الجديدة ضعيفة للمستخدم '{username}'")
            return False

        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)
        if user_info:
            self._update_password_hash(user_info['record_id'], new_password)
            logger.info(f"UserManager: تم تغيير كلمة مرور المستخدم '{username}' بنجاح")
            return True

        return False

    def _validate_password_strength(self, password: str) -> bool:
        """التحقق من قوة كلمة المرور"""
        if len(password) < 8:
            return False

        has_letter = any(c.isalpha() for c in password)
        has_digit = any(c.isdigit() for c in password)

        return has_letter and has_digit

    def reset_password(self, username: str, new_password: str, admin_token: str) -> bool:
        """إعادة تعيين كلمة مرور المستخدم"""
        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)

        if not user_info:
            logger.error(f"UserManager: محاولة إعادة تعيين كلمة مرور لمستخدم غير موجود '{username}'")
            return False

        if not self._validate_password_strength(new_password):
            return False

        self._update_password_hash(user_info['record_id'], new_password)
        logger.info(f"UserManager: تم إعادة تعيين كلمة مرور المستخدم '{username}' بواسطة المدير")

        self._clear_failed_attempts(username)

        return True

    def reload_users(self) -> None:
        """إعادة تحميل بيانات المستخدمين من Airtable"""
        logger.debug("UserManager: إعادة تحميل بيانات المستخدمين")
        self._load_users()

    def get_user_view(self, username: str) -> Optional[str]:
        """الحصول على الـ View المخصص للمستخدم"""
        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)
        return user_info.get('view') if user_info else None

    def get_user_collaborator(self, username: str) -> Optional[Any]:
        """الحصول على Airtable Collaborator للمستخدم"""
        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)
        return user_info.get('airtable_collaborator') if user_info else None

    def get_user_role(self, username: str) -> str:
        """الحصول على دور المستخدم"""
        lookup_key = username.strip().lower()
        user_info = self._users_cache.get(lookup_key)
        return user_info.get('role', 'viewer') if user_info else 'viewer'

    def get_all_users(self) -> Dict[str, Dict[str, Any]]:
        """الحصول على جميع المستخدمين"""
        safe_users = {}
        for key, user in self._users_cache.items():
            safe_user = user.copy()
            safe_user.pop('password', None)
            safe_users[key] = safe_user
        return safe_users

    def user_exists(self, username: str) -> bool:
        """التحقق من وجود مستخدم"""
        lookup_key = username.strip().lower()
        return lookup_key in self._users_cache

    def create_user(self, username: str, password: str, role: str = "viewer",
                   admin_token: str = None) -> Optional[str]:
        """إنشاء مستخدم جديد"""
        if self.user_exists(username):
            logger.error(f"UserManager: المستخدم '{username}' موجود بالفعل")
            return None

        if not self._validate_password_strength(password):
            logger.error(f"UserManager: كلمة مرور ضعيفة للمستخدم الجديد '{username}'")
            return None

        password_hash = self._hash_password(password)

        try:
            # محاولة استخدام حقول مختلفة
            fields = {
                "Username": username,
                "Role": role,
                "Active": True,
                "Created Date": datetime.now().isoformat()
            }

            # محاولة إضافة كلمة المرور المشفرة
            try:
                fields["PasswordHash"] = password_hash
            except:
                # إذا فشل، استخدم حقل Password
                fields["Password"] = password_hash

            result = self.airtable_model.create_record(fields)
            if result:
                logger.info(f"UserManager: تم إنشاء المستخدم '{username}' بنجاح")
                self.reload_users()
                return result.get('id')

        except Exception as e:
            logger.error(f"UserManager: فشل إنشاء المستخدم '{username}': {e}")

        return None

============================================================
FILE: core\security\encryption.py
SIZE: 6042 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/security/encryption.py

مدير التشفير للبيانات الحساسة
"""

import hashlib
import secrets
from cryptography.fernet import Fernet
import os
import base64
import json
from typing import Tuple, Optional

from core.logger import logger


class EncryptionManager:
    """مدير التشفير الآمن للبيانات"""

    def __init__(self, key_file: str = "data/.encryption_key"):
        """
        Initialize encryption manager

        Args:
            key_file: Path to encryption key file
        """
        self.key_file = key_file
        self.key = self._get_or_create_key()
        self.cipher = Fernet(self.key)

    def _get_or_create_key(self) -> bytes:
        """الحصول على مفتاح التشفير أو إنشاؤه"""
        try:
            if os.path.exists(self.key_file):
                with open(self.key_file, 'rb') as f:
                    key = f.read()
                    # Validate key
                    Fernet(key)  # This will raise if invalid
                    return key

            # Create new key
            key = Fernet.generate_key()

            # Save key securely
            os.makedirs(os.path.dirname(self.key_file), exist_ok=True)

            # Set restrictive permissions on Unix-like systems
            if os.name != 'nt':  # Not Windows
                os.chmod(os.path.dirname(self.key_file), 0o700)

            with open(self.key_file, 'wb') as f:
                f.write(key)

            # Set file permissions
            if os.name != 'nt':
                os.chmod(self.key_file, 0o600)

            logger.info("Created new encryption key")
            return key

        except Exception as e:
            logger.error(f"Error managing encryption key: {e}")
            # Generate temporary key (not persistent)
            return Fernet.generate_key()

    def encrypt_data(self, data: str) -> str:
        """
        تشفير البيانات

        Args:
            data: String data to encrypt

        Returns:
            Base64 encoded encrypted data
        """
        try:
            encrypted = self.cipher.encrypt(data.encode('utf-8'))
            return base64.urlsafe_b64encode(encrypted).decode('utf-8')
        except Exception as e:
            logger.error(f"Encryption error: {e}")
            raise

    def decrypt_data(self, encrypted_data: str) -> str:
        """
        فك تشفير البيانات

        Args:
            encrypted_data: Base64 encoded encrypted data

        Returns:
            Decrypted string data
        """
        try:
            decoded = base64.urlsafe_b64decode(encrypted_data.encode('utf-8'))
            decrypted = self.cipher.decrypt(decoded)
            return decrypted.decode('utf-8')
        except Exception as e:
            logger.error(f"Decryption error: {e}")
            raise

    def encrypt_json(self, data: dict) -> str:
        """
        تشفير بيانات JSON

        Args:
            data: Dictionary to encrypt

        Returns:
            Encrypted JSON string
        """
        json_str = json.dumps(data, ensure_ascii=False)
        return self.encrypt_data(json_str)

    def decrypt_json(self, encrypted_data: str) -> dict:
        """
        فك تشفير بيانات JSON

        Args:
            encrypted_data: Encrypted JSON string

        Returns:
            Decrypted dictionary
        """
        json_str = self.decrypt_data(encrypted_data)
        return json.loads(json_str)

    def hash_password(self, password: str, salt: Optional[bytes] = None) -> Tuple[str, bytes]:
        """
        تشفير كلمة المرور باستخدام PBKDF2

        Args:
            password: Password to hash
            salt: Optional salt (will generate if not provided)

        Returns:
            Tuple of (hashed_password, salt)
        """
        if salt is None:
            salt = secrets.token_bytes(32)

        # Use PBKDF2 with SHA256
        hashed = hashlib.pbkdf2_hmac(
            'sha256',
            password.encode('utf-8'),
            salt,
            100000,  # iterations
            dklen=64  # 64 bytes = 512 bits
        )

        # Return base64 encoded hash and salt
        return base64.b64encode(hashed).decode('utf-8'), salt

    def verify_password(self, password: str, hashed: str, salt: bytes) -> bool:
        """
        التحقق من كلمة المرور

        Args:
            password: Password to verify
            hashed: Base64 encoded hashed password
            salt: Salt used for hashing

        Returns:
            True if password matches
        """
        new_hash, _ = self.hash_password(password, salt)
        return secrets.compare_digest(new_hash, hashed)

    def generate_token(self, length: int = 32) -> str:
        """
        Generate secure random token

        Args:
            length: Token length in bytes

        Returns:
            URL-safe base64 encoded token
        """
        return secrets.token_urlsafe(length)

    def rotate_key(self) -> bool:
        """
        Rotate encryption key (requires re-encrypting all data)

        Returns:
            True if successful
        """
        try:
            # Generate new key
            new_key = Fernet.generate_key()
            new_cipher = Fernet(new_key)

            # Save old key for rollback
            old_key = self.key

            # Update key
            self.key = new_key
            self.cipher = new_cipher

            # Save new key
            with open(self.key_file, 'wb') as f:
                f.write(new_key)

            logger.info("Encryption key rotated successfully")
            return True

        except Exception as e:
            logger.error(f"Key rotation failed: {e}")
            return False

============================================================
FILE: core\security\rate_limiter.py
SIZE: 10258 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/security/rate_limiter.py

حماية من هجمات Brute Force
"""

import time
import json
import os
from collections import defaultdict
from typing import Tuple, Dict, List
from datetime import datetime, timedelta
import threading

from core.logger import logger


class RateLimiter:
    """مدير حماية معدل المحاولات"""

    def __init__(
        self,
        max_attempts: int = 5,
        window_seconds: int = 300,  # 5 minutes
        lockout_seconds: int = 300,  # 5 minutes
        persistent_storage: bool = True
    ):
        """
        Initialize rate limiter

        Args:
            max_attempts: Maximum attempts allowed in window
            window_seconds: Time window for attempts
            lockout_seconds: Lockout duration after max attempts
            persistent_storage: Save state to disk
        """
        self.max_attempts = max_attempts
        self.window_seconds = window_seconds
        self.lockout_seconds = lockout_seconds
        self.persistent_storage = persistent_storage

        # Storage
        self.attempts: Dict[str, List[float]] = defaultdict(list)
        self.lockouts: Dict[str, float] = {}
        self.config_file = "data/rate_limiter.json"

        # Thread safety
        self._lock = threading.RLock()

        # Load saved state
        if self.persistent_storage:
            self._load_state()

        # Start cleanup thread
        self._start_cleanup_thread()

    def check_rate_limit(self, identifier: str) -> Tuple[bool, str]:
        """
        التحقق من معدل المحاولات

        Args:
            identifier: Unique identifier (e.g., username:ip)

        Returns:
            Tuple of (allowed, message)
        """
        with self._lock:
            # Clean up old data
            self._cleanup_old_attempts()

            # Check if locked out
            if identifier in self.lockouts:
                remaining = self.lockouts[identifier] - time.time()
                if remaining > 0:
                    minutes = int(remaining // 60)
                    seconds = int(remaining % 60)
                    return False, f"Account locked. Try again in {minutes}m {seconds}s"
                else:
                    # Lockout expired
                    del self.lockouts[identifier]
                    logger.info(f"Lockout expired for: {identifier}")

            # Check attempts in current window
            now = time.time()
            window_start = now - self.window_seconds

            # Filter attempts within window
            self.attempts[identifier] = [
                t for t in self.attempts[identifier]
                if t > window_start
            ]

            # Check if exceeding limit
            current_attempts = len(self.attempts[identifier])

            if current_attempts >= self.max_attempts:
                # Lock out the identifier
                self.lockouts[identifier] = now + self.lockout_seconds
                logger.warning(f"Rate limit exceeded for: {identifier} - Locked out")

                if self.persistent_storage:
                    self._save_state()

                return False, f"Too many attempts. Account locked for {self.lockout_seconds // 60} minutes."

            # Calculate remaining attempts
            remaining = self.max_attempts - current_attempts
            return True, f"{remaining} attempts remaining"

    def record_attempt(self, identifier: str):
        """
        تسجيل محاولة

        Args:
            identifier: Unique identifier
        """
        with self._lock:
            self.attempts[identifier].append(time.time())
            logger.debug(f"Recorded attempt for: {identifier}")

            if self.persistent_storage:
                self._save_state()

    def clear_attempts(self, identifier: str):
        """
        مسح المحاولات عند النجاح

        Args:
            identifier: Unique identifier
        """
        with self._lock:
            if identifier in self.attempts:
                del self.attempts[identifier]
            if identifier in self.lockouts:
                del self.lockouts[identifier]

            logger.info(f"Cleared attempts for: {identifier}")

            if self.persistent_storage:
                self._save_state()

    def is_locked_out(self, identifier: str) -> bool:
        """
        Check if identifier is locked out

        Args:
            identifier: Unique identifier

        Returns:
            True if locked out
        """
        with self._lock:
            if identifier in self.lockouts:
                if self.lockouts[identifier] > time.time():
                    return True
                else:
                    del self.lockouts[identifier]
            return False

    def get_attempts_count(self, identifier: str) -> int:
        """
        Get current attempts count

        Args:
            identifier: Unique identifier

        Returns:
            Number of attempts in current window
        """
        with self._lock:
            now = time.time()
            window_start = now - self.window_seconds

            return len([
                t for t in self.attempts.get(identifier, [])
                if t > window_start
            ])

    def reset_identifier(self, identifier: str):
        """
        Reset all data for an identifier

        Args:
            identifier: Unique identifier
        """
        self.clear_attempts(identifier)

    def _cleanup_old_attempts(self):
        """تنظيف المحاولات القديمة"""
        now = time.time()
        window_start = now - self.window_seconds

        # Clean attempts
        for identifier in list(self.attempts.keys()):
            self.attempts[identifier] = [
                t for t in self.attempts[identifier]
                if t > window_start
            ]
            if not self.attempts[identifier]:
                del self.attempts[identifier]

        # Clean expired lockouts
        for identifier in list(self.lockouts.keys()):
            if self.lockouts[identifier] <= now:
                del self.lockouts[identifier]
                logger.debug(f"Removed expired lockout for: {identifier}")

    def _save_state(self):
        """حفظ الحالة إلى الملف"""
        if not self.persistent_storage:
            return

        try:
            with self._lock:
                state = {
                    "attempts": dict(self.attempts),
                    "lockouts": dict(self.lockouts),
                    "timestamp": datetime.now().isoformat(),
                    "config": {
                        "max_attempts": self.max_attempts,
                        "window_seconds": self.window_seconds,
                        "lockout_seconds": self.lockout_seconds
                    }
                }

                os.makedirs(os.path.dirname(self.config_file), exist_ok=True)

                # Write to temporary file first
                temp_file = f"{self.config_file}.tmp"
                with open(temp_file, 'w', encoding='utf-8') as f:
                    json.dump(state, f, indent=2)

                # Atomic rename
                os.replace(temp_file, self.config_file)

        except Exception as e:
            logger.error(f"Error saving rate limiter state: {e}")

    def _load_state(self):
        """تحميل الحالة من الملف"""
        if not self.persistent_storage:
            return

        try:
            if os.path.exists(self.config_file):
                with open(self.config_file, 'r', encoding='utf-8') as f:
                    state = json.load(f)

                with self._lock:
                    # Load attempts
                    self.attempts = defaultdict(list)
                    for key, value in state.get("attempts", {}).items():
                        self.attempts[key] = value

                    # Load lockouts
                    self.lockouts = state.get("lockouts", {})

                    # Clean old data immediately
                    self._cleanup_old_attempts()

                logger.info("Loaded rate limiter state")

        except Exception as e:
            logger.error(f"Error loading rate limiter state: {e}")

    def _start_cleanup_thread(self):
        """Start background cleanup thread"""
        def cleanup_loop():
            while True:
                try:
                    time.sleep(60)  # Run every minute
                    with self._lock:
                        self._cleanup_old_attempts()
                        if self.persistent_storage:
                            self._save_state()
                except Exception as e:
                    logger.error(f"Cleanup thread error: {e}")

        thread = threading.Thread(target=cleanup_loop, daemon=True)
        thread.start()

    def get_statistics(self) -> dict:
        """
        Get rate limiter statistics

        Returns:
            Dictionary with statistics
        """
        with self._lock:
            return {
                "total_tracked": len(self.attempts),
                "currently_locked": len(self.lockouts),
                "total_attempts": sum(len(attempts) for attempts in self.attempts.values()),
                "config": {
                    "max_attempts": self.max_attempts,
                    "window_seconds": self.window_seconds,
                    "lockout_seconds": self.lockout_seconds
                }
            }

    def export_blacklist(self) -> List[str]:
        """
        Export list of currently locked identifiers

        Returns:
            List of locked identifiers
        """
        with self._lock:
            self._cleanup_old_attempts()
            return list(self.lockouts.keys())

============================================================
FILE: core\security\two_factor_auth.py
SIZE: 11664 characters
============================================================

# -*- coding: utf-8 -*-
"""
core/security/two_factor_auth.py

مدير المصادقة الثنائية
Two-Factor Authentication Manager
"""

import pyotp
import qrcode
import io
import base64
import secrets
from typing import Optional, List, Tuple
from datetime import datetime
import json

from core.logger import logger


class TwoFactorAuth:
    """مدير المصادقة الثنائية"""

    def __init__(self, issuer_name: str = "FTS Sales Manager"):
        """
        Initialize 2FA manager

        Args:
            issuer_name: Name shown in authenticator apps
        """
        self.issuer_name = issuer_name

    def generate_secret(self) -> str:
        """
        Generate a new secret key for 2FA

        Returns:
            Base32 encoded secret key
        """
        return pyotp.random_base32()

    def generate_qr_code(self, username: str, secret: str) -> str:
        """
        Generate QR code for authenticator app setup

        Args:
            username: User's username
            secret: Secret key

        Returns:
            Base64 encoded QR code image
        """
        try:
            # Create provisioning URI
            totp = pyotp.TOTP(secret)
            provisioning_uri = totp.provisioning_uri(
                name=username,
                issuer_name=self.issuer_name
            )

            # Generate QR code
            qr = qrcode.QRCode(
                version=1,
                error_correction=qrcode.constants.ERROR_CORRECT_L,
                box_size=10,
                border=4,
            )
            qr.add_data(provisioning_uri)
            qr.make(fit=True)

            # Create image
            img = qr.make_image(fill_color="black", back_color="white")

            # Convert to base64
            buffer = io.BytesIO()
            img.save(buffer, format='PNG')
            img_str = base64.b64encode(buffer.getvalue()).decode()

            return f"data:image/png;base64,{img_str}"

        except Exception as e:
            logger.error(f"Error generating QR code: {e}")
            raise

    def verify_token(self, secret: str, token: str, window: int = 1) -> bool:
        """
        Verify a TOTP token

        Args:
            secret: User's secret key
            token: 6-digit token from authenticator
            window: Time window for validity (default 1 = ±30 seconds)

        Returns:
            True if token is valid
        """
        try:
            # Remove spaces and validate format
            token = token.replace(" ", "").strip()

            if not token.isdigit() or len(token) != 6:
                return False

            # Verify token
            totp = pyotp.TOTP(secret)
            return totp.verify(token, valid_window=window)

        except Exception as e:
            logger.error(f"Error verifying token: {e}")
            return False

    def generate_backup_codes(self, count: int = 10) -> List[str]:
        """
        Generate backup codes for account recovery

        Args:
            count: Number of backup codes to generate

        Returns:
            List of backup codes
        """
        codes = []

        for _ in range(count):
            # Generate 8-character alphanumeric code
            code = ''.join(secrets.choice('ABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789') for _ in range(8))
            # Format as XXXX-XXXX
            formatted_code = f"{code[:4]}-{code[4:]}"
            codes.append(formatted_code)

        return codes

    def hash_backup_code(self, code: str) -> str:
        """
        Hash a backup code for storage

        Args:
            code: Backup code to hash

        Returns:
            Hashed code
        """
        import hashlib

        # Remove formatting
        clean_code = code.replace("-", "").upper()

        # Hash with salt
        salt = "FTS_2FA_BACKUP"
        return hashlib.sha256(f"{salt}{clean_code}".encode()).hexdigest()

    def verify_backup_code(self, code: str, hashed_codes: List[str]) -> Tuple[bool, Optional[str]]:
        """
        Verify a backup code

        Args:
            code: Backup code to verify
            hashed_codes: List of hashed backup codes

        Returns:
            Tuple of (is_valid, used_code_hash)
        """
        hashed = self.hash_backup_code(code)

        if hashed in hashed_codes:
            return True, hashed

        return False, None

    def get_current_token(self, secret: str) -> str:
        """
        Get current TOTP token (for testing)

        Args:
            secret: Secret key

        Returns:
            Current 6-digit token
        """
        totp = pyotp.TOTP(secret)
        return totp.now()

    def get_time_remaining(self) -> int:
        """
        Get seconds remaining for current token

        Returns:
            Seconds until token expires
        """
        import time
        return 30 - int(time.time() % 30)

    def export_setup_data(self, username: str, secret: str, backup_codes: List[str]) -> dict:
        """
        Export 2FA setup data for user

        Args:
            username: Username
            secret: Secret key
            backup_codes: List of backup codes

        Returns:
            Dictionary with setup data
        """
        return {
            "username": username,
            "secret": secret,
            "issuer": self.issuer_name,
            "backup_codes": backup_codes,
            "setup_date": datetime.now().isoformat(),
            "algorithm": "SHA1",
            "digits": 6,
            "period": 30
        }

    def validate_setup(self, secret: str, token1: str, token2: str) -> bool:
        """
        Validate 2FA setup with two consecutive tokens

        Args:
            secret: Secret key
            token1: First token
            token2: Second token (should be different)

        Returns:
            True if setup is valid
        """
        # Verify first token
        if not self.verify_token(secret, token1):
            return False

        # Ensure tokens are different
        if token1 == token2:
            return False

        # Wait and verify second token
        import time
        time.sleep(1)

        return self.verify_token(secret, token2)


class TwoFactorDialog(ctk.CTkToplevel):
    """نافذة إدخال رمز المصادقة الثنائية"""

    def __init__(self, parent, lang_manager, theme_manager):
        super().__init__(parent)

        self.parent = parent
        self.lang_manager = lang_manager
        self.theme_manager = theme_manager
        self.result = None

        # Setup window
        self.title(self.lang_manager.get("2fa_title", "Two-Factor Authentication"))
        self.geometry("400x300")
        self.resizable(False, False)

        # Make modal
        self.transient(parent)
        self.grab_set()

        # Build UI
        self._build_ui()

        # Center window
        self.update_idletasks()
        x = (self.winfo_screenwidth() - 400) // 2
        y = (self.winfo_screenheight() - 300) // 2
        self.geometry(f"400x300+{x}+{y}")

        # Focus on entry
        self.after(100, lambda: self.code_entry.focus_set())

    def _build_ui(self):
        """Build dialog UI"""
        # Main frame
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # Icon and title
        title_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 20))

        icon_label = ctk.CTkLabel(
            title_frame,
            text="🔐",
            font=ctk.CTkFont(size=48)
        )
        icon_label.pack()

        title_label = ctk.CTkLabel(
            title_frame,
            text=self.lang_manager.get("2fa_prompt", "Enter Authentication Code"),
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title_label.pack(pady=(10, 0))

        # Instructions
        instructions = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get(
                "2fa_instructions",
                "Enter the 6-digit code from your authenticator app"
            ),
            font=ctk.CTkFont(size=12),
            text_color="gray60",
            wraplength=350
        )
        instructions.pack(pady=(0, 20))

        # Code entry
        self.code_entry = ctk.CTkEntry(
            main_frame,
            placeholder_text="000 000",
            font=ctk.CTkFont(size=24, weight="bold"),
            justify="center",
            height=50,
            width=200
        )
        self.code_entry.pack()

        # Bind events
        self.code_entry.bind("<Return>", lambda e: self._verify())
        self.code_entry.bind("<KeyRelease>", self._format_code)

        # Buttons
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x", pady=(30, 0))

        self.verify_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("verify", "Verify"),
            command=self._verify,
            width=120,
            height=40
        )
        self.verify_btn.pack(side="left", padx=(0, 10))

        self.cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self._cancel,
            width=120,
            height=40,
            fg_color="transparent",
            border_width=2
        )
        self.cancel_btn.pack(side="left")

        # Use backup code link
        backup_link = ctk.CTkButton(
            main_frame,
            text=self.lang_manager.get("use_backup_code", "Use backup code"),
            font=ctk.CTkFont(size=12, underline=True),
            fg_color="transparent",
            text_color=("blue", "lightblue"),
            hover=False,
            command=self._use_backup_code
        )
        backup_link.pack(pady=(15, 0))

    def _format_code(self, event=None):
        """Format code as XXX XXX"""
        text = self.code_entry.get().replace(" ", "")

        # Only allow digits
        text = ''.join(c for c in text if c.isdigit())[:6]

        # Format with space
        if len(text) > 3:
            text = f"{text[:3]} {text[3:]}"

        # Update entry
        self.code_entry.delete(0, "end")
        self.code_entry.insert(0, text)

    def _verify(self):
        """Verify code"""
        code = self.code_entry.get().replace(" ", "")

        if len(code) != 6 or not code.isdigit():
            self.code_entry.configure(border_color="red")
            return

        self.result = code
        self.destroy()

    def _cancel(self):
        """Cancel dialog"""
        self.result = None
        self.destroy()

    def _use_backup_code(self):
        """Switch to backup code entry"""
        # Change UI for backup code entry
        self.code_entry.configure(placeholder_text="XXXX-XXXX")
        self.title(self.lang_manager.get("backup_code_title", "Enter Backup Code"))

    def get_code(self) -> Optional[str]:
        """Get entered code"""
        self.wait_window()
        return self.result

============================================================
FILE: data\login_cache.json
SIZE: 89 characters
============================================================

{
  "username": "user",
  "remember": true,
  "timestamp": "2025-07-03T04:24:57.383528"
}

============================================================
FILE: locales\ar.yaml
SIZE: 24141 characters
============================================================

# locales/ar.yaml - النسخة المحدثة والكاملة

# عناوين النوافذ
login_title: "تسجيل الدخول"
main_window_title: "مدير مبيعات FTS"
add_edit_title: "إضافة/تعديل حجز"
view_manager_title: "مدير طرق العرض"

# تسميات تسجيل الدخول
username_label: "اسم المستخدم"
password_label: "كلمة المرور"
username_placeholder: "أدخل اسم المستخدم"
password_placeholder: "أدخل كلمة المرور"
login_button: "دخول"
show_password: "إظهار"
toggle_theme: "تبديل الثيم"

# رسائل تسجيل الدخول
error_empty_credentials: "يرجى إدخال اسم المستخدم وكلمة المرور."
error_invalid_credentials: "اسم المستخدم أو كلمة المرور غير صحيح."
error_auth_exception: "خطأ أثناء التحقق."
error_login_process: "خطأ في معالجة تسجيل الدخول."

# ============ شريط القوائم ============
# القوائم الرئيسية
file_menu: "ملف"
edit_menu: "تحرير"
view_menu: "عرض"
tools_menu: "أدوات"
admin_menu: "مسؤول"
help_menu: "مساعدة"

# عناصر قائمة ملف
logout: "تسجيل خروج"
export_data: "تصدير البيانات"
close: "إغلاق"

# عناصر قائمة عرض
dark_mode: "الوضع الداكن"
language_menu: "اللغة"
arabic: "العربية"
english: "English"
fullscreen: "ملء الشاشة"
performance_mode: "وضع الأداء العالي"

# عناصر قائمة أدوات
reports: "التقارير"

# عناصر قائمة مسؤول
user_management: "إدارة المستخدمين"
config_editor: "محرر الإعدادات"
clear_cache: "مسح الذاكرة المؤقتة"
view_logs: "عرض السجلات"

# عناصر قائمة مساعدة
user_guide: "دليل المستخدم"

# رسائل تأكيد إضافية
confirm_logout: "هل أنت متأكد أنك تريد تسجيل الخروج؟"
confirm_clear_cache: "مسح جميع البيانات المؤقتة؟"

# رسائل حالة إضافية
performance_mode_enabled: "تم تفعيل وضع الأداء العالي"
performance_mode_disabled: "تم تعطيل وضع الأداء العالي"
cache_cleared: "تم مسح الذاكرة المؤقتة بنجاح"
fullscreen_enabled: "تم تفعيل ملء الشاشة"
fullscreen_disabled: "تم تعطيل ملء الشاشة"

# رسائل "قريباً"
coming_soon: "قريباً"
export_coming_soon: "ميزة التصدير قريباً"
reports_coming_soon: "ميزة التقارير قريباً"
user_management_coming_soon: "إدارة المستخدمين قريباً"
config_editor_coming_soon: "محرر الإعدادات قريباً"
logs_viewer_coming_soon: "عارض السجلات قريباً"

# دليل المستخدم
guide_add: "لإضافة حجز: انقر على زر إضافة أو اضغط Ctrl+N"
guide_edit: "للتعديل: انقر مزدوجاً على حجز أو اضغط Ctrl+E"
guide_delete: "للحذف: حدد الحجوزات واضغط Delete"
guide_search: "للبحث: استخدم صندوق البحث أو اضغط Ctrl+F"
guide_export: "للتصدير: استخدم قائمة ملف > تصدير أو اضغط Ctrl+S"

# معلومات البرنامج
app_name: "مدير مبيعات FTS"
developed_by: "تم التطوير بواسطة"
logged_as: "مسجل الدخول كـ"
user_role: "الدور"

# ============ باقي المحتوى الأصلي ============

# القوائم
menu_settings: "الإعدادات"
menu_change_language: "تغيير اللغة"
menu_toggle_theme: "تبديل الثيم"
menu_account: "الحساب"
menu_logout: "تسجيل الخروج"
menu_exit: "خروج"
menu_views: "طرق العرض"
menu_view_manager: "مدير طرق العرض"

# رسائل التأكيد
confirm_change_language: "هل تريد تغيير اللغة؟"
confirm_exit: "هل أنت متأكد أنك تريد الخروج؟"
confirm_delete: "هل أنت متأكد من حذف هذا الحجز؟"
confirm_delete_multiple: "هل أنت متأكد من حذف {} حجز؟"
confirm_close: "تأكيد الإغلاق"

# شريط البحث والحالة
search_label: "بحث:"
search_placeholder: "اكتب للبحث..."
status_loading: "جاري التحميل..."
status_load_complete: "تم تحميل {} سجل."
error_loading_records: "خطأ أثناء تحميل السجلات."
loading_data: "جاري تحميل البيانات..."
refreshing_data: "جاري تحديث البيانات..."
saving_data: "جاري حفظ البيانات..."
processing: "جاري المعالجة..."

# أزرار الإجراءات
add: "إضافة"
edit: "تعديل"
delete: "حذف"
save: "حفظ"
cancel: "إلغاء"
close: "إغلاق"
refresh: "تحديث"
export: "تصدير"
import: "استيراد"
print: "طباعة"
apply: "تطبيق"
clear: "مسح"
search: "بحث"
filter: "تصفية"
sort: "ترتيب"
select_all: "تحديد الكل"
clear_selection: "إلغاء التحديد"

# رسائل الإجراءات
add_button: "➕ إضافة حجز"
edit_button: "✏️ تعديل حجز"
delete_button: "🗑️ حذف حجز"
refresh_button: "🔄 تحديث"
export_button: "📤 تصدير"

# رسائل التحديد
error_no_selection: "يرجى اختيار سجل."
select_booking_edit: "يرجى تحديد حجز للتعديل"
select_booking_delete: "يرجى تحديد حجز للحذف"
select_one_booking_only: "يمكن تعديل حجز واحد فقط في كل مرة"
selected_count: "محدد: {} حجز"
no_selection: "لا يوجد تحديد"

# رسائل النجاح والخطأ
success: "نجاح"
error: "خطأ"
warning: "تحذير"
info: "معلومات"
success_save: "تم الحفظ بنجاح!"
success_update: "تم التحديث بنجاح!"
success_delete: "تم الحذف بنجاح!"
error_save: "فشل في حفظ البيانات"
error_update: "فشل في تحديث البيانات"
error_delete: "فشل في حذف السجل"
error_load: "فشل في تحميل البيانات"
error_add_form: "فشل في فتح نموذج الإضافة"
error_edit_form: "فشل في فتح نموذج التعديل"

# نافذة الإضافة/التعديل
basic_info: "معلومات أساسية"
trip_details: "تفاصيل الرحلة"
passenger_info: "معلومات الركاب"
contact_info: "معلومات الاتصال"
pricing_info: "معلومات الأسعار"
additional_info: "معلومات إضافية"

# الحقول
customer_name: "اسم العميل"
hotel_name: "اسم الفندق"
agency: "الوكالة"
booking_number: "رقم الحجز"
room_number: "رقم الغرفة"
trip_name: "اسم الرحلة"
trip_date: "تاريخ الرحلة"
option: "الخيار"
destination: "الوجهة"
guide: "المرشد"
product_id: "معرف المنتج"
pickup_time: "وقت الانطلاق"
remarks: "ملاحظات"
add_ons: "الإضافات"
adults: "البالغين"
children: "الأطفال"
students: "الطلاب"
youth: "الشباب"
infants: "الرضع"
children_ages: "أعمار الأطفال"
phone_number: "رقم الهاتف"
email: "البريد الإلكتروني"
customer_country: "بلد العميل"
total_price_usd: "السعر الإجمالي (USD)"
total_price_eur: "السعر الإجمالي (EUR)"
total_price_gbp: "السعر الإجمالي (GBP)"
net_rate: "السعر الصافي"
currency: "العملة"
cost_egp: "التكلفة (EGP)"
collecting_on_date: "التحصيل عند التاريخ"
management_option: "خيار الإدارة"
add_on: "إضافة"

# رسائل التحقق
required_field: "هذا الحقل مطلوب"
invalid_phone: "رقم هاتف غير صحيح"
invalid_date: "تاريخ غير صحيح"
invalid_number: "يرجى إدخال رقم صحيح"
future_date: "التاريخ لا يمكن أن يكون في الماضي"
negative_amount: "المبلغ لا يمكن أن يكون سالباً"
invalid_email: "بريد إلكتروني غير صحيح"

# القوائم المنسدلة
add_new_value: "إضافة قيمة جديدة"
enter_new_value: "أدخل القيمة الجديدة:"
value_added_successfully: "تمت إضافة '{}' بنجاح"
failed_add_value: "فشل في إضافة القيمة إلى Airtable"
dropdown_error: "خطأ في تحميل قيم القائمة المنسدلة"
dropdown_manager_unavailable: "مدير القوائم المنسدلة غير متاح"
refresh_lists: "تحديث القوائم"
lists_status: "حالة القوائم"
lists_updated: "تم تحديث القوائم بنجاح"
update_failed: "فشل تحديث القوائم"
loading_lists: "جاري تحميل القوائم..."
updating_lists: "جاري تحديث القوائم..."
all_lists_working: "جميع القوائم المنسدلة تعمل بشكل صحيح!"
dropdown_errors: "أخطاء القوائم المنسدلة"
check_connection: "تحقق من:\n1. اتصال الإنترنت\n2. مفتاح API ومعرف القاعدة\n3. وجود الجداول في Airtable"

# التنقل
previous: "السابق"
next: "التالي"
first_page: "الصفحة الأولى"
last_page: "الصفحة الأخيرة"
page: "صفحة"
of: "من"
showing: "عرض"
to: "إلى"
total_records: "إجمالي السجلات"
navigating_to: "الانتقال إلى"

# المسودات
draft: "مسودة"
save_draft: "حفظ كمسودة"
load_draft: "تحميل مسودة"
draft_saved: "تم حفظ المسودة بنجاح"
draft_save_failed: "فشل في حفظ المسودة"
draft_found: "تم العثور على مسودة"
load_draft_question: "تم العثور على مسودة محفوظة. هل تريد تحميلها؟"
unsaved_changes: "تغييرات غير محفوظة"
save_draft_question: "هناك تغييرات غير محفوظة.\n\nهل تريد حفظها كمسودة؟"

# اختصارات لوحة المفاتيح
shortcuts: "اختصارات"
keyboard_shortcuts: "اختصارات لوحة المفاتيح"
required_fields: "الحقول المطلوبة"
change_language: "تغيير اللغة"
change_theme: "تغيير الثيم"

# Views وطرق العرض
view_label: "طريقة العرض:"
all_records: "جميع السجلات"
today_bookings: "حجوزات اليوم"
this_week: "هذا الأسبوع"
this_month: "هذا الشهر"
pending_bookings: "الحجوزات المعلقة"
confirmed_bookings: "الحجوزات المؤكدة"
cancelled_bookings: "الحجوزات الملغاة"
my_bookings: "حجوزاتي"
team_bookings: "حجوزات الفريق"
high_priority: "أولوية عالية"
vip_customers: "عملاء VIP"
airport_transfers: "نقل المطار"
hotel_transfers: "نقل الفندق"
tour_bookings: "حجوزات الجولات"

# مدير Views
view_manager: "مدير طرق العرض"
assign_views_to_users: "تعيين طرق العرض للمستخدمين"
select_view: "اختر طريقة العرض:"
apply_to_selected: "تطبيق على المحدد"
apply_to_all_role: "تطبيق على جميع المستخدمين بنفس الدور"
apply_to_role: "تطبيق على الدور"
select_role_and_view: "اختر الدور وطريقة العرض:"
select_view_first: "يرجى اختيار طريقة عرض أولاً"
select_user_first: "يرجى اختيار مستخدم أولاً"
select_role_and_view_first: "يرجى اختيار الدور وطريقة العرض"
save_changes: "حفظ جميع التغييرات"
save_all_changes: "حفظ جميع التغييرات"
no_changes_to_save: "لا توجد تغييرات للحفظ"
failed_load_users: "فشل في تحميل المستخدمين"
failed_save_changes: "فشل في حفظ التغييرات"

# حالات الحجز
booking_status: "حالة الحجز"
status_active: "نشط"
status_pending: "قيد الانتظار"
status_confirmed: "مؤكد"
status_cancelled: "ملغي"
status_completed: "مكتمل"

# الإحصائيات
statistics: "الإحصائيات"
total_bookings: "إجمالي الحجوزات"
today_count: "حجوزات اليوم"
pending_count: "بانتظار الموافقة"

# التصدير
export_to_excel: "تصدير إلى Excel"
export_to_pdf: "تصدير إلى PDF"
export_success: "تم التصدير بنجاح"
export_failed: "فشل التصدير"
no_data_export: "لا توجد بيانات للتصدير"

# رسائل عامة
please_wait: "يرجى الانتظار..."
loading: "جاري التحميل..."
done: "تم"
yes: "نعم"
no: "لا"
ok: "موافق"
confirm: "تأكيد"
back: "رجوع"
forward: "للأمام"
help: "مساعدة"
about: "حول"
version: "الإصدار"
copyright: "© 2024 FTS. جميع الحقوق محفوظة."

# رسائل النظام
system_error: "خطأ في النظام"
network_error: "خطأ في الشبكة"
permission_denied: "ليس لديك صلاحية"
session_expired: "انتهت الجلسة"
please_login_again: "يرجى تسجيل الدخول مرة أخرى"

# التاريخ والوقت
date: "التاريخ"
time: "الوقت"
datetime: "التاريخ والوقت"
today: "اليوم"
yesterday: "أمس"
tomorrow: "غداً"
this_week: "هذا الأسبوع"
last_week: "الأسبوع الماضي"
next_week: "الأسبوع القادم"
this_month: "هذا الشهر"
last_month: "الشهر الماضي"
next_month: "الشهر القادم"
this_year: "هذه السنة"
last_year: "السنة الماضية"
next_year: "السنة القادمة"

# أيام الأسبوع
monday: "الإثنين"
tuesday: "الثلاثاء"
wednesday: "الأربعاء"
thursday: "الخميس"
friday: "الجمعة"
saturday: "السبت"
sunday: "الأحد"

# الأشهر
january: "يناير"
february: "فبراير"
march: "مارس"
april: "أبريل"
may: "مايو"
june: "يونيو"
july: "يوليو"
august: "أغسطس"
september: "سبتمبر"
october: "أكتوبر"
november: "نوفمبر"
december: "ديسمبر"

# التنقل
nav_home: "الرئيسية"
nav_today: "حجوزات اليوم"
nav_pending: "الحجوزات المعلقة"
nav_confirmed: "الحجوزات المؤكدة"
nav_reports: "التقارير"

# الإحصائيات
stats_total: "إجمالي الحجوزات"
stats_today: "حجوزات اليوم"
stats_pending: "معلقة"

# الأدوار
role_admin: "مدير النظام"
role_manager: "مدير"
role_editor: "محرر"
role_viewer: "مشاهد"

# البحث
search_placeholder: "بحث..."

# عناوين أعمدة الجدول
booking_number: "رقم الحجز"
trip_date: "تاريخ الرحلة"
customer_name: "اسم العميل"
hotel: "الفندق"
pickup_time: "وقت الاستلام"
price: "السعر"
status: "الحالة"

# حالات الحجز
status_confirmed: "مؤكد"
status_pending: "معلق"
status_cancelled: "ملغي"
status_completed: "مكتمل"
deleted: "محذوف"

# ============ القائمة المنسدلة في الهيدر ============
# عناصر القائمة
menu_profile: "الملف الشخصي"
menu_settings: "الإعدادات"
menu_language: "اللغة"
menu_about: "حول التطبيق"
menu_logout: "تسجيل الخروج"

# للملف الشخصي
profile_title: "الملف الشخصي"
basic_info: "المعلومات الأساسية"
usage_stats: "إحصائيات الاستخدام"
actions: "الإجراءات"
change_password: "تغيير كلمة المرور"
update_email: "تحديث البريد الإلكتروني"
last_login: "آخر تسجيل دخول"
login_count: "عدد مرات الدخول"
created_date: "تاريخ الانضمام"
member_since: "عضو منذ"
current_password: "كلمة المرور الحالية"
new_password: "كلمة المرور الجديدة"
confirm_password: "تأكيد كلمة المرور"
password_changed: "تم تغيير كلمة المرور بنجاح"
incorrect_password: "كلمة المرور الحالية غير صحيحة"
passwords_dont_match: "كلمات المرور غير متطابقة"
password_too_short: "كلمة المرور يجب أن تكون 8 أحرف على الأقل"
current_email: "البريد الإلكتروني الحالي:"
new_email: "البريد الإلكتروني الجديد"
enter_email: "يرجى إدخال البريد الإلكتروني"
email_update_request: "تم إرسال طلب تحديث البريد الإلكتروني للمسؤول"
phone: "الهاتف"
department: "القسم"
airtable_view: "طريقة العرض المخصصة"

# للإعدادات
settings_title: "الإعدادات"
appearance: "المظهر"
performance: "الأداء"
advanced: "متقدم"
theme_mode: "وضع المظهر"
primary_color: "اللون الأساسي"
font_size: "حجم الخط"
preview: "معاينة"
preview_text: "هذه معاينة لإعداداتك"
auto_refresh: "التحديث التلقائي"
refresh_interval: "فترة التحديث"
enable_auto_refresh: "تفعيل التحديث التلقائي للبيانات"
records_per_page: "عدد السجلات في الصفحة"
lazy_loading: "التحميل الكسول"
enable_lazy_loading: "تحميل البيانات عند الحاجة"
developer_mode: "وضع المطور"
enable_dev_mode: "إظهار معلومات التطوير"
export_settings: "تصدير الإعدادات"
import_settings: "استيراد الإعدادات"
reset_settings: "إعادة تعيين الإعدادات"
export_to_file: "تصدير إلى ملف"
import_from_file: "استيراد من ملف"
reset_to_default: "إعادة تعيين للقيم الافتراضية"
save_settings: "حفظ الإعدادات"
settings_saved: "تم حفظ الإعدادات بنجاح"
settings_exported: "تم تصدير الإعدادات بنجاح"
settings_imported: "تم استيراد الإعدادات بنجاح"
settings_reset: "تم إعادة تعيين الإعدادات للقيم الافتراضية"
discard_changes: "تجاهل التغييرات غير المحفوظة؟"
confirm_reset: "إعادة تعيين جميع الإعدادات للقيم الافتراضية؟"

# للغة
language_title: "اختر اللغة"
language_desc: "اختر لغتك المفضلة"
current: "الحالية"

# حول التطبيق
about_title: "حول التطبيق"
build: "الإصدار"
developer: "المطور"
license: "الترخيص"
website: "الموقع"
support: "الدعم"
app_description: "FTS Travels Sales Manager هو نظام متكامل لإدارة المبيعات والحجوزات السياحية.\n\nيوفر النظام أدوات قوية لإدارة العملاء والحجوزات والتقارير المالية."
feature_not_available: "هذه الميزة غير متوفرة"
fill_all_fields: "يرجى ملء جميع الحقول"
logout_error: "حدث خطأ أثناء تسجيل الخروج"

palette: "الألوان"
choose_palette: "اختر لوحة الألوان"
select_palette: "اختر لوحة الألوان"
palette_desc: "اختر نظام الألوان المفضل لديك للوضع الفاتح"
purple_modern: "بنفسجي عصري"
blue_modern: "أزرق عصري"
emerald_modern: "زمردي عصري"
pink_modern: "وردي عصري"
orange_warm: "برتقالي دافئ"
indigo_elegant: "نيلي أنيق"
blue_classic: "أزرق كلاسيكي"
apply: "تطبيق"
palette_saved: "تم حفظ لوحة الألوان. يرجى إعادة فتح النافذة."
theme_dark: "تم تفعيل الوضع الداكن"
theme_light: "تم تفعيل الوضع الفاتح"
theme_change: "تم تغيير الثيم"
theme_change_msg: "يرجى إعادة فتح النافذة لتطبيق ألوان الثيم الجديد."

# =============================================================================
# أسماء التبويبات
# =============================================================================
basic_info: "معلومات أساسية"
trip_details: "تفاصيل الرحلة"
passenger_info: "معلومات الركاب"
contact_info: "معلومات الاتصال"
pricing_info: "معلومات الأسعار"

# =============================================================================
# أسماء الحقول - المعلومات الأساسية
# =============================================================================
customer_name: "اسم العميل"
hotel_name: "اسم الفندق"
agency: "الوكالة"
booking_number: "رقم الحجز"
room_number: "رقم الغرفة"

# =============================================================================
# أسماء الحقول - تفاصيل الرحلة
# =============================================================================
trip_name: "اسم الرحلة"
trip_date: "تاريخ الرحلة"
option: "الخيار"
destination: "الوجهة"
guide: "المرشد"
product_id: "رقم المنتج"
pickup_time: "وقت الاستقبال"
remarks: "ملاحظات"
add_ons: "إضافات"

# =============================================================================
# أسماء الحقول - معلومات الركاب
# =============================================================================
adults: "البالغين"
children: "الأطفال"
students: "الطلاب"
youth: "الشباب"
infants: "الرضع"
children_ages: "أعمار الأطفال"

# =============================================================================
# أسماء الحقول - معلومات الاتصال
# =============================================================================
phone_number: "رقم الهاتف"
email: "البريد الإلكتروني"
customer_country: "بلد العميل"

# =============================================================================
# أسماء الحقول - معلومات الأسعار
# =============================================================================
total_price_usd: "السعر الإجمالي (دولار أمريكي)"
total_price_eur: "السعر الإجمالي (يورو)"
total_price_gbp: "السعر الإجمالي (جنيه إسترليني)"
net_rate: "السعر الصافي"
currency: "العملة"
cost_egp: "التكلفة (جنيه مصري)"
collecting_on_date: "التحصيل في تاريخ الرحلة"
management_option: "خيار الإدارة"
add_on: "إضافة"

# =============================================================================
# أزرار وعناصر التحكم
# =============================================================================
search: "بحث"
clear: "مسح"
reset: "إعادة تعيين"
apply: "تطبيق"
filter: "فلتر"
export: "تصدير"
import: "استيراد"
print: "طباعة"
help: "مساعدة"
about: "حول"
settings: "إعدادات"
preferences: "التفضيلات"
language: "اللغة"
theme: "المظهر"
dark_mode: "الوضع المظلم"
light_mode: "الوضع الفاتح"

# =============================================================================
# حالات البيانات
# =============================================================================
active: "نشط"
inactive: "غير نشط"
pending: "معلق"
confirmed: "مؤكد"
cancelled: "ملغي"
completed: "مكتمل"
in_progress: "قيد التنفيذ"
draft_status: "مسودة"
published: "منشور"
archived: "مؤرشف"

# =============================================================================
# أيام الأسبوع
# =============================================================================
monday: "الاثنين"
tuesday: "الثلاثاء"
wednesday: "الأربعاء"
thursday: "الخميس"
friday: "الجمعة"
saturday: "السبت"
sunday: "الأحد"

# =============================================================================
# أشهر السنة
# =============================================================================
january: "يناير"
february: "فبراير"
march: "مارس"
april: "أبريل"
may: "مايو"
june: "يونيو"
july: "يوليو"
august: "أغسطس"
september: "سبتمبر"
october: "أكتوبر"
november: "نوفمبر"
december: "ديسمبر"

# =============================================================================
# رسائل التحقق
# =============================================================================
invalid_email: "عنوان البريد الإلكتروني غير صحيح"
invalid_phone: "رقم الهاتف غير صحيح"
invalid_date: "التاريخ غير صحيح"
invalid_number: "الرقم غير صحيح"
field_too_long: "الحقل طويل جداً"
field_too_short: "الحقل قصير جداً"
passwords_dont_match: "كلمات المرور غير متطابقة"
password_too_weak: "كلمة المرور ضعيفة"

# =============================================================================
# رسائل النجاح
# =============================================================================
data_loaded: "تم تحميل البيانات بنجاح"
settings_saved: "تم حفظ الإعدادات بنجاح"
export_completed: "تم التصدير بنجاح"
import_completed: "تم الاستيراد بنجاح"
backup_created: "تم إنشاء النسخة الاحتياطية بنجاح"
backup_restored: "تم استعادة النسخة الاحتياطية بنجاح"

# =============================================================================
# رسائل الخطأ
# =============================================================================
file_not_found: "الملف غير موجود"
access_denied: "الوصول مرفوض"
network_error: "خطأ في الشبكة"
server_error: "خطأ في الخادم"
database_error: "خطأ في قاعدة البيانات"
permission_denied: "الصلاحية مرفوضة"
invalid_credentials: "بيانات الدخول غير صحيحة"
session_expired: "انتهت صلاحية الجلسة"
file_corrupted: "الملف تالف"
disk_full: "القرص ممتلئ"
memory_error: "خطأ في الذاكرة"
timeout_error: "انتهت مهلة الانتظار"

# =============================================================================
# أنواع الملفات
# =============================================================================
document: "وثيقة"
image: "صورة"
video: "فيديو"
audio: "صوت"
spreadsheet: "جدول بيانات"
presentation: "عرض تقديمي"
pdf: "ملف PDF"
text_file: "ملف نصي"
archive: "أرشيف"
executable: "ملف تنفيذي"

# =============================================================================
# وحدات القياس
# =============================================================================
currency_usd: "دولار أمريكي"
currency_eur: "يورو"
currency_gbp: "جنيه إسترليني"
currency_egp: "جنيه مصري"
currency_sar: "ريال سعودي"
currency_aed: "درهم إماراتي"

# =============================================================================
# أنواع الأذونات
# =============================================================================
read_only: "قراءة فقط"
read_write: "قراءة وكتابة"
full_access: "وصول كامل"
admin: "مدير"
user: "مستخدم"
guest: "ضيف"

# =============================================================================
# حالات الاتصال
# =============================================================================
online: "متصل"
offline: "غير متصل"
connecting: "جاري الاتصال"
connected: "متصل"
disconnected: "منقطع"
reconnecting: "جاري إعادة الاتصال"

# =============================================================================
# أولويات المهام
# =============================================================================
high_priority: "أولوية عالية"
medium_priority: "أولوية متوسطة"
low_priority: "أولوية منخفضة"
urgent: "مستعجل"
normal: "عادي"

# =============================================================================
# حالات الطقس (للسياحة)
# =============================================================================
sunny: "مشمس"
cloudy: "غائم"
rainy: "ممطر"
windy: "عاصف"
hot: "حار"
cold: "بارد"
mild: "معتدل"

# =============================================================================
# أنواع الرحلات
# =============================================================================
day_trip: "رحلة يومية"
overnight: "رحلة ليلية"
weekend: "رحلة نهاية الأسبوع"
package_tour: "باكيج سياحي"
private_tour: "رحلة خاصة"
group_tour: "رحلة جماعية"
cultural_tour: "رحلة ثقافية"
adventure_tour: "رحلة مغامرات"
religious_tour: "رحلة دينية"
business_trip: "رحلة عمل"

# =============================================================================
# وسائل النقل
# =============================================================================
bus: "حافلة"
car: "سيارة"
van: "ميني باص"
boat: "قارب"
train: "قطار"
plane: "طائرة"
taxi: "تاكسي"
walking: "مشي"
bicycle: "دراجة"

# =============================================================================
# أنواع الإقامة
# =============================================================================
hotel: "فندق"
resort: "منتجع"
hostel: "نزل"
apartment: "شقة"
villa: "فيلا"
cruise: "رحلة بحرية"
camping: "تخييم"
bed_breakfast: "إفطار وإقامة"

# =============================================================================
# أنواع الوجبات
# =============================================================================
breakfast: "إفطار"
lunch: "غداء"
dinner: "عشاء"
snack: "وجبة خفيفة"
buffet: "بوفيه"
a_la_carte: "وجبة مفتوحة"
vegetarian: "نباتي"
halal: "حلال"
kosher: "كوشر"

# =============================================================================
# مستويات الخدمة
# =============================================================================
basic: "أساسي"
standard: "قياسي"
premium: "مميز"
luxury: "فاخر"
vip: "كبار الشخصيات"
economy: "اقتصادي"
first_class: "درجة أولى"
business_class: "درجة رجال الأعمال"

# =============================================================================
# طرق الدفع
# =============================================================================
cash: "نقداً"
credit_card: "بطاقة ائتمان"
debit_card: "بطاقة خصم"
bank_transfer: "تحويل بنكي"
paypal: "باي بال"
check: "شيك"
installments: "أقساط"
deposit: "عربون"

# =============================================================================
# حالات الحجز
# =============================================================================
booking_confirmed: "تم تأكيد الحجز"
booking_pending: "الحجز في انتظار التأكيد"
booking_cancelled: "تم إلغاء الحجز"
booking_completed: "تم إنجاز الحجز"
booking_modified: "تم تعديل الحجز"
booking_expired: "انتهت صلاحية الحجز"
booking_refunded: "تم استرداد الحجز"

# =============================================================================
# أنواع العملاء
# =============================================================================
individual: "فردي"
group: "جماعي"
corporate: "شركة"
travel_agent: "وكيل سفر"
tour_operator: "منظم رحلات"
online_booking: "حجز إلكتروني"
walk_in: "زيارة مباشرة"
referral: "إحالة"
repeat_customer: "عميل دائم"
vip_customer: "عميل مميز"

============================================================
FILE: locales\en.yaml
SIZE: 24501 characters
============================================================

# locales/en.yaml - Complete Updated Version

# Window Titles
login_title: "Login"
main_window_title: "FTS Sales Manager"
add_edit_title: "Add/Edit Booking"
view_manager_title: "View Manager"

# Login Labels
username_label: "Username"
password_label: "Password"
username_placeholder: "Enter username"
password_placeholder: "Enter password"
login_button: "Log In"
show_password: "Show"
toggle_theme: "Toggle Theme"

# Login Messages
error_empty_credentials: "Please enter username and password."
error_invalid_credentials: "Invalid username or password."
error_auth_exception: "Authentication error."
error_login_process: "Error processing login."

# ============ Menu Bar ============
# Main Menus
file_menu: "File"
edit_menu: "Edit"
view_menu: "View"
tools_menu: "Tools"
admin_menu: "Admin"
help_menu: "Help"

# File Menu Items
logout: "Logout"
export_data: "Export Data"
close: "Close"

# View Menu Items
dark_mode: "Dark Mode"
language_menu: "Language"
arabic: "العربية"
english: "English"
fullscreen: "Fullscreen"
performance_mode: "Performance Mode"

# Tools Menu Items
reports: "Reports"

# Admin Menu Items
user_management: "User Management"
config_editor: "Configuration Editor"
clear_cache: "Clear Cache"
view_logs: "View Logs"

# Help Menu Items
user_guide: "User Guide"

# Additional Confirmation Messages
confirm_logout: "Are you sure you want to logout?"
confirm_clear_cache: "Clear all cached data?"

# Additional Status Messages
performance_mode_enabled: "Performance mode enabled"
performance_mode_disabled: "Performance mode disabled"
cache_cleared: "Cache cleared successfully"
fullscreen_enabled: "Fullscreen enabled"
fullscreen_disabled: "Fullscreen disabled"

# Coming Soon Messages
coming_soon: "Coming soon"
export_coming_soon: "Export feature coming soon"
reports_coming_soon: "Reports feature coming soon"
user_management_coming_soon: "User management coming soon"
config_editor_coming_soon: "Configuration editor coming soon"
logs_viewer_coming_soon: "Logs viewer coming soon"

# User Guide
guide_add: "To add a booking: Click Add button or press Ctrl+N"
guide_edit: "To edit: Double-click on a booking or press Ctrl+E"
guide_delete: "To delete: Select bookings and press Delete"
guide_search: "To search: Use the search box or press Ctrl+F"
guide_export: "To export: Use File menu > Export or press Ctrl+S"

# About Info
app_name: "FTS Sales Manager"
developed_by: "Developed by"
logged_as: "Logged in as"
user_role: "Role"

# ============ Original Content ============

# Menus
menu_settings: "Settings"
menu_change_language: "Change Language"
menu_toggle_theme: "Toggle Theme"
menu_account: "Account"
menu_logout: "Log Out"
menu_exit: "Exit"
menu_views: "Views"
menu_view_manager: "View Manager"

# Confirmation Messages
confirm_change_language: "Change language?"
confirm_exit: "Are you sure you want to exit?"
confirm_delete: "Are you sure you want to delete this booking?"
confirm_delete_multiple: "Are you sure you want to delete {} bookings?"
confirm_close: "Confirm Close"

# Search and Status Bar
search_label: "Search:"
search_placeholder: "Type to search..."
status_loading: "Loading..."
status_load_complete: "{} records loaded."
error_loading_records: "Error loading records."
loading_data: "Loading data..."
refreshing_data: "Refreshing data..."
saving_data: "Saving data..."
processing: "Processing..."

# Action Buttons
add: "Add"
edit: "Edit"
delete: "Delete"
save: "Save"
cancel: "Cancel"
close: "Close"
refresh: "Refresh"
export: "Export"
import: "Import"
print: "Print"
apply: "Apply"
clear: "Clear"
search: "Search"
filter: "Filter"
sort: "Sort"
select_all: "Select All"
clear_selection: "Clear Selection"

# Action Messages
add_button: "➕ Add Booking"
edit_button: "✏️ Edit Booking"
delete_button: "🗑️ Delete Booking"
refresh_button: "🔄 Refresh"
export_button: "📤 Export"

# Selection Messages
error_no_selection: "Please select a record."
select_booking_edit: "Please select a booking to edit"
select_booking_delete: "Please select a booking to delete"
select_one_booking_only: "You can only edit one booking at a time"
selected_count: "Selected: {} booking(s)"
no_selection: "No selection"

# Success and Error Messages
success: "Success"
error: "Error"
warning: "Warning"
info: "Information"
success_save: "Saved successfully!"
success_update: "Updated successfully!"
success_delete: "Deleted successfully!"
error_save: "Failed to save data"
error_update: "Failed to update data"
error_delete: "Failed to delete record"
error_load: "Failed to load data"
error_add_form: "Failed to open add form"
error_edit_form: "Failed to open edit form"

# Add/Edit Window
basic_info: "Basic Information"
trip_details: "Trip Details"
passenger_info: "Passenger Information"
contact_info: "Contact Information"
pricing_info: "Pricing Information"
additional_info: "Additional Information"

# Fields
customer_name: "Customer Name"
hotel_name: "Hotel Name"
agency: "Agency"
booking_number: "Booking Number"
room_number: "Room Number"
trip_name: "Trip Name"
trip_date: "Trip Date"
option: "Option"
destination: "Destination"
guide: "Guide"
product_id: "Product ID"
pickup_time: "Pickup Time"
remarks: "Remarks"
add_ons: "Add-ons"
adults: "Adults"
children: "Children"
students: "Students"
youth: "Youth"
infants: "Infants"
children_ages: "Children Ages"
phone_number: "Phone Number"
email: "Email"
customer_country: "Customer Country"
total_price_usd: "Total Price (USD)"
total_price_eur: "Total Price (EUR)"
total_price_gbp: "Total Price (GBP)"
net_rate: "Net Rate"
currency: "Currency"
cost_egp: "Cost (EGP)"
collecting_on_date: "Collecting on Date"
management_option: "Management Option"
add_on: "Add-on"

# Validation Messages
required_field: "This field is required"
invalid_phone: "Invalid phone number"
invalid_date: "Invalid date format"
invalid_number: "Please enter a valid number"
future_date: "Date cannot be in the past"
negative_amount: "Amount cannot be negative"
invalid_email: "Invalid email format"

# Dropdowns
add_new_value: "Add new value"
enter_new_value: "Enter new value:"
value_added_successfully: "'{}' added successfully"
failed_add_value: "Failed to add value to Airtable"
dropdown_error: "Error loading dropdown values"
dropdown_manager_unavailable: "Dropdown manager is not available"
refresh_lists: "Refresh Lists"
lists_status: "Lists Status"
lists_updated: "Lists updated successfully"
update_failed: "Failed to update lists"
loading_lists: "Loading lists..."
updating_lists: "Updating lists..."
all_lists_working: "All dropdown lists are working correctly!"
dropdown_errors: "Dropdown Errors"
check_connection: "Check:\n1. Internet connection\n2. API Key and Base ID\n3. Tables exist in Airtable"

# Navigation
previous: "Previous"
next: "Next"
first_page: "First Page"
last_page: "Last Page"
page: "Page"
of: "of"
showing: "Showing"
to: "to"
total_records: "Total Records"
navigating_to: "Navigating to"

# Drafts
draft: "Draft"
save_draft: "Save as Draft"
load_draft: "Load Draft"
draft_saved: "Draft saved successfully"
draft_save_failed: "Failed to save draft"
draft_found: "Draft found"
load_draft_question: "A saved draft was found. Do you want to load it?"
unsaved_changes: "Unsaved changes"
save_draft_question: "There are unsaved changes.\n\nDo you want to save as draft?"

# Keyboard Shortcuts
shortcuts: "Shortcuts"
keyboard_shortcuts: "Keyboard Shortcuts"
required_fields: "Required fields"
change_language: "Change Language"
change_theme: "Change Theme"

# Views
view_label: "View:"
all_records: "All Records"
today_bookings: "Today's Bookings"
this_week: "This Week"
this_month: "This Month"
pending_bookings: "Pending Bookings"
confirmed_bookings: "Confirmed Bookings"
cancelled_bookings: "Cancelled Bookings"
my_bookings: "My Bookings"
team_bookings: "Team Bookings"
high_priority: "High Priority"
vip_customers: "VIP Customers"
airport_transfers: "Airport Transfers"
hotel_transfers: "Hotel Transfers"
tour_bookings: "Tour Bookings"

# View Manager
view_manager: "View Manager"
assign_views_to_users: "Assign Views to Users"
select_view: "Select View:"
apply_to_selected: "Apply to Selected"
apply_to_all_role: "Apply to All Users with Role"
apply_to_role: "Apply to Role"
select_role_and_view: "Select Role and View:"
select_view_first: "Please select a view first"
select_user_first: "Please select a user first"
select_role_and_view_first: "Please select role and view"
save_changes: "Save All Changes"
save_all_changes: "Save All Changes"
no_changes_to_save: "No changes to save"
failed_load_users: "Failed to load users"
failed_save_changes: "Failed to save changes"

# Booking Status
booking_status: "Booking Status"
status_active: "Active"
status_pending: "Pending"
status_confirmed: "Confirmed"
status_cancelled: "Cancelled"
status_completed: "Completed"

# Statistics
statistics: "Statistics"
total_bookings: "Total Bookings"
today_count: "Today's Bookings"
pending_count: "Pending Approval"

# Export
export_to_excel: "Export to Excel"
export_to_pdf: "Export to PDF"
export_success: "Export successful"
export_failed: "Export failed"
no_data_export: "No data to export"

# General Messages
please_wait: "Please wait..."
loading: "Loading..."
done: "Done"
yes: "Yes"
no: "No"
ok: "OK"
confirm: "Confirm"
back: "Back"
forward: "Forward"
help: "Help"
about: "About"
version: "Version"
copyright: "© 2024 FTS. All rights reserved."

# System Messages
system_error: "System Error"
network_error: "Network Error"
permission_denied: "Permission Denied"
session_expired: "Session Expired"
please_login_again: "Please login again"

# Date and Time
date: "Date"
time: "Time"
datetime: "Date & Time"
today: "Today"
yesterday: "Yesterday"
tomorrow: "Tomorrow"
this_week: "This Week"
last_week: "Last Week"
next_week: "Next Week"
this_month: "This Month"
last_month: "Last Month"
next_month: "Next Month"
this_year: "This Year"
last_year: "Last Year"
next_year: "Next Year"

# Days of Week
monday: "Monday"
tuesday: "Tuesday"
wednesday: "Wednesday"
thursday: "Thursday"
friday: "Friday"
saturday: "Saturday"
sunday: "Sunday"

# Months
january: "January"
february: "February"
march: "March"
april: "April"
may: "May"
june: "June"
july: "July"
august: "August"
september: "September"
october: "October"
november: "November"
december: "December"

# Navigation
nav_home: "Home"
nav_today: "Today's Bookings"
nav_pending: "Pending Bookings"
nav_confirmed: "Confirmed Bookings"
nav_reports: "Reports"

# Statistics
stats_total: "Total Bookings"
stats_today: "Today's Bookings"
stats_pending: "Pending"

# Roles
role_admin: "Administrator"
role_manager: "Manager"
role_editor: "Editor"
role_viewer: "Viewer"

# Search
search_placeholder: "Search..."

# Table column headers
booking_number: "Booking Nr."
trip_date: "Trip Date"
customer_name: "Customer Name"
hotel: "Hotel"
pickup_time: "Pickup Time"
price: "Price"
status: "Status"

# Booking statuses
status_confirmed: "Confirmed"
status_pending: "Pending"
status_cancelled: "Cancelled"
status_completed: "Completed"
deleted: "deleted"

# ============ Header Dropdown Menu ============
# Menu Items
menu_profile: "Profile"
menu_settings: "Settings"
menu_language: "Language"
menu_about: "About"
menu_logout: "Logout"

# Profile
profile_title: "User Profile"
basic_info: "Basic Information"
usage_stats: "Usage Statistics"
actions: "Actions"
change_password: "Change Password"
update_email: "Update Email"
last_login: "Last Login"
login_count: "Login Count"
created_date: "Created Date"
member_since: "Member Since"
current_password: "Current Password"
new_password: "New Password"
confirm_password: "Confirm Password"
password_changed: "Password changed successfully"
incorrect_password: "Current password is incorrect"
passwords_dont_match: "Passwords do not match"
password_too_short: "Password must be at least 8 characters"
current_email: "Current Email:"
new_email: "New Email"
enter_email: "Please enter an email address"
email_update_request: "Email update request has been sent to administrator"
phone: "Phone"
department: "Department"
airtable_view: "Assigned View"

# Settings
settings_title: "Settings"
appearance: "Appearance"
performance: "Performance"
advanced: "Advanced"
theme_mode: "Theme Mode"
primary_color: "Primary Color"
font_size: "Font Size"
preview: "Preview"
preview_text: "This is a preview of your settings"
auto_refresh: "Auto Refresh"
refresh_interval: "Refresh Interval"
enable_auto_refresh: "Enable automatic data refresh"
records_per_page: "Records per Page"
lazy_loading: "Lazy Loading"
enable_lazy_loading: "Load data on demand"
developer_mode: "Developer Mode"
enable_dev_mode: "Show debug information"
export_settings: "Export Settings"
import_settings: "Import Settings"
reset_settings: "Reset Settings"
export_to_file: "Export to File"
import_from_file: "Import from File"
reset_to_default: "Reset to Default"
save_settings: "Save Settings"
settings_saved: "Settings saved successfully"
settings_exported: "Settings exported successfully"
settings_imported: "Settings imported successfully"
settings_reset: "Settings reset to default"
discard_changes: "Discard unsaved changes?"
confirm_reset: "Reset all settings to default values?"

# Language
language_title: "Select Language"
language_desc: "Choose your preferred language"
current: "Current"

# About
about_title: "About"
build: "Build"
developer: "Developer"
license: "License"
website: "Website"
support: "Support"
app_description: "FTS Travels Sales Manager is an integrated system for managing tourism sales and bookings.\n\nThe system provides powerful tools for managing customers, bookings, and financial reports."
feature_not_available: "This feature is not available"
fill_all_fields: "Please fill all fields"
logout_error: "An error occurred during logout"

palette: "Colors"
choose_palette: "Choose Color Palette"
select_palette: "Select Color Palette"
palette_desc: "Choose your preferred color scheme for light theme"
purple_modern: "Modern Purple"
blue_modern: "Modern Blue"
emerald_modern: "Modern Emerald"
pink_modern: "Modern Pink"
orange_warm: "Warm Orange"
indigo_elegant: "Elegant Indigo"
blue_classic: "Classic Blue"
apply: "Apply"
palette_saved: "Color palette saved. Please reopen the window."
theme_dark: "Dark theme activated"
theme_light: "Light theme activated"
theme_change: "Theme Changed"
theme_change_msg: "Please reopen the window to apply the new theme colors."

# =============================================================================
# Tab Names
# =============================================================================
basic_info: "Basic Information"
trip_details: "Trip Details"
passenger_info: "Passenger Information"
contact_info: "Contact Information"
pricing_info: "Pricing Information"

# =============================================================================
# Field Names - Basic Information
# =============================================================================
customer_name: "Customer Name"
hotel_name: "Hotel Name"
agency: "Agency"
booking_number: "Booking Number"
room_number: "Room Number"

# =============================================================================
# Field Names - Trip Details
# =============================================================================
trip_name: "Trip Name"
trip_date: "Trip Date"
option: "Option"
destination: "Destination"
guide: "Guide"
product_id: "Product ID"
pickup_time: "Pickup Time"
remarks: "Remarks"
add_ons: "Add-ons"

# =============================================================================
# Field Names - Passenger Information
# =============================================================================
adults: "Adults"
children: "Children"
students: "Students"
youth: "Youth"
infants: "Infants"
children_ages: "Children Ages"

# =============================================================================
# Field Names - Contact Information
# =============================================================================
phone_number: "Phone Number"
email: "Email"
customer_country: "Customer Country"

# =============================================================================
# Field Names - Pricing Information
# =============================================================================
total_price_usd: "Total Price (USD)"
total_price_eur: "Total Price (EUR)"
total_price_gbp: "Total Price (GBP)"
net_rate: "Net Rate"
currency: "Currency"
cost_egp: "Cost (EGP)"
collecting_on_date: "Collecting on Trip Date"
management_option: "Management Option"
add_on: "Add-on"

# =============================================================================
# Buttons and Controls
# =============================================================================
search: "Search"
clear: "Clear"
reset: "Reset"
apply: "Apply"
filter: "Filter"
export: "Export"
import: "Import"
print: "Print"
help: "Help"
about: "About"
settings: "Settings"
preferences: "Preferences"
language: "Language"
theme: "Theme"
dark_mode: "Dark Mode"
light_mode: "Light Mode"

# =============================================================================
# Data States
# =============================================================================
active: "Active"
inactive: "Inactive"
pending: "Pending"
confirmed: "Confirmed"
cancelled: "Cancelled"
completed: "Completed"
in_progress: "In Progress"
draft_status: "Draft"
published: "Published"
archived: "Archived"

# =============================================================================
# Days of Week
# =============================================================================
monday: "Monday"
tuesday: "Tuesday"
wednesday: "Wednesday"
thursday: "Thursday"
friday: "Friday"
saturday: "Saturday"
sunday: "Sunday"

# =============================================================================
# Months of Year
# =============================================================================
january: "January"
february: "February"
march: "March"
april: "April"
may: "May"
june: "June"
july: "July"
august: "August"
september: "September"
october: "October"
november: "November"
december: "December"

# =============================================================================
# Validation Messages
# =============================================================================
invalid_email: "Invalid email address"
invalid_phone: "Invalid phone number"
invalid_date: "Invalid date"
invalid_number: "Invalid number"
field_too_long: "Field is too long"
field_too_short: "Field is too short"
passwords_dont_match: "Passwords don't match"
password_too_weak: "Password is too weak"

# =============================================================================
# Success Messages
# =============================================================================
data_loaded: "Data loaded successfully"
settings_saved: "Settings saved successfully"
export_completed: "Export completed successfully"
import_completed: "Import completed successfully"
backup_created: "Backup created successfully"
backup_restored: "Backup restored successfully"

# =============================================================================
# Error Messages
# =============================================================================
file_not_found: "File not found"
access_denied: "Access denied"
network_error: "Network error"
server_error: "Server error"
database_error: "Database error"
permission_denied: "Permission denied"
invalid_credentials: "Invalid credentials"
session_expired: "Session expired"
file_corrupted: "File corrupted"
disk_full: "Disk full"
memory_error: "Memory error"
timeout_error: "Timeout error"

# =============================================================================
# File Types
# =============================================================================
document: "Document"
image: "Image"
video: "Video"
audio: "Audio"
spreadsheet: "Spreadsheet"
presentation: "Presentation"
pdf: "PDF File"
text_file: "Text File"
archive: "Archive"
executable: "Executable"

# =============================================================================
# Units of Measurement
# =============================================================================
currency_usd: "US Dollar"
currency_eur: "Euro"
currency_gbp: "British Pound"
currency_egp: "Egyptian Pound"
currency_sar: "Saudi Riyal"
currency_aed: "UAE Dirham"

# =============================================================================
# Permission Types
# =============================================================================
read_only: "Read Only"
read_write: "Read & Write"
full_access: "Full Access"
admin: "Administrator"
user: "User"
guest: "Guest"

# =============================================================================
# Connection States
# =============================================================================
online: "Online"
offline: "Offline"
connecting: "Connecting"
connected: "Connected"
disconnected: "Disconnected"
reconnecting: "Reconnecting"

# =============================================================================
# Task Priorities
# =============================================================================
high_priority: "High Priority"
medium_priority: "Medium Priority"
low_priority: "Low Priority"
urgent: "Urgent"
normal: "Normal"

# =============================================================================
# Weather Conditions (for Tourism)
# =============================================================================
sunny: "Sunny"
cloudy: "Cloudy"
rainy: "Rainy"
windy: "Windy"
hot: "Hot"
cold: "Cold"
mild: "Mild"

# =============================================================================
# Trip Types
# =============================================================================
day_trip: "Day Trip"
overnight: "Overnight Trip"
weekend: "Weekend Trip"
package_tour: "Package Tour"
private_tour: "Private Tour"
group_tour: "Group Tour"
cultural_tour: "Cultural Tour"
adventure_tour: "Adventure Tour"
religious_tour: "Religious Tour"
business_trip: "Business Trip"

# =============================================================================
# Transportation
# =============================================================================
bus: "Bus"
car: "Car"
van: "Van"
boat: "Boat"
train: "Train"
plane: "Plane"
taxi: "Taxi"
walking: "Walking"
bicycle: "Bicycle"

# =============================================================================
# Accommodation Types
# =============================================================================
hotel: "Hotel"
resort: "Resort"
hostel: "Hostel"
apartment: "Apartment"
villa: "Villa"
cruise: "Cruise"
camping: "Camping"
bed_breakfast: "Bed & Breakfast"

# =============================================================================
# Meal Types
# =============================================================================
breakfast: "Breakfast"
lunch: "Lunch"
dinner: "Dinner"
snack: "Snack"
buffet: "Buffet"
a_la_carte: "A la Carte"
vegetarian: "Vegetarian"
halal: "Halal"
kosher: "Kosher"

# =============================================================================
# Service Levels
# =============================================================================
basic: "Basic"
standard: "Standard"
premium: "Premium"
luxury: "Luxury"
vip: "VIP"
economy: "Economy"
first_class: "First Class"
business_class: "Business Class"

# =============================================================================
# Payment Methods
# =============================================================================
cash: "Cash"
credit_card: "Credit Card"
debit_card: "Debit Card"
bank_transfer: "Bank Transfer"
paypal: "PayPal"
check: "Check"
installments: "Installments"
deposit: "Deposit"

# =============================================================================
# Booking Status
# =============================================================================
booking_confirmed: "Booking Confirmed"
booking_pending: "Booking Pending"
booking_cancelled: "Booking Cancelled"
booking_completed: "Booking Completed"
booking_modified: "Booking Modified"
booking_expired: "Booking Expired"
booking_refunded: "Booking Refunded"

# =============================================================================
# Customer Types
# =============================================================================
individual: "Individual"
group: "Group"
corporate: "Corporate"
travel_agent: "Travel Agent"
tour_operator: "Tour Operator"
online_booking: "Online Booking"
walk_in: "Walk-in"
referral: "Referral"
repeat_customer: "Repeat Customer"
vip_customer: "VIP Customer"

============================================================
FILE: utils\async_operations.py
SIZE: 736 characters
============================================================

# utils/async_operations.py
from concurrent.futures import ThreadPoolExecutor
import threading

class AsyncOperationManager:
    def __init__(self, max_workers=4):
        self.executor = ThreadPoolExecutor(max_workers=max_workers)
        self.pending_operations = {}

    def run_async(self, operation_id: str, func, *args, **kwargs):
        """تشغيل عملية بشكل غير متزامن"""
        if operation_id in self.pending_operations:
            return self.pending_operations[operation_id]

        future = self.executor.submit(func, *args, **kwargs)
        self.pending_operations[operation_id] = future
        return future

    def shutdown(self):
        """إيقاف المدير"""
        self.executor.shutdown(wait=True)

============================================================
FILE: utils\error_handler.py
SIZE: 1884 characters
============================================================

# utils/error_handler.py
from functools import wraps
import logging
import traceback
from typing import Callable, Optional
from tkinter import messagebox

def error_handler(error_key: str = "error_general", show_dialog: bool = True):
    """مُزخرف لمعالجة الأخطاء"""
    def decorator(func: Callable) -> Callable:
        @wraps(func)
        def wrapper(self, *args, **kwargs):
            try:
                return func(self, *args, **kwargs)
            except Exception as e:
                # تسجيل الخطأ
                logger.error(f"Error in {func.__name__}: {str(e)}")
                logger.error(traceback.format_exc())

                # تحديث شريط الحالة
                if hasattr(self, 'status_bar'):
                    error_msg = self.lang_manager.get(error_key, str(e))
                    self.status_bar.set_status(error_msg, "error")

                # عرض رسالة خطأ
                if show_dialog and hasattr(self, 'lang_manager'):
                    messagebox.showerror(
                        self.lang_manager.get("error", "Error"),
                        error_msg
                    )

                # وميض النافذة
                if hasattr(self, 'winfo_exists') and self.winfo_exists():
                    try:
                        from utils.window_manager import WindowManager
                        WindowManager.flash_window(self, count=2, interval=300)
                    except:
                        pass

                # إطلاق حدث خطأ
                if hasattr(self, 'event_bus') and self.event_bus:
                    self.event_bus.emit("error_occurred", {
                        "function": func.__name__,
                        "error": str(e)
                    })

                return None
        return wrapper
    return decorator

============================================================
FILE: utils\image_utils.py
SIZE: 8538 characters
============================================================

# -*- coding: utf-8 -*-
"""
utils/image_utils.py

أدوات مساعدة لتحميل وإدارة الصور في CustomTkinter
"""

import os
import sys
from PIL import Image
import customtkinter as ctk
from typing import Optional, Tuple, Union
import logging

logger = logging.getLogger(__name__)


class ImageLoader:
    """فئة مساعدة لتحميل الصور بطريقة آمنة"""

    # ذاكرة تخزين مؤقت للصور المحملة
    _image_cache = {}

    @staticmethod
    def load_image(
        path: str,
        size: Optional[Tuple[int, int]] = None,
        maintain_aspect_ratio: bool = True
    ) -> Optional[ctk.CTkImage]:
        """
        تحميل صورة وتحويلها إلى CTkImage

        Args:
            path: مسار الصورة
            size: الحجم المطلوب (width, height)
            maintain_aspect_ratio: الحفاظ على نسبة العرض إلى الارتفاع

        Returns:
            CTkImage أو None في حالة الفشل
        """
        # التحقق من الذاكرة المؤقتة
        cache_key = f"{path}_{size}_{maintain_aspect_ratio}"
        if cache_key in ImageLoader._image_cache:
            return ImageLoader._image_cache[cache_key]

        try:
            # التحقق من وجود الملف
            if not os.path.exists(path):
                logger.warning(f"ملف الصورة غير موجود: {path}")
                return None

            # فتح الصورة
            pil_image = Image.open(path)

            # تحويل إلى RGBA للحصول على أفضل توافق
            if pil_image.mode != 'RGBA':
                # إنشاء صورة RGBA جديدة
                rgba_image = Image.new('RGBA', pil_image.size, (255, 255, 255, 255))

                # لصق الصورة الأصلية
                if pil_image.mode == 'P':  # صورة مفهرسة
                    pil_image = pil_image.convert('RGBA')
                rgba_image.paste(pil_image, (0, 0))
                pil_image = rgba_image

            # تغيير الحجم إذا تم تحديده
            if size:
                if maintain_aspect_ratio:
                    pil_image.thumbnail(size, Image.Resampling.LANCZOS)
                    # حساب الحجم الفعلي بعد thumbnail
                    actual_size = pil_image.size
                else:
                    pil_image = pil_image.resize(size, Image.Resampling.LANCZOS)
                    actual_size = size
            else:
                actual_size = pil_image.size

            # إنشاء CTkImage
            ctk_image = ctk.CTkImage(
                light_image=pil_image,
                dark_image=pil_image,
                size=actual_size
            )

            # حفظ في الذاكرة المؤقتة
            ImageLoader._image_cache[cache_key] = ctk_image

            logger.info(f"تم تحميل الصورة بنجاح: {path}")
            return ctk_image

        except Exception as e:
            logger.error(f"فشل تحميل الصورة {path}: {e}")
            return None

    @staticmethod
    def load_icon(
        icon_name: str,
        size: Tuple[int, int] = (24, 24),
        directories: Optional[list] = None
    ) -> Optional[ctk.CTkImage]:
        """
        تحميل أيقونة من مجلدات متعددة

        Args:
            icon_name: اسم الأيقونة (بدون امتداد)
            size: حجم الأيقونة
            directories: قائمة المجلدات للبحث فيها

        Returns:
            CTkImage أو None
        """
        if directories is None:
            directories = [
                "resources/icons",
                "assets/icons",
                "icons",
                "resources",
                "assets"
            ]

        extensions = ['.png', '.jpg', '.jpeg', '.ico', '.gif']

        for directory in directories:
            for ext in extensions:
                path = os.path.join(directory, f"{icon_name}{ext}")
                if os.path.exists(path):
                    return ImageLoader.load_image(path, size)

        logger.warning(f"لم يتم العثور على الأيقونة: {icon_name}")
        return None

    @staticmethod
    def create_placeholder_image(
        size: Tuple[int, int] = (50, 50),
        color: str = "#cccccc",
        text: str = "?"
    ) -> ctk.CTkImage:
        """
        إنشاء صورة بديلة عند فشل تحميل الصورة الأصلية

        Args:
            size: حجم الصورة
            color: لون الخلفية
            text: النص المعروض

        Returns:
            CTkImage
        """
        # إنشاء صورة جديدة
        image = Image.new('RGBA', size, color)

        # يمكن إضافة نص أو رسومات هنا إذا لزم الأمر
        # (يتطلب ImageDraw)

        return ctk.CTkImage(
            light_image=image,
            dark_image=image,
            size=size
        )

    @staticmethod
    def clear_cache():
        """مسح الذاكرة المؤقتة للصور"""
        ImageLoader._image_cache.clear()
        logger.info("تم مسح ذاكرة التخزين المؤقت للصور")


class IconManager:
    """مدير الأيقونات للتطبيق"""

    # أيقونات التطبيق الافتراضية
    DEFAULT_ICONS = {
        "app": "✈️",
        "add": "➕",
        "edit": "✏️",
        "delete": "🗑️",
        "save": "💾",
        "cancel": "❌",
        "refresh": "🔄",
        "search": "🔍",
        "settings": "⚙️",
        "user": "👤",
        "logout": "🚪",
        "info": "ℹ️",
        "warning": "⚠️",
        "error": "❌",
        "success": "✅",
        "calendar": "📅",
        "clock": "🕐",
        "money": "💰",
        "document": "📄",
        "folder": "📁",
        "email": "📧",
        "phone": "📞",
        "location": "📍",
        "star": "⭐",
        "heart": "❤️"
    }

    @staticmethod
    def get_icon(name: str, fallback: str = "❓") -> str:
        """الحصول على أيقونة إيموجي"""
        return IconManager.DEFAULT_ICONS.get(name, fallback)

    @staticmethod
    def create_icon_button(
        parent,
        icon_name: str,
        text: str = "",
        command = None,
        size: Tuple[int, int] = (40, 40),
        **kwargs
    ) -> ctk.CTkButton:
        """
        إنشاء زر مع أيقونة

        Args:
            parent: الحاوية الأب
            icon_name: اسم الأيقونة
            text: نص الزر (اختياري)
            command: دالة الأمر
            size: حجم الزر
            **kwargs: خيارات إضافية للزر

        Returns:
            CTkButton
        """
        # محاولة تحميل صورة الأيقونة
        icon_image = ImageLoader.load_icon(icon_name, size=(24, 24))

        if icon_image:
            # إنشاء زر مع صورة
            button = ctk.CTkButton(
                parent,
                image=icon_image,
                text=text,
                command=command,
                width=size[0],
                height=size[1],
                **kwargs
            )
        else:
            # استخدام إيموجي كبديل
            emoji = IconManager.get_icon(icon_name)
            button_text = f"{emoji} {text}" if text else emoji
            button = ctk.CTkButton(
                parent,
                text=button_text,
                command=command,
                width=size[0],
                height=size[1],
                **kwargs
            )

        return button


def setup_window_icon(window, icon_paths: Optional[list] = None):
    """
    تعيين أيقونة النافذة

    Args:
        window: نافذة CTk أو Tk
        icon_paths: قائمة مسارات الأيقونات للمحاولة
    """
    if icon_paths is None:
        icon_paths = [
            "resources/app_icon.ico",
            "resources/icon.ico",
            "assets/icon.ico",
            "resources/app_icon.png",
            "resources/icon.png",
            "assets/icon.png"
        ]

    for path in icon_paths:
        try:
            if os.path.exists(path):
                if path.endswith('.ico'):
                    # استخدام ملف ICO مباشرة
                    window.iconbitmap(path)
                    logger.info(f"تم تعيين أيقونة النافذة: {path}")
                    return True
                else:
                    # تحويل PNG إلى PhotoImage
                    # ملاحظة: iconphoto يتطلب PhotoImage وليس CTkImage
                    from tkinter import PhotoImage
                    icon = PhotoImage(file=path)
                    window.iconphoto(False, icon)
                    logger.info(f"تم تعيين أيقونة النافذة: {path}")
                    return True
        except Exception as e:
            logger.debug(f"فشل تعيين الأيقونة {path}: {e}")
            continue

    logger.warning("لم يتم العثور على أيقونة مناسبة للنافذة")
    return False

============================================================
FILE: utils\login_visual_effects.py
SIZE: 11479 characters
============================================================

# -*- coding: utf-8 -*-
"""
utils/login_visual_effects.py

تأثيرات بصرية وحركات متقدمة لنافذة تسجيل الدخول
Advanced Visual Effects and Animations for Login Window
"""

import customtkinter as ctk
from typing import Optional, Tuple, Callable
import threading
import time
import math

class LoginVisualEffects:
    """كلاس للتأثيرات البصرية المتقدمة"""

    @staticmethod
    def create_gradient_frame(parent, colors: Tuple[str, str], orientation='vertical', **kwargs):
        """إنشاء إطار بتدرج لوني"""
        # customtkinter لا يدعم التدرجات مباشرة، لذا نستخدم لون واحد
        # يمكن استخدام Canvas للتدرجات المعقدة
        frame = ctk.CTkFrame(parent, fg_color=colors[0], **kwargs)
        return frame

    @staticmethod
    def add_hover_effect(widget, normal_color: str, hover_color: str,
                        scale_factor: float = 1.05, duration: int = 200):
        """إضافة تأثير hover متقدم"""
        original_width = None
        original_height = None

        def on_enter(event):
            nonlocal original_width, original_height
            try:
                # حفظ الأبعاد الأصلية
                if hasattr(widget, 'cget'):
                    original_width = widget.cget('width')
                    original_height = widget.cget('height')

                # تغيير اللون
                if hasattr(widget, 'configure'):
                    if 'fg_color' in widget.configure():
                        widget.configure(fg_color=hover_color)

                # تأثير التكبير (محاكاة)
                if original_width and original_height and scale_factor > 1:
                    new_width = int(original_width * scale_factor)
                    new_height = int(original_height * scale_factor)
                    # لا يمكن تطبيق التكبير الفعلي في customtkinter

            except Exception as e:
                pass

        def on_leave(event):
            try:
                # إعادة اللون الأصلي
                if hasattr(widget, 'configure'):
                    if 'fg_color' in widget.configure():
                        widget.configure(fg_color=normal_color)

            except Exception as e:
                pass

        widget.bind("<Enter>", on_enter)
        widget.bind("<Leave>", on_leave)

    @staticmethod
    def create_shadow_effect(widget, parent, shadow_color='#00000020',
                           offset_x=0, offset_y=4, blur_radius=10):
        """محاكاة تأثير الظل"""
        # إنشاء إطار خلفي للظل
        shadow_frame = ctk.CTkFrame(
            parent,
            fg_color=shadow_color,
            corner_radius=widget.cget('corner_radius') if hasattr(widget, 'cget') else 0
        )

        # وضع الظل خلف العنصر
        shadow_frame.place(
            in_=widget,
            x=offset_x,
            y=offset_y,
            relwidth=1,
            relheight=1
        )

        # رفع العنصر الأصلي فوق الظل
        widget.lift()

        return shadow_frame

    @staticmethod
    def animate_fade_in(widget, duration: int = 500, steps: int = 20):
        """تأثير الظهور التدريجي"""
        # customtkinter لا يدعم transparency مباشرة
        # لذا نحاكي التأثير بإظهار العنصر تدريجياً

        def fade_animation():
            widget.pack_forget()
            time.sleep(0.1)
            widget.pack()

        thread = threading.Thread(target=fade_animation, daemon=True)
        thread.start()

    @staticmethod
    def create_loading_animation(parent, size: int = 40, color: str = '#2563eb'):
        """إنشاء رسوم متحركة للتحميل"""
        loading_frame = ctk.CTkFrame(parent, fg_color="transparent")

        # دائرة التحميل
        spinner = ctk.CTkProgressBar(
            loading_frame,
            mode="indeterminate",
            width=size * 3,
            height=size // 4,
            progress_color=color
        )
        spinner.pack()
        spinner.start()

        # نص التحميل
        loading_text = ctk.CTkLabel(
            loading_frame,
            text="Loading...",
            font=ctk.CTkFont(size=12),
            text_color=color
        )
        loading_text.pack(pady=(5, 0))

        return loading_frame, spinner

    @staticmethod
    def pulse_effect(widget, color1: str, color2: str, duration: int = 1000):
        """تأثير النبض للعناصر المهمة"""
        def pulse():
            toggle = True
            while True:
                try:
                    if hasattr(widget, 'winfo_exists') and widget.winfo_exists():
                        color = color1 if toggle else color2
                        widget.configure(fg_color=color)
                        toggle = not toggle
                        time.sleep(duration / 2000)  # تحويل إلى ثواني
                    else:
                        break
                except:
                    break

        thread = threading.Thread(target=pulse, daemon=True)
        thread.start()

    @staticmethod
    def create_ripple_effect(button, ripple_color: str = '#ffffff40'):
        """تأثير التموج عند النقر"""
        def on_click(event):
            # محاكاة بسيطة للتأثير
            original_color = button.cget('fg_color')
            button.configure(fg_color=ripple_color)
            button.after(200, lambda: button.configure(fg_color=original_color))

        button.bind("<Button-1>", on_click)

    @staticmethod
    def shake_effect(widget, amplitude: int = 10, duration: int = 500):
        """تأثير الاهتزاز للأخطاء"""
        original_x = widget.winfo_x()

        def shake():
            steps = 10
            for i in range(steps):
                if not widget.winfo_exists():
                    break

                # حساب الإزاحة
                progress = i / steps
                offset = int(amplitude * math.sin(progress * math.pi * 4) * (1 - progress))

                # تطبيق الإزاحة
                widget.place(x=original_x + offset)
                time.sleep(duration / steps / 1000)

            # إعادة للموضع الأصلي
            if widget.winfo_exists():
                widget.place(x=original_x)

        thread = threading.Thread(target=shake, daemon=True)
        thread.start()

    @staticmethod
    def create_tooltip(widget, text: str, delay: int = 1000):
        """إنشاء تلميح أداة احترافي"""
        tooltip = None

        def show_tooltip(event):
            nonlocal tooltip

            # إنشاء نافذة التلميح
            tooltip = ctk.CTkToplevel(widget)
            tooltip.withdraw()
            tooltip.overrideredirect(True)

            # تصميم التلميح
            tooltip_label = ctk.CTkLabel(
                tooltip,
                text=text,
                font=ctk.CTkFont(size=11),
                fg_color='#1e293b',
                text_color='white',
                corner_radius=6,
                padx=10,
                pady=5
            )
            tooltip_label.pack()

            # حساب الموضع
            x = widget.winfo_rootx() + widget.winfo_width() // 2
            y = widget.winfo_rooty() - 30

            tooltip.geometry(f"+{x}+{y}")
            tooltip.deiconify()

        def hide_tooltip(event):
            nonlocal tooltip
            if tooltip:
                tooltip.destroy()
                tooltip = None

        widget.bind("<Enter>", lambda e: widget.after(delay, lambda: show_tooltip(e)))
        widget.bind("<Leave>", hide_tooltip)

    @staticmethod
    def apply_glass_effect(frame):
        """تطبيق تأثير الزجاج (glassmorphism)"""
        # customtkinter لا يدعم الشفافية الحقيقية
        # لكن يمكن محاكاة التأثير بالألوان
        frame.configure(
            fg_color='#ffffff10',  # شبه شفاف
            border_width=1,
            border_color='#ffffff30'
        )

    @staticmethod
    def create_gradient_button(parent, text: str, colors: Tuple[str, str], **kwargs):
        """إنشاء زر بتدرج لوني"""
        # استخدام اللون الأول كلون أساسي واللون الثاني للـ hover
        button = ctk.CTkButton(
            parent,
            text=text,
            fg_color=colors[0],
            hover_color=colors[1],
            **kwargs
        )

        # إضافة تأثيرات إضافية
        LoginVisualEffects.create_ripple_effect(button)

        return button

    @staticmethod
    def create_animated_entry(parent, placeholder: str, **kwargs):
        """إنشاء حقل إدخال مع رسوم متحركة"""
        entry = ctk.CTkEntry(parent, placeholder_text=placeholder, **kwargs)

        # تأثير التركيز
        def on_focus_in(event):
            if hasattr(entry, 'configure'):
                entry.configure(border_width=2)

        def on_focus_out(event):
            if hasattr(entry, 'configure'):
                entry.configure(border_width=1)

        entry.bind("<FocusIn>", on_focus_in)
        entry.bind("<FocusOut>", on_focus_out)

        return entry

    @staticmethod
    def create_success_animation(parent, message: str = "Success!", duration: int = 2000):
        """رسوم متحركة للنجاح"""
        success_frame = ctk.CTkFrame(
            parent,
            fg_color='#10b981',
            corner_radius=10
        )

        # أيقونة النجاح
        icon_label = ctk.CTkLabel(
            success_frame,
            text="✓",
            font=ctk.CTkFont(size=30, weight="bold"),
            text_color="white"
        )
        icon_label.pack(pady=(10, 5))

        # رسالة النجاح
        message_label = ctk.CTkLabel(
            success_frame,
            text=message,
            font=ctk.CTkFont(size=14),
            text_color="white"
        )
        message_label.pack(pady=(0, 10), padx=20)

        # إظهار مؤقت
        success_frame.pack(pady=20)
        success_frame.after(duration, success_frame.destroy)

        return success_frame

# دوال مساعدة لتطبيق التأثيرات على نافذة تسجيل الدخول
def enhance_login_window(login_window):
    """تطبيق جميع التحسينات البصرية على نافذة تسجيل الدخول"""
    effects = LoginVisualEffects()

    # تطبيق تأثيرات على الأزرار
    if hasattr(login_window, 'btn_login'):
        effects.add_hover_effect(
            login_window.btn_login,
            '#2563eb',
            '#1d4ed8',
            scale_factor=1.02
        )
        effects.create_ripple_effect(login_window.btn_login)
        effects.create_tooltip(
            login_window.btn_login,
            "Press Enter to login quickly"
        )

    if hasattr(login_window, 'btn_cancel'):
        effects.add_hover_effect(
            login_window.btn_cancel,
            'transparent',
            '#fee2e2'
        )

    # تطبيق تأثيرات على حقول الإدخال
    if hasattr(login_window, 'entry_username'):
        effects.create_tooltip(
            login_window.entry_username,
            "Enter your registered username"
        )

    if hasattr(login_window, 'entry_password'):
        effects.create_tooltip(
            login_window.entry_password,
            "Enter your secure password"
        )

    # تطبيق تأثير الظهور التدريجي
    if hasattr(login_window, 'scrollable_frame'):
        effects.animate_fade_in(login_window.scrollable_frame)

    return login_window

============================================================
FILE: utils\threading_utils.py
SIZE: 5475 characters
============================================================

# -*- coding: utf-8 -*-
"""
utils/threading_utils.py

أدوات للتعامل مع الخيوط (Threading) في تطبيق Tkinter
"""

import threading
import queue
from typing import Callable, Any, Optional
import tkinter as tk
from core.logger import logger


class GUIUpdater:
    """فئة لتحديث واجهة المستخدم من خيوط مختلفة بشكل آمن"""

    def __init__(self):
        self.update_queue = queue.Queue()
        self.root_widget = None
        self.is_running = True

    def set_root_widget(self, widget):
        """تعيين النافذة الرئيسية"""
        self.root_widget = widget

    def schedule_update(self, func: Callable, *args, **kwargs):
        """جدولة تحديث في الخيط الرئيسي"""
        if self.root_widget and self.is_running:
            try:
                self.root_widget.after(0, func, *args, **kwargs)
            except Exception as e:
                logger.error(f"خطأ في جدولة التحديث: {e}")

    def stop(self):
        """إيقاف المحدث"""
        self.is_running = False


class ThreadPool:
    """مجموعة خيوط بسيطة لتنفيذ المهام"""

    def __init__(self, max_workers: int = 5):
        self.max_workers = max_workers
        self.tasks_queue = queue.Queue()
        self.workers = []
        self.is_running = True
        self._start_workers()

    def _start_workers(self):
        """بدء خيوط العمل"""
        for i in range(self.max_workers):
            worker = threading.Thread(target=self._worker_loop, daemon=True)
            worker.start()
            self.workers.append(worker)

    def _worker_loop(self):
        """حلقة العمل للخيط"""
        while self.is_running:
            try:
                task = self.tasks_queue.get(timeout=1)
                if task is None:
                    break

                func, args, kwargs, callback, error_callback = task

                try:
                    result = func(*args, **kwargs)
                    if callback and _gui_updater:
                        _gui_updater.schedule_update(callback, result)
                except Exception as e:
                    logger.error(f"خطأ في تنفيذ المهمة: {e}", exc_info=True)
                    if error_callback and _gui_updater:
                        _gui_updater.schedule_update(error_callback, e)

                self.tasks_queue.task_done()

            except queue.Empty:
                continue
            except Exception as e:
                logger.error(f"خطأ في حلقة العمل: {e}", exc_info=True)

    def schedule_task(self, func: Callable, args=None, kwargs=None,
                     callback: Optional[Callable] = None,
                     error_callback: Optional[Callable] = None):
        """جدولة مهمة للتنفيذ"""
        args = args or ()
        kwargs = kwargs or {}
        task = (func, args, kwargs, callback, error_callback)
        self.tasks_queue.put(task)

    def shutdown(self):
        """إيقاف مجموعة الخيوط"""
        self.is_running = False

        # إضافة مهام فارغة لإيقاظ الخيوط
        for _ in self.workers:
            self.tasks_queue.put(None)

        # انتظار انتهاء الخيوط
        for worker in self.workers:
            worker.join(timeout=2)


# المتغيرات العامة
_gui_updater: Optional[GUIUpdater] = None
_thread_pool: Optional[ThreadPool] = None


def initialize_threading(root_widget):
    """تهيئة نظام الخيوط"""
    global _gui_updater, _thread_pool

    _gui_updater = GUIUpdater()
    _gui_updater.set_root_widget(root_widget)

    _thread_pool = ThreadPool(max_workers=3)

    logger.info("تم تهيئة نظام الخيوط")


def shutdown_threading():
    """إيقاف نظام الخيوط"""
    global _gui_updater, _thread_pool

    if _gui_updater:
        _gui_updater.stop()
        _gui_updater = None

    if _thread_pool:
        _thread_pool.shutdown()
        _thread_pool = None

    logger.info("تم إيقاف نظام الخيوط")


def get_gui_updater() -> Optional[GUIUpdater]:
    """الحصول على محدث واجهة المستخدم"""
    return _gui_updater


def get_thread_pool() -> Optional[ThreadPool]:
    """الحصول على مجموعة الخيوط"""
    return _thread_pool


def run_in_thread(func: Callable, args=None, kwargs=None,
                 callback: Optional[Callable] = None,
                 error_callback: Optional[Callable] = None):
    """تشغيل دالة في خيط منفصل"""
    if _thread_pool:
        _thread_pool.schedule_task(func, args, kwargs, callback, error_callback)
    else:
        # تشغيل في خيط جديد مباشرة
        def wrapper():
            try:
                result = func(*(args or ()), **(kwargs or {}))
                if callback and _gui_updater:
                    _gui_updater.schedule_update(callback, result)
            except Exception as e:
                logger.error(f"خطأ في تنفيذ المهمة: {e}", exc_info=True)
                if error_callback and _gui_updater:
                    _gui_updater.schedule_update(error_callback, e)

        thread = threading.Thread(target=wrapper, daemon=True)
        thread.start()


def safe_gui_update(widget, func: Callable, *args, **kwargs):
    """تحديث آمن لواجهة المستخدم"""
    try:
        if widget and widget.winfo_exists():
            widget.after(0, func, *args, **kwargs)
    except tk.TclError:
        # النافذة محذوفة
        pass
    except Exception as e:
        logger.error(f"خطأ في تحديث الواجهة: {e}")

============================================================
FILE: utils\validators.py
SIZE: 12546 characters
============================================================

# -*- coding: utf-8 -*-
"""
utils/validators.py

التحقق من صحة المدخلات
"""

import re
from typing import Tuple, Dict, List, Optional
import string
from datetime import datetime

from core.logger import logger


class InputValidator:
    """مدير التحقق من المدخلات"""

    # Common patterns
    USERNAME_PATTERN = re.compile(r'^[a-zA-Z0-9_.-]+$')
    EMAIL_PATTERN = re.compile(
        r'^[a-zA-Z0-9._%+-]+@[a-zA-Z0-9.-]+\.[a-zA-Z]{2,}$'
    )
    PHONE_PATTERN = re.compile(r'^\+?[0-9\s\-\(\)]+$')

    # Common weak passwords
    COMMON_PASSWORDS = {
        'password', '123456', '123456789', 'qwerty', 'abc123',
        'password1', 'password123', 'admin', 'letmein', 'welcome',
        'monkey', '1234567890', 'qwertyuiop', 'admin123', 'root',
        'toor', 'pass', 'test', 'guest', 'master', 'god', '666666',
        '123123', '12345', '1234567', '12345678', '111111',
        '123321', 'pass123', 'pass1234'
    }

    @staticmethod
    def validate_username(username: str) -> Tuple[bool, str]:
        """
        التحقق من صحة اسم المستخدم

        Args:
            username: Username to validate

        Returns:
            Tuple of (is_valid, error_message)
        """
        # Check if empty
        if not username:
            return False, "Username is required"

        # Check length
        if len(username) < 3:
            return False, "Username must be at least 3 characters"

        if len(username) > 50:
            return False, "Username must not exceed 50 characters"

        # Check format
        if not InputValidator.USERNAME_PATTERN.match(username):
            return False, "Username can only contain letters, numbers, dots, hyphens and underscores"

        # Check for consecutive special characters
        if '..' in username or '--' in username or '__' in username:
            return False, "Username cannot contain consecutive special characters"

        # Check start/end
        if username[0] in '.-_' or username[-1] in '.-_':
            return False, "Username cannot start or end with special characters"

        return True, ""

    @staticmethod
    def validate_email(email: str) -> Tuple[bool, str]:
        """
        التحقق من صحة البريد الإلكتروني

        Args:
            email: Email to validate

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not email:
            return False, "Email is required"

        # Basic format check
        if not InputValidator.EMAIL_PATTERN.match(email.lower()):
            return False, "Invalid email format"

        # Check length
        if len(email) > 255:
            return False, "Email address too long"

        # Check local part
        local = email.split('@')[0]
        if len(local) > 64:
            return False, "Email local part too long"

        return True, ""

    @staticmethod
    def validate_password(password: str) -> Tuple[bool, str]:
        """
        التحقق من صحة كلمة المرور الأساسية

        Args:
            password: Password to validate

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not password:
            return False, "Password is required"

        if len(password) < 8:
            return False, "Password must be at least 8 characters"

        if len(password) > 128:
            return False, "Password too long"

        return True, ""

    @staticmethod
    def validate_password_complexity(
        password: str,
        require_uppercase: bool = True,
        require_lowercase: bool = True,
        require_numbers: bool = True,
        require_special: bool = True,
        min_length: int = 8
    ) -> Dict[str, bool]:
        """
        تحليل تعقيد كلمة المرور

        Args:
            password: Password to analyze
            require_uppercase: Require uppercase letters
            require_lowercase: Require lowercase letters
            require_numbers: Require numbers
            require_special: Require special characters
            min_length: Minimum length required

        Returns:
            Dictionary with complexity checks
        """
        complexity = {
            "length": len(password) >= min_length,
            "uppercase": not require_uppercase or bool(re.search(r'[A-Z]', password)),
            "lowercase": not require_lowercase or bool(re.search(r'[a-z]', password)),
            "numbers": not require_numbers or bool(re.search(r'\d', password)),
            "special": not require_special or bool(re.search(r'[!@#$%^&*(),.?":{}|<>]', password)),
            "no_spaces": ' ' not in password,
            "no_common": password.lower() not in InputValidator.COMMON_PASSWORDS,
            "no_repeating": not bool(re.search(r'(.)\1{2,}', password)),  # No 3+ repeating chars
            "no_sequential": not InputValidator._has_sequential_chars(password)
        }

        return complexity

    @staticmethod
    def _has_sequential_chars(password: str, length: int = 3) -> bool:
        """Check for sequential characters"""
        sequences = [
            'abcdefghijklmnopqrstuvwxyz',
            'zyxwvutsrqponmlkjihgfedcba',
            '0123456789',
            '9876543210',
            'qwertyuiop',
            'asdfghjkl',
            'zxcvbnm'
        ]

        password_lower = password.lower()
        for seq in sequences:
            for i in range(len(seq) - length + 1):
                if seq[i:i+length] in password_lower:
                    return True

        return False

    @staticmethod
    def calculate_password_score(password: str) -> int:
        """
        حساب نقاط قوة كلمة المرور

        Args:
            password: Password to score

        Returns:
            Score from 0-10
        """
        if not password:
            return 0

        score = 0

        # Get complexity
        complexity = InputValidator.validate_password_complexity(password)

        # Base score from requirements
        if complexity['length']:
            score += 2
        if complexity['uppercase']:
            score += 1
        if complexity['lowercase']:
            score += 1
        if complexity['numbers']:
            score += 1
        if complexity['special']:
            score += 1
        if complexity['no_common']:
            score += 1
        if complexity['no_repeating']:
            score += 1
        if complexity['no_sequential']:
            score += 1

        # Bonus for length
        if len(password) >= 12:
            score += 1
        if len(password) >= 16:
            score += 1
        if len(password) >= 20:
            score += 1

        # Cap at 10
        return min(score, 10)

    @staticmethod
    def validate_phone(phone: str, country_code: Optional[str] = None) -> Tuple[bool, str]:
        """
        التحقق من صحة رقم الهاتف

        Args:
            phone: Phone number to validate
            country_code: Optional country code for specific validation

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not phone:
            return False, "Phone number is required"

        # Remove common formatting
        cleaned = re.sub(r'[\s\-\(\)]', '', phone)

        # Check if it's numeric (with optional +)
        if not re.match(r'^\+?\d+$', cleaned):
            return False, "Invalid phone number format"

        # Check length (international standards)
        if len(cleaned) < 7 or len(cleaned) > 15:
            return False, "Phone number length invalid"

        # Country-specific validation
        if country_code:
            if country_code.upper() == 'EG':  # Egypt
                if not (cleaned.startswith('+20') or cleaned.startswith('01')):
                    return False, "Invalid Egyptian phone number"

                # Remove country code for length check
                local = cleaned[3:] if cleaned.startswith('+20') else cleaned
                if not (len(local) == 10 or len(local) == 11):
                    return False, "Egyptian phone number must be 10 or 11 digits"

        return True, ""

    @staticmethod
    def sanitize_input(text: str, allow_html: bool = False) -> str:
        """
        تنظيف المدخلات من الأكواد الضارة

        Args:
            text: Text to sanitize
            allow_html: Whether to allow HTML tags

        Returns:
            Sanitized text
        """
        if not text:
            return ""

        # Remove null bytes
        text = text.replace('\x00', '')

        # Strip leading/trailing whitespace
        text = text.strip()

        if not allow_html:
            # Escape HTML entities
            text = (
                text.replace('&', '&amp;')
                    .replace('<', '&lt;')
                    .replace('>', '&gt;')
                    .replace('"', '&quot;')
                    .replace("'", '&#x27;')
            )

        return text

    @staticmethod
    def validate_date(
        date_str: str,
        format: str = '%Y-%m-%d',
        min_date: Optional[datetime] = None,
        max_date: Optional[datetime] = None
    ) -> Tuple[bool, str]:
        """
        التحقق من صحة التاريخ

        Args:
            date_str: Date string to validate
            format: Expected date format
            min_date: Minimum allowed date
            max_date: Maximum allowed date

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not date_str:
            return False, "Date is required"

        try:
            date = datetime.strptime(date_str, format)

            if min_date and date < min_date:
                return False, f"Date must be after {min_date.strftime(format)}"

            if max_date and date > max_date:
                return False, f"Date must be before {max_date.strftime(format)}"

            return True, ""

        except ValueError:
            return False, f"Invalid date format. Expected: {format}"

    @staticmethod
    def validate_url(url: str, require_https: bool = False) -> Tuple[bool, str]:
        """
        التحقق من صحة URL

        Args:
            url: URL to validate
            require_https: Require HTTPS protocol

        Returns:
            Tuple of (is_valid, error_message)
        """
        if not url:
            return False, "URL is required"

        # URL pattern
        url_pattern = re.compile(
            r'^https?://'  # http:// or https://
            r'(?:(?:[A-Z0-9](?:[A-Z0-9-]{0,61}[A-Z0-9])?\.)+[A-Z]{2,6}\.?|'  # domain...
            r'localhost|'  # localhost...
            r'\d{1,3}\.\d{1,3}\.\d{1,3}\.\d{1,3})'  # ...or ip
            r'(?::\d+)?'  # optional port
            r'(?:/?|[/?]\S+)$', re.IGNORECASE
        )

        if not url_pattern.match(url):
            return False, "Invalid URL format"

        if require_https and not url.startswith('https://'):
            return False, "URL must use HTTPS"

        return True, ""

    @staticmethod
    def validate_credit_card(card_number: str) -> Tuple[bool, str]:
        """
        التحقق من صحة رقم بطاقة الائتمان (Luhn algorithm)

        Args:
            card_number: Credit card number

        Returns:
            Tuple of (is_valid, error_message)
        """
        # Remove spaces and dashes
        card_number = re.sub(r'[\s-]', '', card_number)

        if not card_number.isdigit():
            return False, "Card number must contain only digits"

        if len(card_number) < 13 or len(card_number) > 19:
            return False, "Invalid card number length"

        # Luhn algorithm
        total = 0
        reverse_digits = card_number[::-1]

        for i, digit in enumerate(reverse_digits):
            n = int(digit)
            if i % 2 == 1:
                n *= 2
                if n > 9:
                    n -= 9
            total += n

        if total % 10 != 0:
            return False, "Invalid card number"

        return True, ""

============================================================
FILE: utils\window_manager.py
SIZE: 48019 characters
============================================================

# -*- coding: utf-8 -*-
"""
utils/window_manager.py - نسخة محسنة مع دعم ملء الشاشة وارتفاع الشاشة الكامل وارتفاع منطقة العمل

أداة احترافية لإدارة النوافذ مع:
- التوسيط على الشاشة دائماً
- التكيف مع حجم الشاشة
- ضمان ظهور النافذة فوق النوافذ الأخرى
- حل مشكلة ظهور النوافذ في الجانب الأيمن
- إظهار سلس بدون وميض
- دعم ملء الشاشة كوضع افتراضي للنافذة الرئيسية
- دعم ارتفاع الشاشة الكامل لنوافذ تسجيل الدخول
- دعم ارتفاع منطقة العمل (حتى شريط المهام) لنوافذ الإضافة والتعديل

التحديثات الأخيرة:
- إضافة workarea_height_mode لجعل النافذة بارتفاع منطقة العمل (حتى شريط المهام)
- إضافة get_available_screen_area للحصول على المساحة المتاحة بدقة
- تحسين _apply_workarea_height_mode لجميع أنظمة التشغيل
- إضافة setup_add_edit_window للاستخدام السريع مع نوافذ الإضافة والتعديل
- دعم محسن لحساب ارتفاع شريط المهام على Windows
- إضافة دعم لنوافذ الحوار بارتفاع منطقة العمل
"""

import platform
import customtkinter as ctk
import tkinter as tk
from typing import Union, Optional, Callable, Tuple
from weakref import WeakSet
import time
import weakref


class WindowManager:
    """مدير النوافذ المحسن مع معالجة آمنة للنوافذ ودعم جميع أوضاع الارتفاع"""

    # استخدام WeakSet لتجنب مشاكل المراجع الدائرية
    _active_windows = WeakSet()

    @staticmethod
    def get_available_screen_area():
        """الحصول على المساحة المتاحة للنوافذ (بدون شريط المهام)"""
        try:
            import tkinter as tk
            root = tk.Tk()
            root.withdraw()  # إخفاء النافذة المؤقتة

            # الحصول على أبعاد الشاشة الكاملة
            screen_width = root.winfo_screenwidth()
            screen_height = root.winfo_screenheight()

            # محاولة الحصول على المساحة المتاحة (بدون شريط المهام)
            try:
                # على Windows
                if platform.system() == "Windows":
                    import ctypes
                    from ctypes import wintypes

                    # الحصول على معلومات منطقة العمل
                    user32 = ctypes.windll.user32
                    rect = wintypes.RECT()
                    user32.SystemParametersInfoW(48, 0, ctypes.byref(rect), 0)  # SPI_GETWORKAREA

                    available_width = rect.right - rect.left
                    available_height = rect.bottom - rect.top
                    work_area_x = rect.left
                    work_area_y = rect.top

                    root.destroy()
                    return available_width, available_height, work_area_x, work_area_y

            except Exception as e:
                print(f"فشل في الحصول على منطقة العمل: {e}")

            # إذا فشل، استخدم تقدير افتراضي (شريط المهام عادة 40-50 بكسل)
            taskbar_height = 50
            available_width = screen_width
            available_height = screen_height - taskbar_height
            work_area_x = 0
            work_area_y = 0

            root.destroy()
            return available_width, available_height, work_area_x, work_area_y

        except Exception as e:
            print(f"خطأ في حساب المساحة المتاحة: {e}")
            # قيم افتراضية آمنة
            return 1920, 1030, 0, 0

    @staticmethod
    def _apply_workarea_height_mode(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel], size: tuple = None):
        """تطبيق وضع ارتفاع منطقة العمل (من أعلى الشاشة إلى شريط المهام)"""
        try:
            # الحصول على المساحة المتاحة
            available_width, available_height, work_x, work_y = WindowManager.get_available_screen_area()

            # تحديد العرض
            if size and len(size) >= 1:
                window_width = size[0]
            else:
                # عرض افتراضي مناسب لنوافذ الإضافة/التعديل
                window_width = min(600, int(available_width * 0.4))

            # ارتفاع منطقة العمل الكامل
            window_height = available_height

            # حساب الموضع المتوسط أفقياً مع وضع النافذة في أعلى منطقة العمل
            x = (available_width - window_width) // 2
            y = work_y  # بداية منطقة العمل (عادة 0)

            # تطبيق الأبعاد والموضع
            window.geometry(f"{window_width}x{window_height}+{x}+{y}")

            # تحديث النافذة
            window.update_idletasks()
            window.update()

            print(f"تم تطبيق وضع ارتفاع منطقة العمل: {window_width}x{window_height}+{x}+{y}")
            print(f"منطقة العمل: {available_width}x{available_height} من ({work_x},{work_y})")

        except Exception as e:
            print(f"خطأ في تطبيق وضع ارتفاع منطقة العمل: {e}")
            # في حالة الفشل، استخدم إعدادات افتراضية آمنة
            try:
                screen_width = window.winfo_screenwidth()
                screen_height = window.winfo_screenheight()
                # تقدير ارتفاع شريط المهام
                safe_height = screen_height - 50
                window_width = size[0] if size else 600
                x = (screen_width - window_width) // 2
                window.geometry(f"{window_width}x{safe_height}+{x}+0")
            except:
                pass

    @staticmethod
    def setup_centered_window(window: Union[ctk.CTk, ctk.CTkToplevel],
                             size: tuple = None,
                             parent: Optional[Union[ctk.CTk, ctk.CTkToplevel]] = None,
                             full_height_mode: bool = False,
                             workarea_height_mode: bool = False,  # جديد: للارتفاع حتى شريط المهام
                             **kwargs) -> None:
        """إعداد نافذة مع ضمان التوسيط الصحيح مع دعم أوضاع الارتفاع المختلفة"""

        # إخفاء النافذة أولاً لتجنب الوميض
        if isinstance(window, (ctk.CTkToplevel, tk.Toplevel)):
            window.withdraw()

        # تعيين الحجم بناءً على الوضع المطلوب
        if workarea_height_mode:
            # استخدام ارتفاع منطقة العمل (حتى شريط المهام)
            WindowManager._apply_workarea_height_mode(window, size)
        elif full_height_mode:
            # استخدام ارتفاع الشاشة الكامل (فوق شريط المهام أيضاً)
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()

            # تحديد العرض (إما المحدد أو القيمة الافتراضية)
            if size:
                window_width = size[0]
            else:
                window_width = min(500, int(screen_width * 0.4))  # عرض متوسط مناسب

            # استخدام ارتفاع الشاشة الكامل بدون هوامش
            window_height = screen_height  # ارتفاع الشاشة الكامل

            window.geometry(f"{window_width}x{window_height}")
        elif size:
            window.geometry(f"{size[0]}x{size[1]}")

        # فرض التحديث الكامل
        window.update_idletasks()
        window.update()

        # حساب الموضع بناءً على الوضع
        if workarea_height_mode:
            # الموضع محدد مسبقاً في _apply_workarea_height_mode
            pass
        elif full_height_mode:
            # الموضع للارتفاع الكامل
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()
            window_width = window.winfo_width() if window.winfo_width() > 1 else window.winfo_reqwidth()

            # حساب الموضع المتوسط
            x = (screen_width - window_width) // 2
            y = 0  # بدون هامش علوي - ملء الشاشة كاملة
            window_height = screen_height  # ارتفاع الشاشة الكامل

            # التأكد من بقاء النافذة داخل الشاشة
            x = max(10, min(x, screen_width - window_width - 10))

            # تطبيق الموضع والحجم النهائي
            window.geometry(f"{window_width}x{window_height}+{x}+{y}")
        else:
            # التوسيط العادي
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()

            # الحصول على حجم النافذة الفعلي
            if size:
                window_width, window_height = size
            else:
                window_width = window.winfo_reqwidth() if window.winfo_width() <= 1 else window.winfo_width()
                window_height = window.winfo_reqheight() if window.winfo_height() <= 1 else window.winfo_height()

            # حساب الموضع المتوسط
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2

            # التأكد من بقاء النافذة داخل الشاشة
            x = max(10, min(x, screen_width - window_width - 10))
            y = max(10, min(y, screen_height - window_height - 50))  # 50 لترك مساحة لشريط المهام

            # تطبيق الموضع والحجم النهائي
            window.geometry(f"{window_width}x{window_height}+{x}+{y}")

        # تطبيق باقي الإعدادات (بدون التوسيط مرة أخرى)
        kwargs['center'] = False  # منع التوسيط المكرر
        kwargs['use_smooth_show'] = False  # النافذة مخفية بالفعل
        kwargs['full_height_mode'] = full_height_mode  # تمرير المعلومة للدالة الأساسية
        kwargs['workarea_height_mode'] = workarea_height_mode  # تمرير المعلومة الجديدة
        WindowManager.setup_window(window, parent=parent, **kwargs)

        # إظهار النافذة بشكل سلس
        if isinstance(window, (ctk.CTkToplevel, tk.Toplevel)):
            window.deiconify()
            window.lift()
            window.focus_force()

    @staticmethod
    def setup_window(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                    parent: Optional[Union[ctk.CTk, ctk.CTkToplevel]] = None,
                    center: bool = True,
                    center_on_screen: bool = True,  # للتوسيط على الشاشة دائماً
                    modal: bool = False,
                    focus: bool = True,
                    topmost_duration: int = 300,
                    min_size: tuple = None,
                    max_size: tuple = None,
                    size: tuple = None,
                    responsive: bool = True,  # للتكيف مع حجم الشاشة
                    max_screen_ratio: float = 0.9,  # نسبة الحد الأقصى من الشاشة
                    use_smooth_show: bool = True,  # للإظهار السلس
                    fullscreen_default: bool = False,  # للنافذة الرئيسية
                    full_height_mode: bool = False,  # لارتفاع الشاشة الكامل
                    workarea_height_mode: bool = False) -> None:  # جديد: لارتفاع منطقة العمل
        """إعداد النافذة لتظهر بشكل احترافي مع دعم جميع أوضاع الارتفاع"""
        try:
            # إخفاء النافذة مؤقتاً لتجنب الوميض (حل مشكلة التموضع)
            if use_smooth_show and isinstance(window, (ctk.CTkToplevel, tk.Toplevel)):
                window.withdraw()

            # إضافة النافذة إلى المجموعة الضعيفة
            WindowManager._active_windows.add(window)

            # التحقق من وضع ملء الشاشة
            if fullscreen_default:
                # تطبيق ملء الشاشة فوراً
                WindowManager._apply_fullscreen(window)
                # تجاهل باقي إعدادات الحجم والموضع
                center = False
                size = None
                full_height_mode = False
                workarea_height_mode = False
            elif workarea_height_mode:
                # تطبيق وضع ارتفاع منطقة العمل
                WindowManager._apply_workarea_height_mode(window, size)
                center = False  # لا نحتاج توسيط لأن الموضع محدد مسبقاً
            elif full_height_mode:
                # تطبيق وضع ارتفاع الشاشة الكامل
                WindowManager._apply_full_height_mode(window, size)
                center = False  # لا نحتاج توسيط لأن الموضع محدد مسبقاً
            else:
                # الحصول على حجم الشاشة
                screen_width = window.winfo_screenwidth()
                screen_height = window.winfo_screenheight()

                # تعيين الحجم مع التكيف مع الشاشة
                if size and responsive:
                    # حساب الحجم المناسب مع عدم تجاوز نسبة معينة من الشاشة
                    max_width = int(screen_width * max_screen_ratio)
                    max_height = int(screen_height * max_screen_ratio)

                    # تطبيق الحد الأقصى
                    actual_width = min(size[0], max_width)
                    actual_height = min(size[1], max_height)

                    window.geometry(f"{actual_width}x{actual_height}")
                elif size:
                    window.geometry(f"{size[0]}x{size[1]}")

                # فرض التحديث الكامل
                window.update_idletasks()
                window.update()

                # تعيين الحدود مع مراعاة حجم الشاشة
                if min_size:
                    window.minsize(min_size[0], min_size[1])
                if max_size and responsive:
                    # تعديل الحد الأقصى ليتناسب مع الشاشة
                    adjusted_max_width = min(max_size[0], int(screen_width * max_screen_ratio))
                    adjusted_max_height = min(max_size[1], int(screen_height * max_screen_ratio))
                    window.maxsize(adjusted_max_width, adjusted_max_height)
                elif max_size:
                    window.maxsize(max_size[0], max_size[1])

                # توسيط النافذة
                if center:
                    if center_on_screen:
                        # التوسيط الفوري على الشاشة
                        WindowManager.center_window_on_screen(window)
                    else:
                        # التوسيط على النافذة الأصلية
                        WindowManager.center_window(window, parent)

            # جعل النافذة تابعة (لكن مع البقاء فوقها)
            if parent and hasattr(window, 'transient'):
                try:
                    if parent.winfo_exists():
                        window.transient(parent)
                except:
                    pass

            # إظهار النافذة إذا كانت مخفية
            if use_smooth_show and isinstance(window, (ctk.CTkToplevel, tk.Toplevel)):
                window.deiconify()

            # رفع النافذة لتظهر فوق جميع النوافذ (إلا إذا كانت في ملء الشاشة)
            if not fullscreen_default:
                WindowManager.force_bring_to_front(window, topmost_duration)

            # إعطاء التركيز
            if focus:
                WindowManager.set_focus(window)

            # جعلها مشروطة
            if modal and parent:
                WindowManager.make_modal(window, parent)

            # تطبيق إعدادات النظام
            WindowManager._apply_platform_specific(window, fullscreen_default)

            # ربط حدث الإغلاق بطريقة آمنة
            WindowManager._setup_close_handler(window)

            # التأكد من التموضع الصحيح بعد تأخير بسيط (فقط للنوافذ العادية)
            if center and center_on_screen and not fullscreen_default and not full_height_mode and not workarea_height_mode:
                WindowManager.ensure_correct_position(window, delay=100)

        except Exception as e:
            print(f"خطأ في إعداد النافذة: {e}")

    @staticmethod
    def _apply_full_height_mode(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel], size: tuple = None):
        """تطبيق وضع ارتفاع الشاشة الكامل بدون هوامش"""
        try:
            # الحصول على أبعاد الشاشة
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()

            # تحديد العرض
            if size and len(size) >= 1:
                window_width = size[0]
            else:
                # عرض افتراضي مناسب لنافذة تسجيل الدخول
                window_width = min(500, int(screen_width * 0.4))

            # ارتفاع الشاشة الكامل بدون هوامش
            window_height = screen_height

            # حساب الموضع المتوسط أفقياً مع وضع النافذة في أقصى الأعلى
            x = (screen_width - window_width) // 2
            y = 0  # بدون هامش علوي - ملء الشاشة كاملة

            # تطبيق الأبعاد والموضع
            window.geometry(f"{window_width}x{window_height}+{x}+{y}")

            # تحديث النافذة
            window.update_idletasks()
            window.update()

            print(f"تم تطبيق وضع ارتفاع الشاشة الكامل: {window_width}x{window_height}+{x}+{y}")

        except Exception as e:
            print(f"خطأ في تطبيق وضع ارتفاع الشاشة الكامل: {e}")
            # في حالة الفشل، استخدم إعدادات افتراضية
            try:
                screen_height = window.winfo_screenheight()
                window.geometry(f"500x{screen_height}+400+0")
            except:
                pass

    @staticmethod
    def _apply_fullscreen(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]):
        """تطبيق وضع ملء الشاشة بناءً على نظام التشغيل"""
        try:
            system = platform.system()

            # الحصول على أبعاد الشاشة وتعيين النافذة لتملأ الشاشة أولاً
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()
            window.geometry(f"{screen_width}x{screen_height}+0+0")

            # تحديث النافذة قبل تطبيق الحالة
            window.update_idletasks()
            window.update()

            if system == "Windows":
                # للـ Windows، استخدم state('zoomed') للاحتفاظ بشريط المهام
                try:
                    window.state('zoomed')
                    print("تم تطبيق وضع ملء الشاشة (Windows zoomed)")
                except Exception as e:
                    print(f"فشل في zoomed، محاولة fullscreen: {e}")
                    # إذا فشل zoomed، جرب fullscreen
                    window.attributes('-fullscreen', True)
                    print("تم تطبيق وضع ملء الشاشة (Windows fullscreen)")

            elif system == "Linux":
                # للـ Linux، جرب zoomed أولاً ثم fullscreen
                try:
                    window.attributes('-zoomed', True)
                    print("تم تطبيق وضع ملء الشاشة (Linux zoomed)")
                except Exception as e:
                    print(f"فشل في zoomed، محاولة fullscreen: {e}")
                    window.attributes('-fullscreen', True)
                    print("تم تطبيق وضع ملء الشاشة (Linux fullscreen)")

            elif system == "Darwin":  # macOS
                window.attributes('-fullscreen', True)
                print("تم تطبيق وضع ملء الشاشة (macOS)")

            # تحديث النافذة مرة أخيرة
            window.update_idletasks()
            window.update()

        except Exception as e:
            print(f"خطأ في تطبيق ملء الشاشة: {e}")
            # في حالة الفشل، استخدم الحد الأقصى
            try:
                screen_width = window.winfo_screenwidth()
                screen_height = window.winfo_screenheight()
                window.geometry(f"{screen_width-50}x{screen_height-100}+25+25")
                print("تم استخدام حجم الشاشة الأقصى كبديل")
            except:
                pass

    @staticmethod
    def center_window_on_screen(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> None:
        """توسيط النافذة على الشاشة دائماً مع ضمان الدقة"""
        try:
            # فرض التحديث الكامل أولاً
            window.update_idletasks()
            window.update()

            # الحصول على حجم النافذة بطريقة موثوقة
            window_width, window_height = WindowManager._get_window_size(window)

            # إذا كانت القيم غير صحيحة، انتظر وحاول مرة أخرى
            if window_width <= 1 or window_height <= 1:
                window.update()
                window_width = window.winfo_reqwidth()
                window_height = window.winfo_reqheight()

            # الحصول على حجم الشاشة
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()

            # حساب الموضع المتوسط على الشاشة
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2

            # التأكد من أن النافذة داخل حدود الشاشة مع هامش أمان
            margin = 20
            x = max(margin, min(x, screen_width - window_width - margin))
            y = max(margin, min(y, screen_height - window_height - margin))

            # تعيين الموضع بدقة
            window.geometry(f"{window_width}x{window_height}+{x}+{y}")

            # فرض التحديث النهائي
            window.update()

        except Exception as e:
            print(f"خطأ في توسيط النافذة على الشاشة: {e}")

    @staticmethod
    def force_bring_to_front(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                           duration: int = 300) -> None:
        """رفع النافذة للأعلى بشكل قوي لضمان ظهورها فوق جميع النوافذ"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            # رفع النافذة عدة مرات للتأكيد
            window.lift()
            window.update()

            # جعلها في الأعلى مؤقتاً
            window.attributes('-topmost', True)
            window.update()

            # إعطاء التركيز
            window.focus_force()
            window.focus_set()

            # رفع مرة أخرى للتأكيد
            window.lift()

            # على Windows، استخدم طريقة إضافية
            if platform.system() == "Windows":
                window.wm_attributes('-topmost', True)
                window.update()

            if duration > 0:
                # إزالة topmost بعد فترة
                window_ref = weakref.ref(window)
                window.after(duration, lambda: WindowManager._remove_topmost_safe(window_ref))

        except Exception as e:
            print(f"خطأ في رفع النافذة: {e}")

    @staticmethod
    def adjust_window_size_to_screen(window: Union[ctk.CTk, ctk.CTkToplevel],
                                   preferred_width: int,
                                   preferred_height: int,
                                   max_screen_ratio: float = 0.9) -> Tuple[int, int]:
        """تعديل حجم النافذة ليتناسب مع حجم الشاشة"""
        try:
            screen_width = window.winfo_screenwidth()
            screen_height = window.winfo_screenheight()

            # حساب الحد الأقصى المسموح
            max_width = int(screen_width * max_screen_ratio)
            max_height = int(screen_height * max_screen_ratio)

            # تطبيق الحدود
            actual_width = min(preferred_width, max_width)
            actual_height = min(preferred_height, max_height)

            return actual_width, actual_height

        except Exception as e:
            print(f"خطأ في تعديل حجم النافذة: {e}")
            return preferred_width, preferred_height

    @staticmethod
    def _get_window_size(window) -> Tuple[int, int]:
        """الحصول على حجم النافذة الفعلي"""
        try:
            # محاولة الحصول على الحجم من geometry
            geometry = window.geometry()
            if geometry:
                # تحليل السلسلة "widthxheight+x+y"
                size_part = geometry.split('+')[0]
                if 'x' in size_part:
                    width, height = map(int, size_part.split('x'))
                    return width, height
        except:
            pass

        # إذا فشل، استخدم winfo_width/height
        width = window.winfo_width()
        height = window.winfo_height()

        # إذا كانت القيم 1، استخدم reqwidth/reqheight
        if width <= 1 or height <= 1:
            width = window.winfo_reqwidth()
            height = window.winfo_reqheight()

        return width, height

    @staticmethod
    def center_window(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                     parent: Optional[Union[ctk.CTk, ctk.CTkToplevel]] = None) -> None:
        """توسيط النافذة (الطريقة القديمة - للتوافق)"""
        try:
            # تحديث النافذة لضمان الحصول على الأبعاد الصحيحة
            window.update_idletasks()

            # الحصول على حجم النافذة
            window_width, window_height = WindowManager._get_window_size(window)

            if parent and WindowManager._is_window_valid(parent):
                # توسيط على النافذة الأصلية
                parent.update_idletasks()

                parent_x = parent.winfo_x()
                parent_y = parent.winfo_y()
                parent_width = parent.winfo_width()
                parent_height = parent.winfo_height()

                # التأكد من أن قيم النافذة الأصلية صحيحة
                if parent_width <= 1 or parent_height <= 1:
                    parent_width, parent_height = WindowManager._get_window_size(parent)

                x = parent_x + (parent_width - window_width) // 2
                y = parent_y + (parent_height - window_height) // 2
            else:
                # توسيط على الشاشة
                screen_width = window.winfo_screenwidth()
                screen_height = window.winfo_screenheight()

                x = (screen_width - window_width) // 2
                y = (screen_height - window_height) // 2

            # التأكد من أن النافذة داخل حدود الشاشة
            x = max(0, x)
            y = max(0, y)

            # تعيين الموضع فقط (بدون تغيير الحجم)
            window.geometry(f"+{x}+{y}")

            # تحديث النافذة
            window.update()

        except Exception as e:
            print(f"خطأ في توسيط النافذة: {e}")

    @staticmethod
    def center_window_delayed(window: Union[ctk.CTk, ctk.CTkToplevel],
                            parent: Optional[Union[ctk.CTk, ctk.CTkToplevel]] = None,
                            delay: int = 50,
                            on_screen: bool = True) -> None:
        """توسيط النافذة مع تأخير للتأكد من اكتمال الرسم"""
        if on_screen:
            window.after(delay, lambda: WindowManager.center_window_on_screen(window))
        else:
            window.after(delay, lambda: WindowManager.center_window(window, parent))

    @staticmethod
    def set_window_position(window: Union[ctk.CTk, ctk.CTkToplevel],
                          x: int, y: int) -> None:
        """تعيين موضع النافذة بشكل مباشر"""
        try:
            window.geometry(f"+{x}+{y}")
            window.update()
        except Exception as e:
            print(f"خطأ في تعيين موضع النافذة: {e}")

    @staticmethod
    def set_window_size_and_position(window: Union[ctk.CTk, ctk.CTkToplevel],
                                    width: int, height: int,
                                    x: Optional[int] = None,
                                    y: Optional[int] = None,
                                    responsive: bool = True) -> None:
        """تعيين حجم وموضع النافذة مع خيار التكيف مع الشاشة"""
        try:
            if responsive:
                width, height = WindowManager.adjust_window_size_to_screen(window, width, height)

            if x is not None and y is not None:
                window.geometry(f"{width}x{height}+{x}+{y}")
            else:
                window.geometry(f"{width}x{height}")
            window.update()
        except Exception as e:
            print(f"خطأ في تعيين حجم وموضع النافذة: {e}")

    @staticmethod
    def _setup_close_handler(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]):
        """إعداد معالج الإغلاق بطريقة آمنة"""
        try:
            # حفظ المعالج الأصلي
            original_protocol = window.protocol("WM_DELETE_WINDOW")

            def safe_close():
                try:
                    # إزالة من قائمة النوافذ النشطة
                    WindowManager._active_windows.discard(window)

                    # استدعاء المعالج الأصلي إن وجد
                    if callable(original_protocol):
                        original_protocol()
                    elif hasattr(window, 'destroy'):
                        window.destroy()
                except Exception as e:
                    print(f"خطأ في إغلاق النافذة: {e}")

            window.protocol("WM_DELETE_WINDOW", safe_close)

        except Exception as e:
            print(f"خطأ في إعداد معالج الإغلاق: {e}")

    @staticmethod
    def _is_window_valid(window) -> bool:
        """التحقق من صحة النافذة بطريقة آمنة"""
        try:
            return window is not None and window.winfo_exists()
        except:
            return False

    @staticmethod
    def bring_to_front(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                      duration: int = 300) -> None:
        """رفع النافذة للأعلى بطريقة آمنة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            window.lift()
            window.attributes('-topmost', True)

            if duration > 0:
                # استخدام weakref لتجنب مشاكل المراجع
                window_ref = weakref.ref(window)
                window.after(duration, lambda: WindowManager._remove_topmost_safe(window_ref))

            window.update()

        except Exception as e:
            print(f"خطأ في رفع النافذة: {e}")

    @staticmethod
    def _remove_topmost_safe(window_ref: weakref.ref):
        """إزالة خاصية topmost بطريقة آمنة"""
        try:
            window = window_ref()
            if window and WindowManager._is_window_valid(window):
                window.attributes('-topmost', False)
        except:
            pass

    @staticmethod
    def set_focus(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> None:
        """إعطاء التركيز للنافذة بطريقة آمنة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            window.focus_force()
            window.focus_set()

            # التركيز على أول عنصر
            for child in window.winfo_children():
                if isinstance(child, (ctk.CTkEntry, ctk.CTkButton, tk.Entry, tk.Button)):
                    child.focus_set()
                    break

        except Exception as e:
            print(f"خطأ في تعيين التركيز: {e}")

    @staticmethod
    def make_modal(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                   parent: Union[ctk.CTk, ctk.CTkToplevel]) -> None:
        """جعل النافذة مشروطة بطريقة آمنة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            if WindowManager._is_window_valid(parent):
                window.transient(parent)

            window.grab_set()
            window.wait_visibility()

        except Exception as e:
            print(f"خطأ في جعل النافذة مشروطة: {e}")

    @staticmethod
    def ensure_correct_position(window: Union[ctk.CTk, ctk.CTkToplevel],
                               delay: int = 50) -> None:
        """التأكد من التموضع الصحيح للنافذة بعد تأخير"""
        def check_and_fix():
            try:
                if WindowManager._is_window_valid(window):
                    # التحقق من موضع النافذة
                    x = window.winfo_x()
                    y = window.winfo_y()

                    # إذا كانت النافذة في موضع غير متوقع (مثل الجانب الأيمن)
                    screen_width = window.winfo_screenwidth()
                    window_width = window.winfo_width()

                    # إذا كانت النافذة قريبة جداً من الحافة اليمنى
                    if x > screen_width - window_width - 100:
                        # إعادة التوسيط
                        WindowManager.center_window_on_screen(window)
            except:
                pass

        window.after(delay, check_and_fix)

    @staticmethod
    def _apply_platform_specific(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                                fullscreen: bool = False) -> None:
        """تطبيق إعدادات خاصة بنظام التشغيل"""
        system = platform.system()

        try:
            if not WindowManager._is_window_valid(window):
                return

            # تجنب تطبيق بعض الإعدادات في وضع ملء الشاشة
            if not fullscreen:
                if system == "Windows":
                    # إعدادات Windows
                    window.attributes('-alpha', 0.0)
                    window.update()
                    window.attributes('-alpha', 1.0)

                    # تحسين DPI
                    try:
                        from ctypes import windll
                        windll.shcore.SetProcessDpiAwareness(1)
                    except:
                        pass

                elif system == "Darwin":  # macOS
                    window.update()
                    window.lift()
                    window.attributes('-topmost', True)
                    window.after(100, lambda: window.attributes('-topmost', False) if WindowManager._is_window_valid(window) else None)

                elif system == "Linux":
                    window.update()
                    window.lift()
            else:
                # إعدادات خاصة بوضع ملء الشاشة
                if system == "Windows":
                    # تحسين الأداء في ملء الشاشة
                    try:
                        window.focus_force()
                        window.lift()
                    except:
                        pass

        except Exception as e:
            print(f"خطأ في تطبيق إعدادات النظام: {e}")

    @staticmethod
    def flash_window(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                    count: int = 3, interval: int = 500) -> None:
        """وميض النافذة بطريقة آمنة"""
        def flash():
            try:
                for i in range(count * 2):
                    if not WindowManager._is_window_valid(window):
                        break

                    if i % 2 == 0:
                        window.attributes('-alpha', 0.7)
                    else:
                        window.attributes('-alpha', 1.0)
                    window.update()
                    time.sleep(interval / 1000)

                # التأكد من إعادة الشفافية الكاملة
                if WindowManager._is_window_valid(window):
                    window.attributes('-alpha', 1.0)

            except Exception as e:
                print(f"خطأ في وميض النافذة: {e}")

        import threading
        flash_thread = threading.Thread(target=flash, daemon=True)
        flash_thread.start()

    @staticmethod
    def animate_window_open(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel],
                          duration: int = 200) -> None:
        """تحريك فتح النافذة بطريقة آمنة (تجنب مع ملء الشاشة)"""
        steps = 10
        step_duration = duration // steps

        try:
            if not WindowManager._is_window_valid(window):
                return

            # تجنب التحريك إذا كانت النافذة في ملء الشاشة
            try:
                if (hasattr(window, 'attributes') and window.attributes('-fullscreen')) or \
                   (hasattr(window, 'state') and window.state() == 'zoomed'):
                    return
            except:
                pass

            window.attributes('-alpha', 0.0)
            window.update()

            for i in range(1, steps + 1):
                if not WindowManager._is_window_valid(window):
                    break

                alpha = i / steps
                window.attributes('-alpha', alpha)
                window.update()
                window.after(step_duration)

        except Exception:
            # في حالة الفشل، اجعل النافذة مرئية
            if WindowManager._is_window_valid(window):
                window.attributes('-alpha', 1.0)

    @staticmethod
    def get_active_windows() -> list:
        """الحصول على قائمة النوافذ النشطة بطريقة آمنة"""
        active = []

        # WeakSet يتعامل تلقائياً مع النوافذ المحذوفة
        for window in WindowManager._active_windows:
            try:
                if WindowManager._is_window_valid(window):
                    active.append(window)
            except:
                pass

        return active

    @staticmethod
    def close_all_windows(except_window: Optional[Union[ctk.CTk, ctk.CTkToplevel]] = None) -> None:
        """إغلاق جميع النوافذ بطريقة آمنة"""
        windows_to_close = []

        # جمع النوافذ للإغلاق
        for window in WindowManager._active_windows:
            try:
                if window != except_window and WindowManager._is_window_valid(window):
                    windows_to_close.append(window)
            except:
                pass

        # إغلاق النوافذ
        for window in windows_to_close:
            try:
                window.destroy()
            except:
                pass

        # تنظيف القائمة
        WindowManager._active_windows = WeakSet()
        if except_window and WindowManager._is_window_valid(except_window):
            WindowManager._active_windows.add(except_window)

    @staticmethod
    def arrange_cascade() -> None:
        """ترتيب النوافذ بشكل متتالي"""
        offset = 30

        active_windows = WindowManager.get_active_windows()
        for i, window in enumerate(active_windows):
            try:
                # تجنب ترتيب النوافذ في ملء الشاشة
                try:
                    if (hasattr(window, 'attributes') and window.attributes('-fullscreen')) or \
                       (hasattr(window, 'state') and window.state() == 'zoomed'):
                        continue
                except:
                    pass

                window.geometry(f"+{50 + i * offset}+{50 + i * offset}")
            except:
                pass

    @staticmethod
    def setup_window_shortcuts(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> None:
        """إعداد اختصارات لوحة المفاتيح بطريقة آمنة مع دعم ملء الشاشة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            # ESC للخروج من ملء الشاشة أو الإغلاق
            def handle_escape(event=None):
                try:
                    if WindowManager._is_window_valid(window):
                        # التحقق من وضع ملء الشاشة
                        is_fullscreen = False
                        try:
                            if hasattr(window, 'attributes'):
                                is_fullscreen = window.attributes('-fullscreen')
                            elif hasattr(window, 'state'):
                                is_fullscreen = window.state() == 'zoomed'
                        except:
                            pass

                        if is_fullscreen:
                            # الخروج من ملء الشاشة
                            WindowManager._exit_fullscreen(window)
                        else:
                            # إغلاق النافذة
                            window.destroy()
                except:
                    pass

            window.bind('<Escape>', handle_escape)

            # F11 لتبديل ملء الشاشة
            def toggle_fullscreen(event=None):
                try:
                    if WindowManager._is_window_valid(window):
                        WindowManager._toggle_fullscreen(window)
                except:
                    pass

            window.bind('<F11>', toggle_fullscreen)

            # Alt+F4 للإغلاق (Windows)
            if platform.system() == "Windows":
                window.bind('<Alt-F4>', lambda e: window.destroy() if WindowManager._is_window_valid(window) else None)

            # Alt+Enter لتبديل ملء الشاشة (اختصار إضافي)
            window.bind('<Alt-Return>', toggle_fullscreen)

        except Exception as e:
            print(f"خطأ في إعداد الاختصارات: {e}")

    @staticmethod
    def _toggle_fullscreen(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> None:
        """تبديل وضع ملء الشاشة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            system = platform.system()
            current_fullscreen = False

            # التحقق من الحالة الحالية
            try:
                if system == "Windows":
                    current_fullscreen = window.state() == 'zoomed'
                else:
                    current_fullscreen = window.attributes('-fullscreen')
            except:
                pass

            # تبديل الحالة
            if current_fullscreen:
                WindowManager._exit_fullscreen(window)
            else:
                WindowManager._apply_fullscreen(window)

        except Exception as e:
            print(f"خطأ في تبديل ملء الشاشة: {e}")

    @staticmethod
    def _exit_fullscreen(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> None:
        """الخروج من وضع ملء الشاشة"""
        try:
            if not WindowManager._is_window_valid(window):
                return

            system = platform.system()

            if system == "Windows":
                try:
                    window.state('normal')
                    print("تم الخروج من ملء الشاشة (Windows normal)")
                except:
                    window.attributes('-fullscreen', False)
                    print("تم الخروج من ملء الشاشة (Windows fullscreen off)")

            elif system == "Linux":
                try:
                    window.attributes('-zoomed', False)
                    print("تم الخروج من ملء الشاشة (Linux zoomed off)")
                except:
                    window.attributes('-fullscreen', False)
                    print("تم الخروج من ملء الشاشة (Linux fullscreen off)")

            elif system == "Darwin":  # macOS
                window.attributes('-fullscreen', False)
                print("تم الخروج من ملء الشاشة (macOS)")

            # تحديث النافذة
            window.update_idletasks()
            window.update()

        except Exception as e:
            print(f"خطأ في الخروج من ملء الشاشة: {e}")

    @staticmethod
    def is_fullscreen(window: Union[ctk.CTk, ctk.CTkToplevel, tk.Tk, tk.Toplevel]) -> bool:
        """التحقق من وضع ملء الشاشة"""
        try:
            if not WindowManager._is_window_valid(window):
                return False

            system = platform.system()

            if system == "Windows":
                try:
                    return window.state() == 'zoomed'
                except:
                    try:
                        return window.attributes('-fullscreen')
                    except:
                        return False
            else:
                try:
                    return window.attributes('-fullscreen')
                except:
                    if system == "Linux":
                        try:
                            return window.attributes('-zoomed')
                        except:
                            return False
                    return False

        except Exception as e:
            print(f"خطأ في التحقق من ملء الشاشة: {e}")
            return False


# دوال مساعدة سريعة محدثة

def setup_window(window, **kwargs):
    """دالة مساعدة سريعة لإعداد النافذة مع التوسيط على الشاشة افتراضياً"""
    # تعيين الافتراضيات الجديدة
    kwargs.setdefault('center_on_screen', True)
    kwargs.setdefault('responsive', True)
    kwargs.setdefault('use_smooth_show', True)
    WindowManager.setup_window(window, **kwargs)

# دالة مساعدة لنوافذ تسجيل الدخول والحوارات مع دعم ارتفاع الشاشة الكامل
def setup_dialog_window(window, size=(600, 400), full_height=False, **kwargs):
    """إعداد نافذة حوار مع ضمان التوسيط الصحيح ودعم ارتفاع الشاشة الكامل"""
    if full_height:
        # استخدام ارتفاع الشاشة الكامل
        WindowManager.setup_centered_window(window, size=size, full_height_mode=True, modal=True, **kwargs)
    else:
        # الحجم العادي
        WindowManager.setup_centered_window(window, size=size, modal=True, **kwargs)

# دالة مساعدة خاصة لنوافذ تسجيل الدخول بارتفاع الشاشة الكامل
def setup_login_window(window, width=500, **kwargs):
    """إعداد نافذة تسجيل الدخول بارتفاع الشاشة الكامل"""
    WindowManager.setup_centered_window(
        window,
        size=(width, 0),  # سيتم تجاهل الارتفاع واستخدام ارتفاع الشاشة الكامل
        full_height_mode=True,
        modal=True,
        **kwargs
    )

# دوال مساعدة جديدة لنوافذ الإضافة والتعديل

def setup_add_edit_window(window, width=600, **kwargs):
    """إعداد نافذة إضافة/تعديل بارتفاع منطقة العمل (حتى شريط المهام)"""
    WindowManager.setup_centered_window(
        window,
        size=(width, 0),  # سيتم تجاهل الارتفاع واستخدام ارتفاع منطقة العمل
        workarea_height_mode=True,
        modal=True,
        **kwargs
    )

def setup_dialog_window_workarea(window, size=(600, 400), workarea_height=False, **kwargs):
    """إعداد نافذة حوار مع خيار استخدام ارتفاع منطقة العمل"""
    if workarea_height:
        # استخدام ارتفاع منطقة العمل
        WindowManager.setup_centered_window(window, size=size, workarea_height_mode=True, modal=True, **kwargs)
    else:
        # الحجم العادي
        WindowManager.setup_centered_window(window, size=size, modal=True, **kwargs)

# دالة مساعدة للنافذة الرئيسية مع ملء الشاشة
def setup_main_window(window, **kwargs):
    """إعداد النافذة الرئيسية مع ملء الشاشة كافتراضي"""
    kwargs.setdefault('fullscreen_default', True)
    kwargs.setdefault('center', False)
    kwargs.setdefault('use_smooth_show', False)
    WindowManager.setup_window(window, **kwargs)


# أمثلة الاستخدام المحدثة:
"""
# 1. نافذة إضافة/تعديل بارتفاع منطقة العمل (الجديد - المطلوب):
add_window = ctk.CTkToplevel()
setup_add_edit_window(add_window, width=600, parent=main_window)

# 2. نافذة حوار بارتفاع منطقة العمل:
dialog = ctk.CTkToplevel()
setup_dialog_window_workarea(dialog, size=(500, 0), workarea_height=True, parent=main_window)

# 3. باستخدام الطريقة المباشرة:
edit_window = ctk.CTkToplevel()
WindowManager.setup_centered_window(
    edit_window,
    size=(600, 0),
    workarea_height_mode=True,  # من أعلى الشاشة حتى شريط المهام
    parent=main_window
)

# 4. نافذة تسجيل دخول بارتفاع الشاشة الكامل:
login_window = ctk.CTkToplevel()
setup_login_window(login_window, width=450, parent=main_window)

# 5. نافذة حوار عادية:
dialog = ctk.CTkToplevel()
setup_dialog_window(dialog, size=(500, 300), parent=main_window)

# 6. النافذة الرئيسية مع ملء الشاشة:
main_window = ctk.CTk()
setup_main_window(main_window, min_size=(1200, 700))

# 7. مقارنة الأوضاع المختلفة:

# وضع عادي (متوسط الشاشة)
normal_window = ctk.CTkToplevel()
setup_dialog_window(normal_window, size=(600, 400))

# وضع ارتفاع منطقة العمل (من الأعلى حتى شريط المهام) - الجديد
workarea_window = ctk.CTkToplevel()
setup_add_edit_window(workarea_window, width=600)

# وضع ارتفاع الشاشة الكامل (فوق شريط المهام أيضاً)
fullheight_window = ctk.CTkToplevel()
setup_login_window(fullheight_window, width=600)
"""

============================================================
FILE: views\add_edit_window.py
SIZE: 62579 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/add_edit_window.py - نسخة محسنة ومبسطة مع إصلاح مشكلة رقم الحجز

نافذة إضافة/تعديل محسنة مع:
- كود مبسط ومنظم
- دعم offline mode
- ربط القوائم المنسدلة بـ Airtable
- النظام الموحد لإدارة الثيم
- القوائم المنسدلة المدعومة بالبحث
- دعم شامل لتعدد اللغات مع ترجمة التبويبات والحقول
- دعم الحقول للقراءة فقط (readonly fields) - محسن
- توليد رقم الحجز تلقائياً عند اختيار الوكالة
- إصلاح مشكلة عرض رقم الحجز في وضع التعديل
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import messagebox
from typing import Dict, List, Any, Optional
from datetime import datetime
import json
import os
import threading
import time
import random
import string
from core.language_manager import LanguageManager
from utils.window_manager import WindowManager
from core.theme_color_manager import ThemeColorManager, ThemedWindow

# استيراد القوائم المحسنة من الملف الموحد
try:
    from views.components.combobox import (
        EnhancedSearchableComboBox,
        EnhancedSearchableComboBoxImproved,
        create_airtable_combo_for_field,
        create_enhanced_dropdown_with_improved_click
    )
    HAS_ENHANCED_COMBO = True
    HAS_IMPROVED_CLICK = True
except ImportError:
    HAS_ENHANCED_COMBO = False
    HAS_IMPROVED_CLICK = False
    EnhancedSearchableComboBox = None
    EnhancedSearchableComboBoxImproved = None

# استيراد تقويم التاريخ
try:
    from tkcalendar import DateEntry
    HAS_CALENDAR = True
except ImportError:
    HAS_CALENDAR = False
    class DateEntry:
        def __init__(self, parent, **kwargs):
            self.var = kwargs.get('textvariable', tk.StringVar())
            self.entry = ctk.CTkEntry(parent, textvariable=self.var, placeholder_text="YYYY-MM-DD")
            self.entry.pack(fill="x")
        def get(self): return self.var.get()
        def set(self, value): self.var.set(value)

from core.logger import logger


class AddEditWindow(ctk.CTkToplevel):
    """نافذة إضافة/تعديل محسنة ومبسطة مع إصلاح مشكلة رقم الحجز"""

    def __init__(self, parent=None, config_mgr=None, db_mgr=None, airtable_model=None,
                 controller=None, dropdown_manager=None, lang_manager=None,
                 field_groups=None, field_type_map=None, mode="add", record_id=None,
                 initial_fields=None):
        super().__init__(parent)

        # المتغيرات الأساسية
        self.parent = parent
        self.config_mgr = config_mgr
        self.db_mgr = db_mgr
        self.airtable_model = airtable_model
        self.controller = controller
        self.dropdown_manager = dropdown_manager
        self.lang_manager = lang_manager
        self.mode = mode
        self.record_id = record_id
        self.initial_fields = initial_fields or {}

        # النظام الموحد للثيم
        self.themed_window = ThemedWindow(self, controller.theme_manager if controller else None)

        # حالة النافذة
        self._is_closing = False
        self._save_in_progress = False
        self._offline_mode = False

        # إعداد البيانات
        self.field_groups = field_groups or self._get_default_field_groups()
        self.field_type_map = field_type_map or self._get_default_field_types()
        self.dropdown_mapping = self._get_dropdown_mapping()
        self.tab_names = list(self.field_groups.keys())

        # متغيرات الواجهة
        self.current_step = 0
        self.field_vars = {}
        self.field_widgets = {}
        self.combo_boxes = {}
        self.enhanced_combos = {}
        self.dropdown_options = {}

        # ملف المسودة
        self.draft_file = f"draft_{self.mode}_{datetime.now().strftime('%Y%m%d')}.json"

        # إعداد النافذة
        self._setup_window()
        self._load_dropdown_options()
        self._build_ui()
        self._setup_events()

        # ملء البيانات في وضع التعديل - محسن
        if self.mode == "edit" and self.initial_fields:
            # تأخير أطول للتأكد من اكتمال بناء الواجهة
            self.after(100, self._populate_fields)

            # تحديثات إضافية للحقول المحمية
            self.after(150, self._force_readonly_fields_update)
            self.after(150, self._ensure_booking_number_display)
            self.after(150, self._verify_readonly_fields)

            # تحديث نهائي شامل
            self.after(200, self._force_ui_refresh)
        elif self.mode == "add":
            self._try_load_draft()

    def _get_default_field_groups(self):
        """مجموعات الحقول الافتراضية"""
        return {
            "Basic Information": ["Customer Name", "Hotel Name", "Agency", "Booking Nr.", "Room number"],
            "Trip Details": ["trip Name", "Date Trip", "Option", "des", "Guide", "Product ID", "pickup time", "Remarks", "Add - Ons"],
            "Passenger Info": ["ADT", "CHD", "STD", "Youth", "Inf", "CHD Age"],
            "Contact Info": ["Customer Phone", "Customer Email", "Customer Country"],
            "Pricing Info": ["Total price USD", "Total price EUR", "Total price GBP", "Net Rate", "Currency", "Cost EGP", "Collecting on date Trip", "Management Option", "Add-on"]
        }

    def _get_default_field_types(self):
        """أنواع الحقول الافتراضية"""
        return {
            "Customer Name": "text", "Hotel Name": "text", "Agency": "dropdown",
            "Booking Nr.": "readonly",  # ← حقل محمي
            "Room number": "text", "trip Name": "dropdown", "Date Trip": "date", "Option": "dropdown",
            "des": "dropdown", "Guide": "dropdown", "Product ID": "text", "pickup time": "text",
            "Remarks": "text", "Add - Ons": "text", "ADT": "number", "CHD": "number", "STD": "number",
            "Youth": "number", "Inf": "number", "CHD Age": "text", "Customer Phone": "phone",
            "Customer Email": "email", "Customer Country": "text", "Total price USD": "currency",
            "Total price EUR": "currency", "Total price GBP": "currency", "Net Rate": "currency",
            "Currency": "text", "Cost EGP": "currency", "Collecting on date Trip": "text",
            "Management Option": "dropdown", "Add-on": "dropdown"
        }

    def _get_dropdown_mapping(self):
        """تخطيط القوائم المنسدلة"""
        if self.dropdown_manager and hasattr(self.dropdown_manager, 'get_field_mapping'):
            return self.dropdown_manager.get_field_mapping()
        return {
            "Agency": "agencies", "Guide": "guides", "Option": "options",
            "des": "destinations", "trip Name": "Trip Names",
            "Management Option": "management_options", "Add-on": "addons"
        }

    def _setup_window(self):
        """إعداد النافذة"""
        # إعداد النصوص أولاً للحصول على الترجمات
        self._setup_texts()

        title = f"➕ {self.texts['add']}" if self.mode == "add" else f"✏️ {self.texts['edit']}"
        self.title(title)

        # حساب أبعاد النافذة
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        window_width = 1000
        window_height = screen_height - 100
        x = (screen_width - window_width) // 2
        y = 20

        self.geometry(f"{window_width}x{window_height}+{x}+{y}")
        self.minsize(700, 500)
        self.resizable(True, True)

        if self.parent:
            self.transient(self.parent)
            self.grab_set()

        self.protocol("WM_DELETE_WINDOW", self._confirm_close)

    def _load_dropdown_options(self):
        """تحميل القوائم المنسدلة"""
        if not self.dropdown_manager:
            self._offline_mode = True
            self._setup_offline_dropdowns()
            return

        try:
            status = self.dropdown_manager.get_status()
            if status.get('cached_count', 0) > 0:
                self._load_from_cache()
            else:
                self._load_dropdowns_async()
        except Exception as e:
            logger.error(f"خطأ في تحميل القوائم: {e}")
            self._offline_mode = True
            self._setup_offline_dropdowns()

    def _load_from_cache(self):
        """تحميل من الكاش"""
        try:
            all_dropdowns = self.dropdown_manager.get_all_dropdowns()
            for field_name, airtable_key in self.dropdown_mapping.items():
                self.dropdown_options[field_name] = all_dropdowns.get(airtable_key, [])
            if 'Trip Names' in all_dropdowns:
                self.dropdown_options['trip Name'] = all_dropdowns['Trip Names']
        except Exception as e:
            logger.error(f"خطأ في تحميل من الكاش: {e}")
            self._setup_offline_dropdowns()

    def _load_dropdowns_async(self):
        """تحميل القوائم في الخلفية"""
        def load_thread():
            try:
                all_dropdowns = self.dropdown_manager.get_all_dropdowns(timeout=15.0)
                for field_name, airtable_key in self.dropdown_mapping.items():
                    self.dropdown_options[field_name] = all_dropdowns.get(airtable_key, [])
                if 'Trip Names' in all_dropdowns:
                    self.dropdown_options['trip Name'] = all_dropdowns['Trip Names']
            except Exception as e:
                logger.error(f"خطأ في التحميل: {e}")
                self._offline_mode = True
                self.after(0, self._setup_offline_dropdowns)

        threading.Thread(target=load_thread, daemon=True).start()

    def _setup_offline_dropdowns(self):
        """إعداد قوائم افتراضية"""
        defaults = {
            "Agency": ["Direct", "Online", "Partner"],
            "Guide": ["English", "Arabic", "German", "French"],
            "Option": ["Standard", "Premium", "VIP"],
            "des": ["Cairo", "Luxor", "Aswan", "Hurghada"],
            "trip Name": ["Pyramids Tour", "Nile Cruise", "Desert Safari"],
            "Management Option": ["Standard", "Express", "Custom"],
            "Add-on": ["Lunch", "Transport", "Guide", "Entrance Fees"]
        }
        for field_name in self.dropdown_mapping:
            if field_name not in self.dropdown_options:
                self.dropdown_options[field_name] = defaults.get(field_name, [])

    def _setup_texts(self):
        """إعداد النصوص والترجمات"""
        if not self.lang_manager:
            self.texts = {
                "add": "Add", "edit": "Edit", "save": "Save", "cancel": "Cancel",
                "draft": "Draft", "previous": "Previous", "next": "Next",
                "refresh": "Refresh", "success": "Success", "error": "Error",
                "warning": "Warning", "required_field": "This field is required",
                "save_success": "Saved successfully!", "update_success": "Updated successfully!",
                "draft_saved": "Draft saved successfully", "loading": "Loading...",
                "processing": "Processing...", "updating": "Updating..."
            }
        else:
            self.texts = {
                "add": self.lang_manager.get("add", "Add"),
                "edit": self.lang_manager.get("edit", "Edit"),
                "save": self.lang_manager.get("save", "Save"),
                "cancel": self.lang_manager.get("cancel", "Cancel"),
                "draft": self.lang_manager.get("draft", "Draft"),
                "previous": self.lang_manager.get("previous", "Previous"),
                "next": self.lang_manager.get("next", "Next"),
                "refresh": self.lang_manager.get("refresh", "Refresh"),
                "success": self.lang_manager.get("success", "Success"),
                "error": self.lang_manager.get("error", "Error"),
                "warning": self.lang_manager.get("warning", "Warning"),
                "required_field": self.lang_manager.get("required_field", "This field is required"),
                "save_success": self.lang_manager.get("save_success", "Saved successfully!"),
                "update_success": self.lang_manager.get("update_success", "Updated successfully!"),
                "draft_saved": self.lang_manager.get("draft_saved", "Draft saved successfully"),
                "loading": self.lang_manager.get("loading", "Loading..."),
                "processing": self.lang_manager.get("processing", "Processing..."),
                "updating": self.lang_manager.get("updating", "Updating...")
            }

    def _build_ui(self):
        """بناء واجهة المستخدم"""
        # الإطار الرئيسي
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # شريط التقدم
        self.progress_frame = ctk.CTkFrame(main_frame)
        self.progress_frame.pack(fill="x", pady=(0, 10))
        self._create_progress_buttons()

        # إطار المحتوى
        self.content_frame = ctk.CTkScrollableFrame(main_frame)
        self.content_frame.pack(fill="both", expand=True)

        # إنشاء التبويبات
        self.tab_frames = []
        for tab_name in self.tab_names:
            tab_frame = ctk.CTkFrame(self.content_frame)
            tab_frame.pack_forget()
            self.tab_frames.append(tab_frame)
            self._create_tab_content(tab_frame, tab_name)

        # أزرار التنقل
        self._create_navigation_buttons(main_frame)

        # عرض التبويب الأول
        self._show_tab(0)

        # تطبيق الثيم
        self.themed_window.apply_theme()

    def _create_progress_buttons(self):
        """إنشاء أزرار التقدم"""
        self.progress_buttons = []
        for i, name in enumerate(self.tab_names):
            translated_name = self._translate_tab_name(name)
            btn = ctk.CTkButton(
                self.progress_frame,
                text=f"{i+1}. {translated_name}",
                command=lambda idx=i: self._show_tab(idx),
                width=150, height=30
            )
            btn.pack(side="left", padx=5)
            self.progress_buttons.append(btn)

    def _create_tab_content(self, parent, tab_name):
        """إنشاء محتوى التبويب"""
        # عنوان التبويب
        title_frame = ctk.CTkFrame(parent, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 20))

        title_label = ctk.CTkLabel(
            title_frame,
            text=self._translate_tab_name(tab_name),
            font=ctk.CTkFont(size=18, weight="bold")
        )
        title_label.pack()

        # إطار الحقول
        fields_frame = ctk.CTkFrame(parent, fg_color="transparent")
        fields_frame.pack(fill="both", expand=True, padx=20)

        # إنشاء الحقول
        fields = self.field_groups.get(tab_name, [])
        for field_name in fields:
            self._create_field(fields_frame, field_name)

    def _create_field(self, parent, field_name):
        """إنشاء حقل واحد"""
        field_frame = ctk.CTkFrame(parent, fg_color="transparent")
        field_frame.pack(fill="x", pady=10)

        # التسمية
        label_text = self._translate_field_name(field_name)
        if field_name in ["Customer Name", "Agency", "Date Trip"]:
            label_text += " *"
        elif self.field_type_map.get(field_name) == "readonly":
            label_text += " 🔒"  # رمز القفل للحقول المحمية

        label = ctk.CTkLabel(
            field_frame, text=label_text, anchor="w",
            font=ctk.CTkFont(size=12, weight="bold")
        )
        label.pack(fill="x", pady=(0, 5))

        # الحقل
        initial_value = self._get_initial_value(field_name)
        field_type = self.field_type_map.get(field_name, "text")

        var, widget = self._create_field_by_type(field_frame, field_name, field_type, initial_value)

        if var and widget:
            self.field_vars[field_name] = var
            self.field_widgets[field_name] = widget

    def _create_field_by_type(self, parent, field_name, field_type, initial_value):
        """إنشاء حقل حسب النوع - دالة موحدة"""
        if field_type == "dropdown":
            return self._create_dropdown_field(parent, field_name, initial_value)
        elif field_type == "number":
            return self._create_number_field(parent, initial_value)
        elif field_type == "date":
            return self._create_date_field(parent, initial_value)
        elif field_type == "readonly":
            return self._create_readonly_field(parent, initial_value)
        else:
            return self._create_text_field(parent, field_type, initial_value)

    def _create_dropdown_field(self, parent, field_name, initial_value):
        """إنشاء قائمة منسدلة مع ربط أحداث خاصة"""
        values = self.dropdown_options.get(field_name, [])
        if initial_value and initial_value not in values:
            values = list(values) + [initial_value]

        # محاولة استخدام النسخة المحسنة من الملف الموحد
        if HAS_ENHANCED_COMBO and HAS_IMPROVED_CLICK:
            try:
                var, combo = create_enhanced_dropdown_with_improved_click(
                    parent=parent, field_name=field_name, initial_value=initial_value,
                    values=values, themed_window=self.themed_window
                )
                combo.pack(fill="x", pady=5)
                self.enhanced_combos[field_name] = combo

                # ربط حدث تغيير الوكالة لتوليد رقم الحجز
                if field_name == "Agency":
                    self._bind_agency_change_event(combo, var)

                return var, combo
            except Exception as e:
                logger.warning(f"فشل في إنشاء القائمة المحسنة: {e}")

        # القائمة العادية
        var = tk.StringVar(value=initial_value)
        combo = ctk.CTkComboBox(
            parent, values=values, variable=var,
            state="readonly" if self._offline_mode else "normal"
        )
        self.themed_window.apply_to_widget(combo, 'combobox')
        combo.pack(fill="x", pady=5)
        self.combo_boxes[field_name] = combo

        # ربط حدث تغيير الوكالة لتوليد رقم الحجز
        if field_name == "Agency":
            self._bind_agency_change_event(combo, var)

        return var, combo

    def _bind_agency_change_event(self, combo, var):
        """ربط حدث تغيير الوكالة لتوليد رقم الحجز تلقائياً"""
        def on_agency_change(*args):
            # التأكد من أننا في وضع الإضافة وليس التعديل
            if self.mode == "add":
                agency_value = var.get()
                if agency_value and agency_value.strip():
                    # توليد رقم الحجز الجديد
                    booking_nr = self._generate_booking_number(agency_value)
                    # تحديث حقل رقم الحجز
                    self._update_booking_number_field(booking_nr)
                    logger.info(f"تم توليد رقم حجز جديد: {booking_nr} للوكالة: {agency_value}")

        # ربط الحدث بمتغير الوكالة
        var.trace('w', on_agency_change)

        # ربط حدث إضافي للقوائم المحسنة
        if hasattr(combo, 'bind'):
            combo.bind('<<ComboboxSelected>>', lambda e: on_agency_change())

    def _generate_booking_number(self, agency_name):
        """توليد رقم حجز جديد بالتنسيق المطلوب"""
        try:
            # الحصول على أول ثلاثة أحرف من الوكالة
            agency_prefix = agency_name[:3].upper().replace(' ', '')
            if len(agency_prefix) < 3:
                agency_prefix = agency_prefix.ljust(3, 'X')  # ملء بـ X إذا كان أقل من 3 أحرف

            # التوقيت الحالي بصيغة hhmmss
            current_time = datetime.now()
            time_part = current_time.strftime("%H%M%S")

            # خمسة أرقام وحروف عشوائية
            random_chars = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))

            # تجميع رقم الحجز
            booking_number = f"{agency_prefix}-{time_part}-{random_chars}"

            logger.info(f"تم توليد رقم الحجز: {booking_number}")
            return booking_number

        except Exception as e:
            logger.error(f"خطأ في توليد رقم الحجز: {e}")
            # رقم احتياطي في حالة الخطأ
            fallback_time = datetime.now().strftime("%H%M%S")
            fallback_random = ''.join(random.choices(string.ascii_lowercase + string.digits, k=5))
            return f"BKG-{fallback_time}-{fallback_random}"

    def _update_booking_number_field(self, booking_number):
        """تحديث حقل رقم الحجز بالقيمة الجديدة"""
        try:
            if "Booking Nr." in self.field_vars:
                booking_var = self.field_vars["Booking Nr."]
                booking_var.set(booking_number)

                # إجبار تحديث الـ widget إذا كان موجوداً
                if "Booking Nr." in self.field_widgets:
                    widget = self.field_widgets["Booking Nr."]

                    # محاولة تحديث الـ widget مباشرة للحقول المحمية
                    try:
                        if hasattr(widget, 'configure'):
                            # تفعيل مؤقت للتحديث
                            original_state = widget.cget('state')
                            widget.configure(state='normal')

                            # مسح وإدراج القيمة الجديدة
                            if hasattr(widget, 'delete') and hasattr(widget, 'insert'):
                                widget.delete(0, tk.END)
                                widget.insert(0, booking_number)

                            # إعادة الحالة الأصلية
                            widget.configure(state=original_state)

                    except Exception as widget_error:
                        logger.warning(f"فشل في تحديث widget مباشرة: {widget_error}")

                logger.info(f"تم تحديث حقل رقم الحجز: {booking_number}")

        except Exception as e:
            logger.error(f"خطأ في تحديث حقل رقم الحجز: {e}")

    def _create_readonly_field(self, parent, initial_value):
        """إنشاء حقل للقراءة فقط - إصلاح محسن"""
        var = tk.StringVar()

        # تعيين القيمة الأولية إذا كانت موجودة
        if initial_value:
            processed_value = self._process_complex_value(initial_value)
            var.set(str(processed_value) if processed_value else "")

        # استخدام CTkEntry مع تخصيص للحقول المحمية
        widget = ctk.CTkEntry(
            parent,
            textvariable=var,
            state="readonly",
            fg_color="#f8f9fa",  # لون خلفية أفتح للحقول المحمية
            text_color="#495057",  # لون نص أوضح
            border_width=1,
            border_color="#dee2e6",
            font=ctk.CTkFont(size=12)
        )

        widget.pack(fill="x", pady=5)

        # إضافة وظيفة مساعدة لتحديث القيمة
        def update_readonly_value(new_value):
            """تحديث قيمة الحقل المحمي"""
            try:
                # حفظ الحالة الأصلية
                original_state = widget.cget('state')

                # تفعيل الحقل مؤقتاً
                widget.configure(state='normal')

                # مسح وتحديث المحتوى
                widget.delete(0, tk.END)
                widget.insert(0, str(new_value) if new_value else "")

                # إعادة الحالة المحمية
                widget.configure(state='readonly')

                # تحديث المتغير أيضاً
                var.set(str(new_value) if new_value else "")

            except Exception as e:
                logger.error(f"خطأ في تحديث الحقل المحمي: {e}")

        # ربط الوظيفة بالـ widget
        widget.update_readonly_value = update_readonly_value

        return var, widget

    def _create_text_field(self, parent, field_type, initial_value):
        """إنشاء حقل نص"""
        var = tk.StringVar(value=str(initial_value) if initial_value else "")
        placeholder = {"phone": "01x xxxx xxxx", "email": "example@email.com", "currency": "0.00"}.get(field_type, "")

        widget = ctk.CTkEntry(parent, textvariable=var, placeholder_text=placeholder)
        self.themed_window.apply_to_widget(widget, 'entry')
        widget.pack(fill="x", pady=5)
        return var, widget

    def _create_number_field(self, parent, initial_value):
        """إنشاء حقل رقمي"""
        var = tk.IntVar(value=int(initial_value) if initial_value else 0)
        widget = ctk.CTkEntry(parent, textvariable=var, justify="center")
        self.themed_window.apply_to_widget(widget, 'entry')
        widget.pack(fill="x", pady=5)
        return var, widget

    def _create_date_field(self, parent, initial_value):
        """إنشاء حقل تاريخ"""
        date_value = self._parse_date(str(initial_value)) if initial_value else ""
        var = tk.StringVar(value=date_value)

        if HAS_CALENDAR:
            widget = DateEntry(parent, textvariable=var, date_pattern='yyyy-mm-dd')
            widget.pack(fill="x", pady=5)
        else:
            widget = ctk.CTkEntry(parent, textvariable=var, placeholder_text="YYYY-MM-DD")
            self.themed_window.apply_to_widget(widget, 'entry')
            widget.pack(fill="x", pady=5)

        return var, widget

    def _create_navigation_buttons(self, parent):
        """إنشاء أزرار التنقل"""
        nav_frame = ctk.CTkFrame(parent)
        nav_frame.pack(fill="x", pady=10)

        # الأزرار اليسرى
        left_frame = ctk.CTkFrame(nav_frame, fg_color="transparent")
        left_frame.pack(side="left", fill="x", expand=True)

        self.prev_btn = ctk.CTkButton(left_frame, text=f"◀ {self.texts['previous']}", command=self._prev_tab, width=100)
        self.prev_btn.pack(side="left", padx=5)

        self.next_btn = ctk.CTkButton(left_frame, text=f"{self.texts['next']} ▶", command=self._next_tab, width=100)
        self.next_btn.pack(side="left", padx=5)

        self.refresh_btn = ctk.CTkButton(left_frame, text=f"🔄 {self.texts['refresh']}", command=self._refresh_dropdowns, width=120)
        self.refresh_btn.pack(side="left", padx=5)

        # الأزرار اليمنى
        right_frame = ctk.CTkFrame(nav_frame, fg_color="transparent")
        right_frame.pack(side="right")

        self.cancel_btn = ctk.CTkButton(right_frame, text=f"❌ {self.texts['cancel']}", command=self._confirm_close, width=100)
        self.cancel_btn.pack(side="right", padx=5)

        self.draft_btn = ctk.CTkButton(right_frame, text=f"📝 {self.texts['draft']}", command=self._save_draft, width=100)
        self.draft_btn.pack(side="right", padx=5)

        self.save_btn = ctk.CTkButton(right_frame, text=f"💾 {self.texts['save']}", command=self._save, width=120, font=ctk.CTkFont(size=14, weight="bold"))
        self.save_btn.pack(side="right", padx=5)

    def _setup_events(self):
        """إعداد الأحداث واختصارات لوحة المفاتيح"""
        self.bind('<Control-s>', lambda e: self._save())
        self.bind('<Control-d>', lambda e: self._save_draft())
        self.bind('<Escape>', lambda e: self._confirm_close())
        self.bind('<Control-Right>', lambda e: self._next_tab())
        self.bind('<Control-Left>', lambda e: self._prev_tab())

    def _show_tab(self, index):
        """عرض تبويب محدد"""
        for frame in self.tab_frames:
            frame.pack_forget()

        if 0 <= index < len(self.tab_frames):
            self.tab_frames[index].pack(fill="both", expand=True)
            self.current_step = index

            self.prev_btn.configure(state="normal" if index > 0 else "disabled")
            self.next_btn.configure(state="normal" if index < len(self.tab_frames) - 1 else "disabled")

            # تحديث ألوان أزرار التقدم
            for i, btn in enumerate(self.progress_buttons):
                if i == index:
                    btn.configure(fg_color=self.themed_window.get_color('primary'))
                elif i < index:
                    btn.configure(fg_color=self.themed_window.get_color('success'))
                else:
                    btn.configure(fg_color=self.themed_window.get_color('surface'))

    def _prev_tab(self):
        """التبويب السابق"""
        if self.current_step > 0:
            self._show_tab(self.current_step - 1)

    def _next_tab(self):
        """التبويب التالي"""
        if self.current_step < len(self.tab_frames) - 1:
            self._show_tab(self.current_step + 1)

    def _save(self):
        """حفظ البيانات"""
        if self._save_in_progress or not self._validate_form():
            return

        self._save_in_progress = True
        data = self._collect_data()

        def save_operation():
            try:
                if self.mode == "add":
                    result = self.controller.create_record(data)
                else:
                    result = self.controller.update_record(self.record_id, data)

                if result:
                    success_msg = self.texts['save_success'] if self.mode == "add" else self.texts['update_success']
                    self.after(0, lambda: [
                        messagebox.showinfo(self.texts['success'], success_msg),
                        self._delete_draft(),
                        self.destroy()
                    ])
                else:
                    raise Exception("فشل الحفظ")
            except Exception as e:
                error_msg = f"خطأ في الحفظ: {str(e)}"
                self.after(0, lambda: messagebox.showerror(self.texts['error'], error_msg))
            finally:
                self._save_in_progress = False

        threading.Thread(target=save_operation, daemon=True).start()

    def _validate_form(self):
        """التحقق من صحة النموذج"""
        required_fields = ["Customer Name", "Agency", "Date Trip"]
        for field_name in required_fields:
            if field_name in self.field_widgets:
                value = self._get_widget_value(self.field_widgets[field_name])
                if not value or not value.strip():
                    messagebox.showerror(self.texts['error'], f"{self.texts['required_field']}: {self._translate_field_name(field_name)}")
                    return False
        return True

    def _collect_data(self):
        """جمع البيانات من جميع الحقول"""
        data = {}
        for field_name, widget in self.field_widgets.items():
            value = self._get_widget_value(widget)
            if value:
                field_type = self.field_type_map.get(field_name, "text")
                if field_type == "number":
                    try:
                        data[field_name] = int(value)
                    except ValueError:
                        data[field_name] = 0
                elif field_type == "currency":
                    try:
                        data[field_name] = float(str(value).replace(',', '').strip())
                    except ValueError:
                        data[field_name] = value
                else:
                    data[field_name] = value
        return data

    def _get_widget_value(self, widget):
        """الحصول على قيمة من widget - إصلاح محسن للحقول المحمية"""
        try:
            # المحاولة الأولى: الطريقة العادية
            if hasattr(widget, 'get'):
                value = widget.get()
                return value.strip() if isinstance(value, str) else value

        except tk.TclError as tcl_error:
            # للحقول المحمية، جرب طرق بديلة
            try:
                # محاولة الوصول للمتغير المرتبط
                if hasattr(widget, 'cget'):
                    textvariable = widget.cget('textvariable')
                    if textvariable and hasattr(textvariable, 'get'):
                        value = textvariable.get()
                        logger.debug(f"✅ تم الحصول على قيمة من textvariable: {value}")
                        return value.strip() if isinstance(value, str) else value

                # محاولة قراءة المحتوى مباشرة (للحقول المحمية)
                if hasattr(widget, 'configure'):
                    # تفعيل مؤقت للقراءة
                    original_state = widget.cget('state')
                    widget.configure(state='normal')

                    try:
                        value = widget.get()
                        widget.configure(state=original_state)
                        logger.debug(f"✅ تم الحصول على قيمة بتفعيل مؤقت: {value}")
                        return value.strip() if isinstance(value, str) else value
                    except:
                        widget.configure(state=original_state)
                        raise

            except Exception as e:
                logger.error(f"❌ فشل في جميع محاولات قراءة القيمة: {e}")

        except Exception as e:
            logger.error(f"❌ خطأ عام في قراءة قيمة widget: {e}")

        return ""

    def _save_draft(self):
        """حفظ المسودة"""
        try:
            data = self._collect_data()
            draft_data = {
                "timestamp": datetime.now().isoformat(),
                "mode": self.mode,
                "data": data
            }

            os.makedirs("drafts", exist_ok=True)
            with open(f"drafts/{self.draft_file}", 'w', encoding='utf-8') as f:
                json.dump(draft_data, f, ensure_ascii=False, indent=2)

            messagebox.showinfo(self.texts['success'], self.texts['draft_saved'])
        except Exception as e:
            messagebox.showerror(self.texts['error'], f"فشل حفظ المسودة: {str(e)}")

    def _try_load_draft(self):
        """محاولة تحميل مسودة"""
        try:
            draft_path = f"drafts/{self.draft_file}"
            if os.path.exists(draft_path):
                if messagebox.askyesno("مسودة موجودة", "هل تريد تحميل المسودة المحفوظة؟"):
                    with open(draft_path, 'r', encoding='utf-8') as f:
                        draft_data = json.load(f)
                    self._load_draft_data(draft_data.get("data", {}))
        except Exception as e:
            logger.error(f"خطأ في تحميل المسودة: {e}")

    def _load_draft_data(self, data):
        """تحميل بيانات المسودة"""
        for field_name, value in data.items():
            if field_name in self.field_vars:
                try:
                    var = self.field_vars[field_name]
                    if isinstance(var, tk.IntVar):
                        var.set(int(value) if value else 0)
                    else:
                        var.set(str(value) if value else "")
                except Exception as e:
                    logger.warning(f"خطأ في تحميل {field_name}: {e}")

    def _delete_draft(self):
        """حذف المسودة"""
        try:
            draft_path = f"drafts/{self.draft_file}"
            if os.path.exists(draft_path):
                os.remove(draft_path)
        except Exception as e:
            logger.warning(f"خطأ في حذف المسودة: {e}")

    def _refresh_dropdowns(self):
        """تحديث القوائم المنسدلة"""
        if not self.dropdown_manager:
            messagebox.showinfo(self.texts['error'], "خدمة القوائم غير متاحة")
            return

        def refresh_thread():
            try:
                self.dropdown_manager.refresh_all()
                self._load_from_cache()
                self._update_combo_boxes()
                self.after(0, lambda: messagebox.showinfo(self.texts['success'], "تم تحديث القوائم بنجاح"))
            except Exception as e:
                self.after(0, lambda: messagebox.showerror(self.texts['error'], f"فشل التحديث: {str(e)}"))

        threading.Thread(target=refresh_thread, daemon=True).start()

    def _update_combo_boxes(self):
        """تحديث جميع القوائم المنسدلة"""
        # تحديث القوائم العادية
        for field_name, combo in self.combo_boxes.items():
            if field_name in self.dropdown_options:
                try:
                    current_value = combo.get()
                    new_values = self.dropdown_options[field_name]
                    combo.configure(values=new_values)
                    if current_value in new_values:
                        combo.set(current_value)
                except Exception as e:
                    logger.warning(f"فشل تحديث {field_name}: {e}")

        # تحديث القوائم المحسنة
        for field_name, combo in self.enhanced_combos.items():
            if field_name in self.dropdown_options:
                try:
                    current_value = combo.get()
                    new_values = self.dropdown_options[field_name]
                    combo.set_values(new_values)
                    if current_value in new_values:
                        combo.set(current_value)
                except Exception as e:
                    logger.warning(f"فشل تحديث القائمة المحسنة {field_name}: {e}")

    def _confirm_close(self):
        """تأكيد الإغلاق"""
        if self._has_unsaved_changes():
            result = messagebox.askyesnocancel("تغييرات غير محفوظة", "هل تريد حفظ المسودة قبل الإغلاق؟")
            if result is True:
                self._save_draft()
                self.destroy()
            elif result is False:
                self.destroy()
        else:
            self.destroy()

    def _has_unsaved_changes(self):
        """فحص التغييرات غير المحفوظة"""
        if self.mode == "add":
            for var in self.field_vars.values():
                if isinstance(var, tk.IntVar) and var.get() != 0:
                    return True
                elif isinstance(var, tk.StringVar) and var.get():
                    return True
        return False

    def _populate_fields(self):
        """ملء الحقول بالبيانات الأولية - إصلاح محسن مع تركيز على الحقول المحمية"""
        logger.info(f"🚀 بدء ملء الحقول المحسن - عدد الحقول: {len(self.initial_fields)}")

        populated_count = 0
        failed_count = 0
        skipped_count = 0
        readonly_count = 0

        for field_name, value in self.initial_fields.items():
            try:
                # التحقق من وجود الحقل
                if field_name not in self.field_vars:
                    logger.warning(f"⚠️ الحقل '{field_name}' غير موجود في field_vars")
                    skipped_count += 1
                    continue

                # معالجة القيمة
                if value is None or (isinstance(value, str) and not value.strip()):
                    logger.debug(f"⏭️ تخطي الحقل '{field_name}' - قيمة فارغة")
                    skipped_count += 1
                    continue

                processed_value = self._process_complex_value(value)
                logger.info(f"🔄 معالجة الحقل '{field_name}': {value} → {processed_value}")

                if not processed_value:
                    logger.warning(f"⚠️ فشل في معالجة قيمة الحقل '{field_name}': {value}")
                    failed_count += 1
                    continue

                # فحص نوع الحقل
                field_type = self.field_type_map.get(field_name, "text")

                # تعيين القيمة في المتغير أولاً
                var = self.field_vars[field_name]

                if isinstance(var, tk.IntVar):
                    try:
                        int_value = int(float(str(processed_value))) if processed_value else 0
                        var.set(int_value)
                        logger.debug(f"📊 تم تعيين قيمة رقمية للحقل '{field_name}': {int_value}")
                    except (ValueError, TypeError) as e:
                        logger.error(f"❌ خطأ في تحويل القيمة الرقمية للحقل '{field_name}': {e}")
                        var.set(0)
                        failed_count += 1
                        continue
                else:
                    var.set(str(processed_value))
                    logger.debug(f"📝 تم تعيين قيمة نصية للحقل '{field_name}': {processed_value}")

                # معالجة خاصة للحقول المحمية
                if field_type == "readonly":
                    readonly_count += 1
                    logger.info(f"🔒 معالجة حقل محمي: '{field_name}' = '{processed_value}'")

                    # تحديث فوري للحقل المحمي
                    self._force_widget_update(field_name, processed_value)

                    # تحديث إضافي متأخر للتأكد
                    self.after(50, lambda fn=field_name, pv=processed_value: self._force_widget_update(fn, pv))
                    self.after(100, lambda fn=field_name, pv=processed_value: self._force_widget_update(fn, pv))

                else:
                    # للحقول العادية
                    self._force_widget_update(field_name, processed_value)

                # معالجة خاصة للقوائم المنسدلة
                if field_name in self.combo_boxes or field_name in self.enhanced_combos:
                    self._handle_dropdown_value(field_name, processed_value)

                populated_count += 1

            except Exception as e:
                failed_count += 1
                logger.error(f"❌ خطأ في ملء الحقل '{field_name}': {e}")
                import traceback
                traceback.print_exc()

        logger.info(f"📊 نتائج ملء الحقول:")
        logger.info(f"  ✅ نجح: {populated_count}")
        logger.info(f"  🔒 حقول محمية: {readonly_count}")
        logger.info(f"  ❌ فشل: {failed_count}")
        logger.info(f"  ⏭️ تم تخطي: {skipped_count}")

        # تحديثات إضافية متأخرة للحقول المحمية
        self.after(100, self._force_readonly_fields_update)
        self.after(150, self._force_readonly_fields_update)
        self.after(150, self._verify_readonly_fields)

    def _force_readonly_fields_update(self):
        """إجبار تحديث خاص للحقول المحمية"""
        logger.info("🔒 إجبار تحديث الحقول المحمية...")

        for field_name, value in self.initial_fields.items():
            field_type = self.field_type_map.get(field_name, "text")

            if field_type == "readonly" and value:
                processed_value = self._process_complex_value(value)
                if processed_value:
                    logger.info(f"🔄 إعادة تحديث الحقل المحمي '{field_name}': {processed_value}")
                    self._force_widget_update(field_name, processed_value)

    def _verify_readonly_fields(self):
        """فحص والتحقق من الحقول المحمية"""
        logger.info("🔍 فحص الحقول المحمية...")

        for field_name in self.field_widgets.keys():
            field_type = self.field_type_map.get(field_name, "text")

            if field_type == "readonly":
                try:
                    widget = self.field_widgets[field_name]
                    var = self.field_vars.get(field_name)
                    expected_value = self.initial_fields.get(field_name)

                    if expected_value:
                        processed_expected = self._process_complex_value(expected_value)
                        current_var_value = var.get() if var else ""

                        # محاولة قراءة القيمة من الـ widget
                        try:
                            widget_value = self._get_widget_value(widget)
                        except:
                            widget_value = ""

                        logger.info(f"🔍 فحص '{field_name}':")
                        logger.info(f"  📝 متوقع: '{processed_expected}'")
                        logger.info(f"  🔧 متغير: '{current_var_value}'")
                        logger.info(f"  🖼️ widget: '{widget_value}'")

                        # إذا كانت القيم غير متطابقة، أصلحها
                        if str(current_var_value) != str(processed_expected) or str(widget_value) != str(processed_expected):
                            logger.warning(f"⚠️ عدم تطابق في الحقل المحمي '{field_name}' - إصلاح...")
                            self._force_widget_update(field_name, processed_expected)

                except Exception as e:
                    logger.error(f"❌ خطأ في فحص الحقل المحمي '{field_name}': {e}")

    def _ensure_booking_number_display(self):
        """ضمان عرض رقم الحجز بشكل صحيح"""
        booking_field = "Booking Nr."

        if booking_field in self.initial_fields:
            booking_value = self.initial_fields[booking_field]
            processed_booking = self._process_complex_value(booking_value)

            logger.info(f"🎫 ضمان عرض رقم الحجز: '{processed_booking}'")

            if processed_booking:
                # تحديث المتغير
                if booking_field in self.field_vars:
                    self.field_vars[booking_field].set(processed_booking)

                # تحديث الـ widget مباشرة
                if booking_field in self.field_widgets:
                    widget = self.field_widgets[booking_field]

                    try:
                        # للحقول المحمية
                        original_state = widget.cget('state')
                        widget.configure(state='normal')
                        widget.delete(0, tk.END)
                        widget.insert(0, processed_booking)
                        widget.configure(state=original_state)

                        logger.info(f"✅ تم ضمان عرض رقم الحجز: '{processed_booking}'")

                    except Exception as e:
                        logger.error(f"❌ فشل في ضمان عرض رقم الحجز: {e}")

    def _force_widget_update(self, field_name, value):
        """إجبار تحديث widget محدد - إصلاح محسن للحقول المحمية"""
        try:
            if field_name in self.field_widgets:
                widget = self.field_widgets[field_name]

                # فحص إذا كان الحقل محمياً
                field_type = self.field_type_map.get(field_name, "text")

                if field_type == "readonly":
                    # معالجة خاصة للحقول المحمية
                    if hasattr(widget, 'update_readonly_value'):
                        # استخدام الوظيفة المخصصة
                        widget.update_readonly_value(value)
                        logger.debug(f"✅ تم تحديث الحقل المحمي '{field_name}' بالوظيفة المخصصة: {value}")
                    else:
                        # الطريقة التقليدية
                        try:
                            original_state = widget.cget('state')
                            widget.configure(state='normal')
                            widget.delete(0, tk.END)
                            widget.insert(0, str(value))
                            widget.configure(state=original_state)
                            logger.debug(f"✅ تم تحديث الحقل المحمي '{field_name}' بالطريقة التقليدية: {value}")
                        except Exception as readonly_error:
                            logger.error(f"❌ فشل تحديث الحقل المحمي '{field_name}': {readonly_error}")

                            # محاولة تحديث المتغير على الأقل
                            if field_name in self.field_vars:
                                self.field_vars[field_name].set(str(value))

                # للحقول العادية
                elif hasattr(widget, 'delete') and hasattr(widget, 'insert'):
                    try:
                        widget.delete(0, tk.END)
                        widget.insert(0, str(value))
                        logger.debug(f"✅ تم تحديث الحقل العادي '{field_name}': {value}")
                    except tk.TclError as e:
                        logger.error(f"❌ خطأ Tcl في تحديث '{field_name}': {e}")

                # للقوائم المنسدلة
                elif hasattr(widget, 'set'):
                    widget.set(str(value))
                    logger.debug(f"✅ تم تحديث القائمة المنسدلة '{field_name}': {value}")

                # إجبار التحديث المرئي
                widget.update_idletasks()

        except Exception as e:
            logger.error(f"❌ خطأ عام في إجبار تحديث widget '{field_name}': {e}")

    def _force_ui_refresh(self):
        """إجبار تحديث شامل للواجهة"""
        try:
            logger.info("🔄 إجبار تحديث شامل للواجهة...")

            # تحديث جميع المتغيرات مرة أخرى
            for field_name, value in self.initial_fields.items():
                if field_name in self.field_vars and value:
                    try:
                        processed_value = self._process_complex_value(value)
                        if processed_value:
                            var = self.field_vars[field_name]
                            current_value = var.get()

                            # إذا كانت القيمة مختلفة، أعد تعيينها
                            if str(current_value) != str(processed_value):
                                if isinstance(var, tk.IntVar):
                                    var.set(int(float(str(processed_value))) if processed_value else 0)
                                else:
                                    var.set(str(processed_value))
                                logger.debug(f"🔄 إعادة تعيين '{field_name}': {processed_value}")

                            # إجبار تحديث الـ widget مباشرة
                            self._force_widget_update(field_name, processed_value)

                    except Exception as e:
                        logger.error(f"خطأ في التحديث الشامل للحقل '{field_name}': {e}")

            # تحديث النافذة بالكامل
            self.update_idletasks()
            self.update()

            logger.info("✅ اكتمل التحديث الشامل للواجهة")

        except Exception as e:
            logger.error(f"خطأ في التحديث الشامل: {e}")

    def _handle_dropdown_value(self, field_name, value):
        """معالجة خاصة لقيم القوائم المنسدلة - محسنة"""
        try:
            # التحقق من القوائم العادية
            if field_name in self.combo_boxes:
                combo = self.combo_boxes[field_name]
                current_values = list(combo.cget("values"))

                # إذا كانت القيمة غير موجودة، أضفها
                if value not in current_values:
                    new_values = current_values + [value]
                    combo.configure(values=new_values)
                    logger.info(f"تم إضافة القيمة '{value}' إلى القائمة '{field_name}'")

                # تعيين القيمة مع تأخير للتأكد
                combo.set(value)
                self.after(50, lambda: combo.set(value))  # إعادة تعيين مع تأخير
                logger.debug(f"تم تعيين قيمة القائمة العادية '{field_name}': {value}")

            # التحقق من القوائم المحسنة
            elif field_name in self.enhanced_combos:
                combo = self.enhanced_combos[field_name]

                # الحصول على القيم الحالية
                current_values = []
                if hasattr(combo, 'values'):
                    current_values = list(combo.values)
                elif hasattr(combo, 'filtered_values'):
                    current_values = list(combo.filtered_values)

                # إذا كانت القيمة غير موجودة، أضفها
                if value not in current_values:
                    if hasattr(combo, 'add_value'):
                        combo.add_value(value)
                    elif hasattr(combo, 'set_values'):
                        new_values = current_values + [value]
                        combo.set_values(new_values)
                    logger.info(f"تم إضافة القيمة '{value}' إلى القائمة المحسنة '{field_name}'")

                # تعيين القيمة مع تأخير للتأكد
                if hasattr(combo, 'set'):
                    combo.set(value)
                    self.after(50, lambda: combo.set(value))  # إعادة تعيين مع تأخير
                    logger.debug(f"تم تعيين قيمة القائمة المحسنة '{field_name}': {value}")

        except Exception as e:
            logger.error(f"خطأ في معالجة قيمة القائمة المنسدلة '{field_name}': {e}")

    def _verify_dropdown_values(self):
        """فحص إضافي مع إصلاح فوري"""
        logger.info("🔍 بدء فحص وإصلاح قيم القوائم المنسدلة...")

        fixed_count = 0

        for field_name in self.dropdown_mapping.keys():
            if field_name in self.field_vars:
                try:
                    expected_value = self.field_vars[field_name].get()

                    if not expected_value:
                        continue

                    if field_name in self.combo_boxes:
                        combo = self.combo_boxes[field_name]
                        actual_value = combo.get()

                        if str(expected_value) != str(actual_value):
                            logger.warning(f"⚠️ عدم تطابق في القائمة '{field_name}': متوقع='{expected_value}', فعلي='{actual_value}'")

                            # إضافة القيمة إذا لم تكن موجودة
                            current_values = list(combo.cget("values"))
                            if expected_value not in current_values:
                                new_values = current_values + [expected_value]
                                combo.configure(values=new_values)

                            # إعادة تعيين القيمة بقوة
                            combo.set(expected_value)
                            self.after(10, lambda v=expected_value, c=combo: c.set(v))
                            fixed_count += 1
                            logger.info(f"✅ تم إصلاح قيمة القائمة '{field_name}' إلى '{expected_value}'")

                    elif field_name in self.enhanced_combos:
                        combo = self.enhanced_combos[field_name]
                        actual_value = combo.get() if hasattr(combo, 'get') else ""

                        if str(expected_value) != str(actual_value):
                            logger.warning(f"⚠️ عدم تطابق في القائمة المحسنة '{field_name}': متوقع='{expected_value}', فعلي='{actual_value}'")

                            # إضافة القيمة إذا لم تكن موجودة
                            if hasattr(combo, 'add_value'):
                                combo.add_value(expected_value)

                            # إعادة تعيين القيمة
                            if hasattr(combo, 'set'):
                                combo.set(expected_value)
                                self.after(10, lambda v=expected_value, c=combo: c.set(v))
                            fixed_count += 1
                            logger.info(f"✅ تم إصلاح قيمة القائمة المحسنة '{field_name}' إلى '{expected_value}'")

                except Exception as e:
                    logger.error(f"❌ خطأ في فحص القائمة '{field_name}': {e}")

        if fixed_count > 0:
            logger.info(f"🔧 تم إصلاح {fixed_count} قائمة منسدلة")
            # تحديث نهائي للواجهة
            self.after(100, lambda: self.update_idletasks())

    def _process_complex_value(self, value):
        """معالجة محسنة للقيم المعقدة من Airtable"""
        if value is None:
            return ""

        # إضافة logging للتشخيص
        logger.debug(f"Processing complex value: {type(value)} = {value}")

        # معالجة الـ dictionaries
        if isinstance(value, dict):
            # ترتيب أولوية استخراج القيم
            for key in ['name', 'label', 'value', 'text', 'title', 'display_name', 'url', 'id']:
                if key in value and value[key]:
                    result = str(value[key]).strip()
                    logger.debug(f"Extracted from dict[{key}]: {result}")
                    return result
            # إذا لم نجد شيء، أرجع أول قيمة غير فارغة
            for key, val in value.items():
                if val and str(val).strip():
                    result = str(val).strip()
                    logger.debug(f"Fallback from dict[{key}]: {result}")
                    return result
            return ""

        # معالجة الـ arrays
        elif isinstance(value, list):
            if not value:
                return ""
            # إذا كان عنصر واحد، استخدمه
            if len(value) == 1:
                return self._process_complex_value(value[0])
            # إذا كان أكثر من عنصر، اجمعهم
            processed_values = []
            for item in value:
                processed = self._process_complex_value(item)
                if processed:
                    processed_values.append(processed)
            result = ", ".join(processed_values) if processed_values else ""
            logger.debug(f"Processed array: {result}")
            return result

        # القيم البسيطة
        else:
            result = str(value).strip() if value else ""
            logger.debug(f"Simple value: {result}")
            return result

    def _parse_date(self, date_str):
        """تحليل التاريخ"""
        if not date_str:
            return ""
        try:
            if 'T' in date_str:
                return date_str.split('T')[0]
            if len(date_str) == 10 and date_str.count('-') == 2:
                return date_str
            return date_str
        except:
            return date_str

    def _translate_text(self, text):
        """ترجمة النص العام"""
        if not self.lang_manager:
            return text
        key = text.lower().replace(" ", "_")
        return self.lang_manager.get(key, text)

    def _translate_tab_name(self, tab_name):
        """ترجمة أسماء التبويبات بشكل محدد"""
        if not self.lang_manager:
            return tab_name

        # خريطة ترجمة محددة للتبويبات
        tab_translations = {
            "Basic Information": "basic_info",
            "Trip Details": "trip_details",
            "Passenger Info": "passenger_info",
            "Contact Info": "contact_info",
            "Pricing Info": "pricing_info",
            "معلومات أساسية": "basic_info",
            "تفاصيل الرحلة": "trip_details",
            "معلومات الركاب": "passenger_info",
            "معلومات الاتصال": "contact_info",
            "معلومات الأسعار": "pricing_info"
        }

        key = tab_translations.get(tab_name, tab_name.lower().replace(" ", "_"))
        return self.lang_manager.get(key, tab_name)

    def _translate_field_name(self, field_name):
        """ترجمة اسم الحقل"""
        if not self.lang_manager:
            return field_name

        # خريطة ترجمة محددة للحقول
        field_translations = {
            "Customer Name": "customer_name",
            "Hotel Name": "hotel_name",
            "Agency": "agency",
            "Booking Nr.": "booking_number",
            "Room number": "room_number",
            "trip Name": "trip_name",
            "Date Trip": "trip_date",
            "Option": "option",
            "des": "destination",
            "Guide": "guide",
            "Product ID": "product_id",
            "pickup time": "pickup_time",
            "Remarks": "remarks",
            "Add - Ons": "add_ons",
            "ADT": "adults",
            "CHD": "children",
            "STD": "students",
            "Youth": "youth",
            "Inf": "infants",
            "CHD Age": "children_ages",
            "Customer Phone": "phone_number",
            "Customer Email": "email",
            "Customer Country": "customer_country",
            "Total price USD": "total_price_usd",
            "Total price EUR": "total_price_eur",
            "Total price GBP": "total_price_gbp",
            "Net Rate": "net_rate",
            "Currency": "currency",
            "Cost EGP": "cost_egp",
            "Collecting on date Trip": "collecting_on_date",
            "Management Option": "management_option",
            "Add-on": "add_on"
        }

        key = field_translations.get(field_name, field_name.lower().replace(" ", "_"))
        return self.lang_manager.get(key, field_name)

    def update_language(self, lang_manager):
        """تحديث لغة النافذة"""
        self.lang_manager = lang_manager
        self._setup_texts()  # إعادة إعداد النصوص

        # تحديث عنوان النافذة
        title = "➕ " + self.texts.get("add", "Add") if self.mode == "add" else "✏️ " + self.texts.get("edit", "Edit")
        self.title(title)

        # تحديث أزرار التبويبات
        if hasattr(self, 'progress_buttons'):
            for i, btn in enumerate(self.progress_buttons):
                if i < len(self.tab_names):
                    translated_name = self._translate_tab_name(self.tab_names[i])
                    btn.configure(text=f"{i+1}. {translated_name}")

        # تحديث أزرار التنقل
        if hasattr(self, 'prev_btn'):
            self.prev_btn.configure(text=f"◀ {self.texts['previous']}")
        if hasattr(self, 'next_btn'):
            self.next_btn.configure(text=f"{self.texts['next']} ▶")
        if hasattr(self, 'save_btn'):
            self.save_btn.configure(text=f"💾 {self.texts['save']}")
        if hasattr(self, 'cancel_btn'):
            self.cancel_btn.configure(text=f"❌ {self.texts['cancel']}")
        if hasattr(self, 'draft_btn'):
            self.draft_btn.configure(text=f"📝 {self.texts['draft']}")
        if hasattr(self, 'refresh_btn'):
            self.refresh_btn.configure(text=f"🔄 {self.texts['refresh']}")

    def _get_initial_value(self, field_name):
        """الحصول على القيمة الأولية"""
        value = self.initial_fields.get(field_name)
        return self._process_complex_value(value) if value else ""

    def destroy(self):
        """تنظيف الموارد قبل الإغلاق"""
        self._is_closing = True
        try:
            # تنظيف القواميس
            for attr in ['field_vars', 'field_widgets', 'combo_boxes', 'enhanced_combos', 'dropdown_options']:
                if hasattr(self, attr):
                    getattr(self, attr).clear()
        except Exception as e:
            logger.error(f"خطأ في التنظيف: {e}")
        finally:
            super().destroy()

============================================================
FILE: views\login_window.py
SIZE: 91114 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/login_window.py

نافذة تسجيل دخول احترافية محسنة مع ارتفاع منطقة العمل (من أعلى الشاشة حتى شريط المهام)
Enhanced Professional Login Window with Workarea Height Layout
"""

import customtkinter as ctk
from tkinter import messagebox
import json
import os
import re
import time
import hashlib
import secrets
import platform
from typing import Any, Callable, Optional, Dict, Tuple
from datetime import datetime, timedelta
import threading
from functools import wraps
import queue

# Core imports
from core.language_manager import LanguageManager
from core.theme_manager import ThemeManager
from core.logger import logger

# النظام الموحد للثيمات والألوان
from core.theme_color_manager import ThemeColorManager, ThemedWindow

# استيراد لوحات الألوان
try:
    from config.modern_color_palettes import get_color_palette, get_available_palettes
    COLOR_PALETTES_AVAILABLE = True
except ImportError:
    COLOR_PALETTES_AVAILABLE = False
    logger.warning("Color palettes module not found. Using default colors.")

# Security imports
try:
    from core.security.encryption import EncryptionManager
    from core.security.rate_limiter import RateLimiter
    from utils.validators import InputValidator
    from config.login_config import LOGIN_CONFIG
    from core.constants import LoginConstants
    try:
        from core.constants import WindowConstants
        if not hasattr(WindowConstants, 'SCREEN_HEIGHT_RATIO'):
            raise AttributeError("Missing SCREEN_HEIGHT_RATIO")
    except (ImportError, AttributeError):
        WindowConstants = None
except ImportError:
    EncryptionManager = None
    RateLimiter = None
    InputValidator = None
    LOGIN_CONFIG = {}
    WindowConstants = None

    class LoginConstants:
        MIN_PASSWORD_LENGTH = 8
        MAX_LOGIN_ATTEMPTS = 5
        LOGIN_TIMEOUT = 30
        SESSION_TIMEOUT = 1800
        PASSWORD_SPECIAL_CHARS = "!@#$%^&*()_+-=[]{}|;:,.<>?"
        LOCKOUT_DURATION = 300

# Window Constants - Updated for workarea height layout
class LocalWindowConstants:
    MIN_WINDOW_WIDTH = 380
    MIN_WINDOW_HEIGHT = 500
    MAX_WINDOW_WIDTH = 450
    DEFAULT_WINDOW_WIDTH = 400
    SCREEN_HEIGHT_RATIO = 0.85
    ANIMATION_DURATION = 300
    FLASH_INTERVAL = 300
    WORKAREA_HEIGHT_ENABLED = True  # تفعيل ارتفاع منطقة العمل
    FULL_HEIGHT_ENABLED = False     # إلغاء الارتفاع الكامل

if WindowConstants is None:
    WindowConstants = LocalWindowConstants
else:
    for attr in ['SCREEN_HEIGHT_RATIO', 'DEFAULT_WINDOW_WIDTH', 'MAX_WINDOW_WIDTH', 'MIN_WINDOW_HEIGHT', 'WORKAREA_HEIGHT_ENABLED']:
        if not hasattr(WindowConstants, attr):
            setattr(WindowConstants, attr, getattr(LocalWindowConstants, attr))

# Window Manager import with workarea height support
try:
    from utils.window_manager import WindowManager, setup_dialog_window, setup_login_window, setup_add_edit_window, setup_dialog_window_workarea
    WINDOW_MANAGER_AVAILABLE = True
except ImportError:
    WINDOW_MANAGER_AVAILABLE = False
    WindowManager = None
    setup_dialog_window = None
    setup_login_window = None
    setup_add_edit_window = None
    setup_dialog_window_workarea = None


def login_error_handler(func):
    """Decorator لمعالجة أخطاء تسجيل الدخول"""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}", exc_info=True)
            if hasattr(self, '_show_status'):
                self._show_status(f"Error: {str(e)}", "error")
    return wrapper


class LoginWindow(ctk.CTk):
    """
    نافذة تسجيل دخول احترافية محسنة بارتفاع منطقة العمل
    """

    # قيم ثابتة للنافذة - محدثة لارتفاع منطقة العمل
    WINDOW_MIN_WIDTH = 380
    WINDOW_MIN_HEIGHT = 500
    WINDOW_MAX_WIDTH = 450
    WINDOW_DEFAULT_WIDTH = 400
    WINDOW_SCREEN_RATIO = 0.85
    WINDOW_ANIMATION_DURATION = 300
    WINDOW_FLASH_INTERVAL = 300
    WORKAREA_HEIGHT_MODE = True   # تفعيل وضع ارتفاع منطقة العمل
    COMPACT_MODE = False          # إلغاء التصميم المضغوط

    def __init__(
        self,
        controller: Any = None,
        lang_manager: LanguageManager = None,
        theme_manager: ThemeManager = None,
        airtable_model: Any = None,
        user_mgr: Any = None,
        on_login_success: Callable[[Dict[str, Any]], None] = None,
        validate_credentials: Callable[[str, str], Optional[Dict[str, Any]]] = None,
        parent_window: Any = None,
        enable_2fa: bool = False,
        enable_encryption: bool = True,
        enable_rate_limiting: bool = True,
        workarea_height: bool = True  # جديد: للتحكم في ارتفاع منطقة العمل
    ):
        super().__init__()

        # التحقق من صحة parent_window
        self.parent_window = None
        if parent_window:
            if hasattr(parent_window, 'winfo_exists') and hasattr(parent_window, 'tk'):
                try:
                    parent_window.winfo_exists()
                    self.parent_window = parent_window
                except:
                    logger.debug("Parent window is not a valid Tkinter window")

        # إعداد وضع ارتفاع منطقة العمل
        self.workarea_height = workarea_height and self.WORKAREA_HEIGHT_MODE

        # Security features flags
        self.enable_2fa = enable_2fa
        self.enable_encryption = enable_encryption and EncryptionManager is not None
        self.enable_rate_limiting = enable_rate_limiting and RateLimiter is not None

        # Initialize security managers
        self.encryption_manager = EncryptionManager() if self.enable_encryption else None
        self.rate_limiter = RateLimiter() if self.enable_rate_limiting else None

        # معالجة المعاملات
        self.controller = controller
        self.airtable_model = airtable_model
        self.user_mgr = user_mgr

        # إعداد المتغيرات الأساسية
        if controller:
            self.lang_manager = lang_manager or (controller.lang_manager if hasattr(controller, 'lang_manager') else None)
            self.theme_manager = theme_manager or (controller.theme_manager if hasattr(controller, 'theme_manager') else None)
            self.on_login_success = on_login_success or (lambda user_info: controller.on_login_success(user_info))

            if user_mgr and hasattr(user_mgr, 'authenticate'):
                self.validate_credentials = user_mgr.authenticate
            else:
                self.validate_credentials = validate_credentials
        else:
            self.lang_manager = lang_manager
            self.theme_manager = theme_manager
            self.on_login_success = on_login_success
            self.validate_credentials = validate_credentials

        # التحقق من وجود المتطلبات الأساسية
        if not self.lang_manager:
            raise ValueError("LanguageManager is required")
        if not self.theme_manager:
            raise ValueError("ThemeManager is required")

        # النظام الموحد للثيمات والألوان
        self.themed_window = ThemedWindow(self, self.theme_manager)

        # متغيرات داخلية
        self.remember_me = ctk.BooleanVar(value=False)
        self._closing = False
        self._login_attempts = 0
        self._show_password = False
        self._caps_lock_on = False
        self._session_token = None
        self._csrf_token = self._generate_csrf_token()

        try:
            # إعداد النافذة
            self._setup_window()

            # بناء الواجهة بارتفاع منطقة العمل
            self._build_workarea_ui()

            # تحميل بيانات الدخول المحفوظة
            self._load_saved_credentials()

            # Setup window with workarea height layout
            self._setup_window_with_manager()

            # Bind keyboard events
            self.after(50, self._bind_keyboard_events)

            # التركيز على الحقل المناسب
            def set_initial_focus():
                if self._closing or not self.winfo_exists():
                    return
                try:
                    if hasattr(self, 'entry_username') and self.entry_username.winfo_exists():
                        if self.entry_username.get():
                            if hasattr(self, 'entry_password') and self.entry_password.winfo_exists():
                                self.entry_password.focus_set()
                        else:
                            self.entry_username.focus_set()
                except Exception as e:
                    logger.debug(f"Error setting initial focus: {e}")

            if self.winfo_exists():
                self.after(100, set_initial_focus)

            # Start session timeout timer
            self._start_session_timer()

        except Exception as e:
            logger.error(f"Error during initialization: {e}")
            self._on_close()

    def _get_color(self, color_name: str, fallback: str = None) -> str:
        """دالة موحدة للحصول على الألوان"""
        return self.themed_window.get_color(color_name, fallback)

    def _apply_theme(self):
        """تطبيق الثيم الموحد"""
        self.themed_window.apply_theme()

    def _calculate_optimal_window_size(self):
        """حساب الحجم الأمثل للنافذة بارتفاع محدود"""
        try:
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()

            # تحديد العرض
            if screen_width < 500:
                window_width = int(screen_width * 0.85)
            elif screen_width < 800:
                window_width = min(400, int(screen_width * 0.5))
            else:
                window_width = 400

            # تحديد ارتفاع محدود ومناسب (بدلاً من ارتفاع منطقة العمل الكامل)
            if screen_height <= 768:
                window_height = 600  # ارتفاع صغير للشاشات الصغيرة
            elif screen_height <= 1080:
                window_height = 700  # ارتفاع متوسط للشاشات العادية
            else:
                window_height = 750  # ارتفاع أكبر قليلاً للشاشات الكبيرة

            # التأكد من عدم تجاوز الحد الأدنى والأقصى
            window_height = max(window_height, self.WINDOW_MIN_HEIGHT)
            window_height = min(window_height, int(screen_height * 0.8))  # لا يتجاوز 80% من الشاشة

            logger.debug(f"Limited window size: {window_width}x{window_height} for screen {screen_width}x{screen_height}")

            return window_width, window_height

        except Exception as e:
            logger.error(f"Error calculating window size: {e}")
            return 400, 650  # قيم افتراضية محدودة

    def _get_available_color_palettes(self):
        """الحصول على قائمة اللوحات المتاحة للوضع الفاتح"""
        if COLOR_PALETTES_AVAILABLE:
            all_palettes = get_available_palettes()
            return [p for p in all_palettes if p != 'modern_dark']
        return []

    def _save_color_palette_preference(self, palette_name):
        """حفظ تفضيل لوحة الألوان"""
        if hasattr(self, 'controller') and hasattr(self.controller, 'config_manager'):
            self.controller.config_manager.set('light_color_palette', palette_name)
            self.controller.config_manager.save()
            logger.info(f"Saved color palette preference: {palette_name}")

    def _setup_window_with_manager(self):
        """إعداد النافذة باستخدام WindowManager بارتفاع محدود"""
        window_width, window_height = self._calculate_optimal_window_size()

        if WINDOW_MANAGER_AVAILABLE:
            try:
                # استخدام ارتفاع محدود بدلاً من ارتفاع منطقة العمل الكامل
                if setup_dialog_window:
                    setup_dialog_window(
                        self,
                        size=(window_width, window_height),  # استخدام الارتفاع المحسوب
                        parent=self.parent_window,
                        focus=True,
                        topmost_duration=500
                    )
                    logger.debug("Login window setup with limited height using setup_dialog_window")

                else:
                    # الطريقة المباشرة مع ارتفاع محدود
                    WindowManager.setup_centered_window(
                        self,
                        size=(window_width, window_height),
                        parent=self.parent_window,
                        focus=True,
                        topmost_duration=500,
                        modal=True
                    )
                    logger.debug("Login window setup with limited height using direct method")

                # تحريك النافذة إذا كان متاحاً
                if hasattr(WindowManager, 'animate_window_open'):
                    WindowManager.animate_window_open(self, duration=self.WINDOW_ANIMATION_DURATION)

                # إعداد اختصارات النافذة
                if hasattr(WindowManager, 'setup_window_shortcuts'):
                    WindowManager.setup_window_shortcuts(self)

            except Exception as e:
                logger.error(f"Error setting up window with WindowManager: {e}")
                self._fallback_window_setup()
        else:
            self._fallback_window_setup()

    def _fallback_window_setup(self):
        """إعداد احتياطي للنافذة بارتفاع محدود"""
        try:
            window_width, window_height = self._calculate_optimal_window_size()

            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()

            # التوسيط العادي (وسط الشاشة)
            x = (screen_width - window_width) // 2
            y = (screen_height - window_height) // 2

            # التأكد من أن النافذة داخل حدود الشاشة
            x = max(10, min(x, screen_width - window_width - 10))
            y = max(10, min(y, screen_height - window_height - 50))  # ترك مساحة لشريط المهام

            self.geometry(f"{window_width}x{window_height}+{x}+{y}")

            logger.debug(f"Fallback limited window setup: {window_width}x{window_height} at ({x}, {y})")

            self.lift()
            self.focus_force()

            if self.parent_window:
                try:
                    self.transient(self.parent_window)
                    self.grab_set()
                except:
                    pass

        except Exception as e:
            logger.error(f"Error in fallback window setup: {e}")

    def _generate_csrf_token(self) -> str:
        """Generate CSRF token for security"""
        return secrets.token_urlsafe(32)

    def _bind_keyboard_events(self):
        """Bind keyboard events"""
        if self._closing or not self.winfo_exists():
            return

        try:
            self.bind("<KeyPress>", self._check_caps_lock)
            self.bind("<KeyRelease>", self._check_caps_lock)
            self.bind("<Escape>", lambda e: self._on_close())
            self.bind("<F1>", lambda e: self._show_help())
        except Exception as e:
            logger.error(f"Error binding keyboard events: {e}")

    def _check_caps_lock(self, event=None):
        """Check if Caps Lock is on"""
        try:
            if not self.winfo_exists() or self._closing:
                return

            if hasattr(self, 'entry_password') and self.entry_password.focus_get() == self.entry_password:
                if event and event.keysym == 'Caps_Lock':
                    self._caps_lock_on = not self._caps_lock_on
                else:
                    try:
                        import ctypes
                        if platform.system() == "Windows":
                            hllDll = ctypes.WinDLL("User32.dll")
                            VK_CAPITAL = 0x14
                            self._caps_lock_on = bool(hllDll.GetKeyState(VK_CAPITAL) & 1)
                    except:
                        pass

                if self._caps_lock_on and hasattr(self, 'caps_lock_warning'):
                    self.caps_lock_warning.pack(anchor="w", pady=(1, 0))
                elif hasattr(self, 'caps_lock_warning'):
                    self.caps_lock_warning.pack_forget()
        except Exception as e:
            logger.debug(f"Error checking caps lock: {e}")

    def _start_session_timer(self):
        """Start session timeout timer"""
        self._last_activity = time.time()
        self._check_session_timeout()

    def _check_session_timeout(self):
        """Check for session timeout"""
        if self._closing or not self.winfo_exists():
            return

        if time.time() - self._last_activity > LoginConstants.SESSION_TIMEOUT:
            self._show_status(
                self.lang_manager.get("session_timeout", "Session timed out. Please login again."),
                "warning"
            )
            self._on_close()
        else:
            self.after(60000, self._check_session_timeout)

    def _update_activity(self):
        """Update last activity time"""
        self._last_activity = time.time()

    def safe_after(self, ms, func):
        """جدولة دالة بشكل آمن"""
        try:
            if not self._closing and self.winfo_exists():
                return self.after(ms, func)
        except Exception as e:
            if "main thread is not in main loop" in str(e):
                try:
                    return self.after_idle(func)
                except:
                    pass
            logger.error(f"Error in safe_after: {e}")
        return None

    def _setup_window(self):
        """إعداد النافذة بارتفاع منطقة العمل"""
        self.title(self.lang_manager.get("login_window_title", "Login - FTS Sales Manager"))

        self.minsize(self.WINDOW_MIN_WIDTH, self.WINDOW_MIN_HEIGHT)
        self.resizable(False, False)  # منع تغيير الحجم

        self.protocol("WM_DELETE_WINDOW", self._on_close)

        self._apply_theme()

        try:
            if os.path.exists("assets/icon.ico"):
                self.iconbitmap("assets/icon.ico")
            else:
                possible_paths = [
                    "assets/icon.ico",
                    "../assets/icon.ico",
                    "../../assets/icon.ico",
                    os.path.join(os.path.dirname(__file__), "../assets/icon.ico")
                ]
                for path in possible_paths:
                    if os.path.exists(path):
                        self.iconbitmap(path)
                        break
        except Exception as e:
            logger.debug(f"Could not set window icon: {e}")

    def _build_workarea_ui(self):
        """بناء واجهة المستخدم بتخطيط مضغوط ومحسن"""

        # تعيين لون الخلفية الرئيسي
        self.configure(fg_color=self._get_color('background'))

        # الحاوية الرئيسية مع هوامش معقولة
        main_padding = 10
        main_container = ctk.CTkFrame(self, fg_color=self._get_color('background'))
        main_container.pack(fill="both", expand=True, padx=main_padding, pady=main_padding)

        # البطاقة الرئيسية
        card_frame = ctk.CTkFrame(
            main_container,
            fg_color=self._get_color('surface'),
            corner_radius=16,
            border_width=0
        )
        card_frame.pack(fill="both", expand=True)

        # إطار المحتوى العادي (بدون scrollable frame للتوفير في المساحة)
        content_padding = 15
        self.content_frame = ctk.CTkFrame(card_frame, fg_color="transparent")
        self.content_frame.pack(fill="both", expand=True, padx=content_padding, pady=content_padding)

        # بناء الأقسام مع تباعد مضغوط
        self._create_compact_header(self.content_frame)
        self._create_compact_login_form(self.content_frame)
        self._create_compact_buttons(self.content_frame)
        self._create_compact_status_area(self.content_frame)
        self._create_compact_footer(self.content_frame)

    def _ensure_content_visibility(self):
        """ضمان إظهار جميع المحتويات في الإطار القابل للتمرير"""
        try:
            if hasattr(self, 'scrollable_frame') and self.scrollable_frame.winfo_exists():
                self.scrollable_frame.update_idletasks()
                self.scrollable_frame._parent_canvas.yview_moveto(0)
                self.update()
        except Exception as e:
            logger.debug(f"Error ensuring content visibility: {e}")

    def _create_compact_header(self, parent):
        """إنشاء رأس مضغوط"""
        header_frame = ctk.CTkFrame(parent, fg_color="transparent")
        header_frame.pack(fill="x", pady=(5, 15))

        # حاوية الشعار المضغوطة
        logo_container = ctk.CTkFrame(header_frame, fg_color="transparent")
        logo_container.pack()

        # شعار مضغوط
        logo_size = 50
        logo_bg = ctk.CTkFrame(
            logo_container,
            width=logo_size,
            height=logo_size,
            corner_radius=logo_size//2,
            fg_color=self._get_color('primary')
        )
        logo_bg.pack()
        logo_bg.pack_propagate(False)

        # حلقة خارجية مضغوطة
        logo_ring = ctk.CTkFrame(
            logo_container,
            width=logo_size + 8,
            height=logo_size + 8,
            corner_radius=(logo_size + 8)//2,
            fg_color=self._get_color('surface'),
            border_width=2,
            border_color=self._get_color('primary')
        )
        logo_ring.place(relx=0.5, rely=0.5, anchor="center")
        logo_bg.lift()

        # نص الشعار المضغوط
        logo_text = ctk.CTkLabel(
            logo_bg,
            text="FTS",
            font=ctk.CTkFont(family="Helvetica", size=18, weight="bold"),
            text_color="white"
        )
        logo_text.place(relx=0.5, rely=0.5, anchor="center")

        # العنوان الرئيسي المضغوط
        self.title_label = ctk.CTkLabel(
            header_frame,
            text="FTS Sales Manager",
            font=ctk.CTkFont(family="Helvetica", size=20, weight="bold"),
            text_color=self._get_color('text_primary')
        )
        self.title_label.pack(pady=(10, 3))

        # العنوان الفرعي المضغوط
        self.subtitle_label = ctk.CTkLabel(
            header_frame,
            text=self.lang_manager.get("login_subtitle", "Secure access to your sales dashboard"),
            font=ctk.CTkFont(family="Helvetica", size=12),
            text_color=self._get_color('text_secondary'),
            wraplength=320
        )
        self.subtitle_label.pack(pady=(0, 8))

        # خط فاصل رفيع
        separator = ctk.CTkFrame(header_frame, height=1, fg_color=self._get_color('input_border'))
        separator.pack(fill="x", pady=(10, 0))

    def _create_compact_login_form(self, parent):
        """إنشاء نموذج تسجيل دخول مضغوط"""
        form_frame = ctk.CTkFrame(parent, fg_color="transparent")
        form_frame.pack(fill="x", pady=(12, 10))

        # حقل اسم المستخدم
        self._create_compact_input_field(
            form_frame,
            label_text=self.lang_manager.get("username", "Username"),
            placeholder=self.lang_manager.get("enter_username", "Enter your username"),
            icon="👤",
            field_name="username"
        )

        # حقل كلمة المرور
        self._create_compact_password_field(form_frame)

        # الخيارات
        self._create_compact_options(form_frame)

        # 2FA field if enabled
        if self.enable_2fa:
            self._create_compact_2fa_field(form_frame)

    def _create_compact_input_field(self, parent, label_text, placeholder, icon, field_name):
        """إنشاء حقل إدخال مضغوط"""
        # أحجام مضغوطة
        label_font_size = 13
        field_height = 36
        padding_bottom = 5
        field_padding = 8

        # تسمية الحقل
        label = ctk.CTkLabel(
            parent,
            text=label_text,
            font=ctk.CTkFont(family="Helvetica", size=label_font_size, weight="bold"),
            text_color=self._get_color('text_primary'),
            anchor="w"
        )
        label.pack(fill="x", pady=(0, padding_bottom))

        # إطار الحقل
        field_container = ctk.CTkFrame(
            parent,
            fg_color=self._get_color('input_bg'),
            corner_radius=10,
            border_width=1,
            border_color=self._get_color('input_border')
        )
        field_container.pack(fill="x", pady=(0, field_padding))

        # الإطار الداخلي
        field_frame = ctk.CTkFrame(field_container, fg_color="transparent")
        field_frame.pack(fill="x", padx=10, pady=6)

        # الأيقونة
        icon_label = ctk.CTkLabel(
            field_frame,
            text=icon,
            font=ctk.CTkFont(size=15),
            text_color=self._get_color('text_secondary'),
            width=28
        )
        icon_label.pack(side="left", padx=(0, 6))

        # حقل الإدخال
        if field_name == "username":
            self.entry_username = ctk.CTkEntry(
                field_frame,
                placeholder_text=placeholder,
                height=field_height,
                font=ctk.CTkFont(family="Helvetica", size=13),
                fg_color=self._get_color('surface'),
                border_width=0,
                text_color=self._get_color('text_primary'),
                placeholder_text_color=self._get_color('text_secondary')
            )
            self.entry_username.pack(side="left", fill="x", expand=True)

            # تطبيق الثيم تلقائياً
            self.themed_window.apply_to_widget(self.entry_username, 'entry')

            # ربط الأحداث
            self.entry_username.bind("<Return>", lambda e: self.entry_password.focus_set())
            self.entry_username.bind("<FocusIn>", lambda e: self._on_field_focus(field_container, True))
            self.entry_username.bind("<FocusOut>", lambda e: self._on_field_focus(field_container, False))
            self.entry_username.bind("<KeyRelease>", lambda e: self._validate_username())
            self.entry_username.bind("<Button-1>", lambda e: self._update_activity())

            # تسمية الخطأ
            self.username_error = ctk.CTkLabel(
                parent,
                text="",
                font=ctk.CTkFont(size=10),
                text_color=self._get_color('danger'),
                anchor="w"
            )

    def _create_workarea_password_field(self, parent):
        """إنشاء حقل كلمة مرور محسن للارتفاع الكامل"""
        # أحجام محسنة
        label_font_size = 14
        field_height = 40
        button_size = 36
        padding_bottom = 8
        field_padding = 12

        # تسمية الحقل
        self.password_label = ctk.CTkLabel(
            parent,
            text=self.lang_manager.get("password", "Password"),
            font=ctk.CTkFont(family="Helvetica", size=label_font_size, weight="bold"),
            text_color=self._get_color('text_primary'),
            anchor="w"
        )
        self.password_label.pack(fill="x", pady=(0, padding_bottom))

        # إطار الحقل
        field_container = ctk.CTkFrame(
            parent,
            fg_color=self._get_color('input_bg'),
            corner_radius=12,
            border_width=2,
            border_color=self._get_color('input_border')
        )
        field_container.pack(fill="x", pady=(0, field_padding))

        field_frame = ctk.CTkFrame(field_container, fg_color="transparent")
        field_frame.pack(fill="x", padx=12, pady=8)

        # الأيقونة
        lock_icon = ctk.CTkLabel(
            field_frame,
            text="🔒",
            font=ctk.CTkFont(size=16),
            text_color=self._get_color('text_secondary'),
            width=30
        )
        lock_icon.pack(side="left", padx=(0, 8))

        # حقل كلمة المرور
        self.entry_password = ctk.CTkEntry(
            field_frame,
            placeholder_text=self.lang_manager.get("enter_password", "Enter your password"),
            show="•",
            height=field_height,
            font=ctk.CTkFont(family="Helvetica", size=14),
            fg_color=self._get_color('surface'),
            border_width=0,
            text_color=self._get_color('text_primary'),
            placeholder_text_color=self._get_color('text_secondary')
        )
        self.entry_password.pack(side="left", fill="x", expand=True)

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.entry_password, 'entry')

        # أزرار التحكم
        controls_frame = ctk.CTkFrame(field_frame, fg_color="transparent")
        controls_frame.pack(side="left", padx=(8, 0))

        # زر إظهار/إخفاء
        self.toggle_pass_btn = ctk.CTkButton(
            controls_frame,
            text="👁",
            width=button_size,
            height=button_size,
            fg_color=self._get_color('input_bg'),
            hover_color=self._get_color('border'),
            text_color=self._get_color('text_secondary'),
            command=self._toggle_password_visibility,
            corner_radius=8,
            border_width=1,
            border_color=self._get_color('input_border'),
            font=ctk.CTkFont(size=14)
        )
        self.toggle_pass_btn.pack(side="left", padx=(0, 4))

        # زر توليد كلمة مرور
        self.gen_pass_btn = ctk.CTkButton(
            controls_frame,
            text="🔑",
            width=button_size,
            height=button_size,
            fg_color=self._get_color('input_bg'),
            hover_color=self._get_color('border'),
            text_color=self._get_color('text_secondary'),
            command=self._generate_strong_password,
            corner_radius=8,
            border_width=1,
            border_color=self._get_color('input_border'),
            font=ctk.CTkFont(size=14)
        )
        self.gen_pass_btn.pack(side="left")

        # ربط الأحداث
        self.entry_password.bind("<Return>", lambda e: self._login())
        self.entry_password.bind("<FocusIn>", lambda e: self._on_field_focus(field_container, True))
        self.entry_password.bind("<FocusOut>", lambda e: self._on_field_focus(field_container, False))
        self.entry_password.bind("<KeyRelease>", self._update_password_strength)
        self.entry_password.bind("<Button-1>", lambda e: self._update_activity())

        # تحذير Caps Lock
        self.caps_lock_warning = ctk.CTkLabel(
            parent,
            text="⚠️ " + self.lang_manager.get("caps_lock_on", "Caps Lock is ON"),
            font=ctk.CTkFont(size=11),
            text_color="#F59E0B"
        )

        # مؤشر قوة كلمة المرور
        self._create_workarea_password_strength(parent)

    def _create_workarea_password_strength(self, parent):
        """إنشاء مؤشر قوة كلمة مرور محسن للارتفاع الكامل"""
        container_height = 45
        bar_height = 8
        padding_y = (8, 0)

        self.strength_container = ctk.CTkFrame(parent, fg_color="transparent", height=container_height)
        self.strength_container.pack(fill="x", pady=padding_y)

        # شريط التقدم
        strength_bg = ctk.CTkFrame(
            self.strength_container,
            height=bar_height,
            corner_radius=bar_height//2,
            fg_color=self._get_color('input_border')
        )
        strength_bg.pack(fill="x", pady=(0, 5))

        self.strength_bar = ctk.CTkProgressBar(
            strength_bg,
            height=bar_height,
            corner_radius=bar_height//2,
            progress_color=self._get_color('secondary'),
            fg_color=self._get_color('input_border')
        )
        self.strength_bar.pack(fill="both", expand=True)
        self.strength_bar.set(0)

        # تسمية القوة والمتطلبات
        info_frame = ctk.CTkFrame(self.strength_container, fg_color="transparent")
        info_frame.pack(fill="x")

        self.strength_label = ctk.CTkLabel(
            info_frame,
            text="",
            font=ctk.CTkFont(family="Helvetica", size=12, weight="bold")
        )
        self.strength_label.pack(side="left")

        self.requirements_text = ctk.CTkLabel(
            info_frame,
            text="",
            font=ctk.CTkFont(size=11),
            text_color=self._get_color('text_secondary')
        )
        self.requirements_text.pack(side="right")

    def _create_workarea_2fa_field(self, parent):
        """Create 2FA field for workarea layout"""
        self.twofa_frame = ctk.CTkFrame(parent, fg_color="transparent")

        # أحجام محسنة للارتفاع الكامل
        label_font_size = 14
        field_height = 40
        icon_font_size = 16
        entry_font_size = 14
        padding_bottom = 8

        # 2FA label
        self.twofa_label = ctk.CTkLabel(
            self.twofa_frame,
            text=self.lang_manager.get("2fa_code", "2FA Code"),
            font=ctk.CTkFont(family="Helvetica", size=label_font_size, weight="bold"),
            text_color=self._get_color('text_primary'),
            anchor="w"
        )
        self.twofa_label.pack(fill="x", pady=(0, padding_bottom))

        # 2FA entry container
        field_container = ctk.CTkFrame(
            self.twofa_frame,
            fg_color=self._get_color('input_bg'),
            corner_radius=12,
            border_width=2,
            border_color=self._get_color('input_border')
        )
        field_container.pack(fill="x")

        field_frame = ctk.CTkFrame(field_container, fg_color="transparent")
        field_frame.pack(fill="x", padx=12, pady=8)

        # 2FA icon
        icon_label = ctk.CTkLabel(
            field_frame,
            text="🔐",
            font=ctk.CTkFont(size=icon_font_size),
            text_color=self._get_color('text_secondary'),
            width=30
        )
        icon_label.pack(side="left", padx=(0, 8))

        # 2FA entry
        self.entry_2fa = ctk.CTkEntry(
            field_frame,
            placeholder_text=self.lang_manager.get("enter_2fa_code", "Enter 6-digit code"),
            height=field_height,
            font=ctk.CTkFont(family="Helvetica", size=entry_font_size),
            fg_color=self._get_color('surface'),
            border_width=0,
            text_color=self._get_color('text_primary'),
            placeholder_text_color=self._get_color('text_secondary')
        )
        self.entry_2fa.pack(side="left", fill="x", expand=True)

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.entry_2fa, 'entry')

        # Initially hidden
        self.twofa_frame.pack_forget()

    def _create_workarea_options(self, parent):
        """إنشاء خيارات محسنة للارتفاع الكامل"""
        options_frame = ctk.CTkFrame(parent, fg_color="transparent")
        options_frame.pack(fill="x", pady=(10, 0))

        # خيار تذكرني
        self.remember_check = ctk.CTkCheckBox(
            options_frame,
            text=self.lang_manager.get("remember_me", "Remember me"),
            variable=self.remember_me,
            font=ctk.CTkFont(family="Helvetica", size=13),
            text_color=self._get_color('text_primary'),
            fg_color=self._get_color('primary'),
            hover_color=self._get_color('primary_hover'),
            border_color=self._get_color('input_border'),
            border_width=2,
            corner_radius=6,
            command=self._update_activity
        )
        self.remember_check.pack(side="left")

        # رابط نسيت كلمة المرور
        self.forgot_btn = ctk.CTkButton(
            options_frame,
            text=self.lang_manager.get("forgot_password", "Forgot password?"),
            font=ctk.CTkFont(family="Helvetica", size=12, weight="normal"),
            fg_color="transparent",
            hover_color=self._get_color('input_bg'),
            text_color=self._get_color('primary'),
            command=self._show_forgot_password
        )
        self.forgot_btn.pack(side="right")

    def _create_workarea_buttons(self, parent):
        """إنشاء أزرار محسنة للارتفاع الكامل"""
        button_frame = ctk.CTkFrame(parent, fg_color="transparent")
        button_frame.pack(fill="x", pady=(20, 15))

        # أحجام محسنة
        button_height = 45
        button_font_size = 15
        button_spacing = 10

        # زر تسجيل الدخول الأساسي
        self.btn_login = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("login", "Sign In"),
            command=self._login,
            height=button_height,
            font=ctk.CTkFont(family="Helvetica", size=button_font_size, weight="bold"),
            corner_radius=12,
            fg_color=self._get_color('primary'),
            hover_color=self._get_color('primary_hover'),
            text_color="white"
        )
        self.btn_login.pack(fill="x", pady=(0, button_spacing))

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.btn_login, 'button')

        # زر الإلغاء الثانوي
        self.btn_cancel = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self._on_close,
            height=button_height,
            font=ctk.CTkFont(family="Helvetica", size=button_font_size, weight="bold"),
            corner_radius=12,
            fg_color=self._get_color('input_bg'),
            hover_color=("#FFE4E6", "#4B5563"),
            text_color=self._get_color('danger'),
            border_width=2,
            border_color=self._get_color('danger')
        )
        self.btn_cancel.pack(fill="x")

    def _create_compact_password_field(self, parent):
        """إنشاء حقل كلمة مرور مضغوط"""
        # أحجام مضغوطة
        label_font_size = 13
        field_height = 36
        button_size = 32
        padding_bottom = 5
        field_padding = 8

        # تسمية الحقل
        self.password_label = ctk.CTkLabel(
            parent,
            text=self.lang_manager.get("password", "Password"),
            font=ctk.CTkFont(family="Helvetica", size=label_font_size, weight="bold"),
            text_color=self._get_color('text_primary'),
            anchor="w"
        )
        self.password_label.pack(fill="x", pady=(0, padding_bottom))

        # إطار الحقل
        field_container = ctk.CTkFrame(
            parent,
            fg_color=self._get_color('input_bg'),
            corner_radius=10,
            border_width=1,
            border_color=self._get_color('input_border')
        )
        field_container.pack(fill="x", pady=(0, field_padding))

        field_frame = ctk.CTkFrame(field_container, fg_color="transparent")
        field_frame.pack(fill="x", padx=10, pady=6)

        # الأيقونة
        lock_icon = ctk.CTkLabel(
            field_frame,
            text="🔒",
            font=ctk.CTkFont(size=15),
            text_color=self._get_color('text_secondary'),
            width=28
        )
        lock_icon.pack(side="left", padx=(0, 6))

        # حقل كلمة المرور
        self.entry_password = ctk.CTkEntry(
            field_frame,
            placeholder_text=self.lang_manager.get("enter_password", "Enter your password"),
            show="•",
            height=field_height,
            font=ctk.CTkFont(family="Helvetica", size=13),
            fg_color=self._get_color('surface'),
            border_width=0,
            text_color=self._get_color('text_primary'),
            placeholder_text_color=self._get_color('text_secondary')
        )
        self.entry_password.pack(side="left", fill="x", expand=True)

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.entry_password, 'entry')

        # أزرار التحكم المضغوطة
        controls_frame = ctk.CTkFrame(field_frame, fg_color="transparent")
        controls_frame.pack(side="left", padx=(6, 0))

        # زر إظهار/إخفاء مضغوط
        self.toggle_pass_btn = ctk.CTkButton(
            controls_frame,
            text="👁",
            width=button_size,
            height=button_size,
            fg_color=self._get_color('input_bg'),
            hover_color=self._get_color('border'),
            text_color=self._get_color('text_secondary'),
            command=self._toggle_password_visibility,
            corner_radius=8,
            border_width=1,
            border_color=self._get_color('input_border'),
            font=ctk.CTkFont(size=13)
        )
        self.toggle_pass_btn.pack(side="left", padx=(0, 3))

        # زر توليد كلمة مرور مضغوط
        self.gen_pass_btn = ctk.CTkButton(
            controls_frame,
            text="🔑",
            width=button_size,
            height=button_size,
            fg_color=self._get_color('input_bg'),
            hover_color=self._get_color('border'),
            text_color=self._get_color('text_secondary'),
            command=self._generate_strong_password,
            corner_radius=8,
            border_width=1,
            border_color=self._get_color('input_border'),
            font=ctk.CTkFont(size=13)
        )
        self.gen_pass_btn.pack(side="left")

        # ربط الأحداث
        self.entry_password.bind("<Return>", lambda e: self._login())
        self.entry_password.bind("<FocusIn>", lambda e: self._on_field_focus(field_container, True))
        self.entry_password.bind("<FocusOut>", lambda e: self._on_field_focus(field_container, False))
        self.entry_password.bind("<KeyRelease>", self._update_password_strength)
        self.entry_password.bind("<Button-1>", lambda e: self._update_activity())

        # تحذير Caps Lock مضغوط
        self.caps_lock_warning = ctk.CTkLabel(
            parent,
            text="⚠️ " + self.lang_manager.get("caps_lock_on", "Caps Lock is ON"),
            font=ctk.CTkFont(size=10),
            text_color="#F59E0B"
        )

        # مؤشر قوة كلمة المرور المضغوط
        self._create_compact_password_strength(parent)

    def _create_compact_password_strength(self, parent):
        """إنشاء مؤشر قوة كلمة مرور مضغوط"""
        container_height = 40
        bar_height = 6
        padding_y = (5, 0)

        self.strength_container = ctk.CTkFrame(parent, fg_color="transparent", height=container_height)
        self.strength_container.pack(fill="x", pady=padding_y)

        # شريط التقدم المضغوط
        strength_bg = ctk.CTkFrame(
            self.strength_container,
            height=bar_height,
            corner_radius=bar_height//2,
            fg_color=self._get_color('input_border')
        )
        strength_bg.pack(fill="x", pady=(0, 4))

        self.strength_bar = ctk.CTkProgressBar(
            strength_bg,
            height=bar_height,
            corner_radius=bar_height//2,
            progress_color=self._get_color('secondary'),
            fg_color=self._get_color('input_border')
        )
        self.strength_bar.pack(fill="both", expand=True)
        self.strength_bar.set(0)

        # تسمية القوة والمتطلبات المضغوطة
        info_frame = ctk.CTkFrame(self.strength_container, fg_color="transparent")
        info_frame.pack(fill="x")

        self.strength_label = ctk.CTkLabel(
            info_frame,
            text="",
            font=ctk.CTkFont(family="Helvetica", size=11, weight="bold")
        )
        self.strength_label.pack(side="left")

        self.requirements_text = ctk.CTkLabel(
            info_frame,
            text="",
            font=ctk.CTkFont(size=10),
            text_color=self._get_color('text_secondary')
        )
        self.requirements_text.pack(side="right")

    def _create_compact_2fa_field(self, parent):
        """Create compact 2FA field"""
        self.twofa_frame = ctk.CTkFrame(parent, fg_color="transparent")

        # أحجام مضغوطة
        label_font_size = 13
        field_height = 36
        icon_font_size = 15
        entry_font_size = 13
        padding_bottom = 5

        # 2FA label
        self.twofa_label = ctk.CTkLabel(
            self.twofa_frame,
            text=self.lang_manager.get("2fa_code", "2FA Code"),
            font=ctk.CTkFont(family="Helvetica", size=label_font_size, weight="bold"),
            text_color=self._get_color('text_primary'),
            anchor="w"
        )
        self.twofa_label.pack(fill="x", pady=(0, padding_bottom))

        # 2FA entry container
        field_container = ctk.CTkFrame(
            self.twofa_frame,
            fg_color=self._get_color('input_bg'),
            corner_radius=10,
            border_width=1,
            border_color=self._get_color('input_border')
        )
        field_container.pack(fill="x")

        field_frame = ctk.CTkFrame(field_container, fg_color="transparent")
        field_frame.pack(fill="x", padx=10, pady=6)

        # 2FA icon
        icon_label = ctk.CTkLabel(
            field_frame,
            text="🔐",
            font=ctk.CTkFont(size=icon_font_size),
            text_color=self._get_color('text_secondary'),
            width=28
        )
        icon_label.pack(side="left", padx=(0, 6))

        # 2FA entry
        self.entry_2fa = ctk.CTkEntry(
            field_frame,
            placeholder_text=self.lang_manager.get("enter_2fa_code", "Enter 6-digit code"),
            height=field_height,
            font=ctk.CTkFont(family="Helvetica", size=entry_font_size),
            fg_color=self._get_color('surface'),
            border_width=0,
            text_color=self._get_color('text_primary'),
            placeholder_text_color=self._get_color('text_secondary')
        )
        self.entry_2fa.pack(side="left", fill="x", expand=True)

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.entry_2fa, 'entry')

        # Initially hidden
        self.twofa_frame.pack_forget()

    def _create_compact_options(self, parent):
        """إنشاء خيارات مضغوطة"""
        options_frame = ctk.CTkFrame(parent, fg_color="transparent")
        options_frame.pack(fill="x", pady=(8, 0))

        # خيار تذكرني مضغوط
        self.remember_check = ctk.CTkCheckBox(
            options_frame,
            text=self.lang_manager.get("remember_me", "Remember me"),
            variable=self.remember_me,
            font=ctk.CTkFont(family="Helvetica", size=12),
            text_color=self._get_color('text_primary'),
            fg_color=self._get_color('primary'),
            hover_color=self._get_color('primary_hover'),
            border_color=self._get_color('input_border'),
            border_width=1,
            corner_radius=5,
            command=self._update_activity
        )
        self.remember_check.pack(side="left")

        # رابط نسيت كلمة المرور مضغوط
        self.forgot_btn = ctk.CTkButton(
            options_frame,
            text=self.lang_manager.get("forgot_password", "Forgot password?"),
            font=ctk.CTkFont(family="Helvetica", size=11, weight="normal"),
            fg_color="transparent",
            hover_color=self._get_color('input_bg'),
            text_color=self._get_color('primary'),
            command=self._show_forgot_password
        )
        self.forgot_btn.pack(side="right")

    def _create_compact_buttons(self, parent):
        """إنشاء أزرار مضغوطة"""
        button_frame = ctk.CTkFrame(parent, fg_color="transparent")
        button_frame.pack(fill="x", pady=(15, 12))

        # أحجام مضغوطة
        button_height = 40
        button_font_size = 14
        button_spacing = 8

        # زر تسجيل الدخول الأساسي
        self.btn_login = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("login", "Sign In"),
            command=self._login,
            height=button_height,
            font=ctk.CTkFont(family="Helvetica", size=button_font_size, weight="bold"),
            corner_radius=10,
            fg_color=self._get_color('primary'),
            hover_color=self._get_color('primary_hover'),
            text_color="white"
        )
        self.btn_login.pack(fill="x", pady=(0, button_spacing))

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.btn_login, 'button')

        # زر الإلغاء الثانوي
        self.btn_cancel = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self._on_close,
            height=button_height,
            font=ctk.CTkFont(family="Helvetica", size=button_font_size, weight="bold"),
            corner_radius=10,
            fg_color=self._get_color('input_bg'),
            hover_color=("#FFE4E6", "#4B5563"),
            text_color=self._get_color('danger'),
            border_width=1,
            border_color=self._get_color('danger')
        )
        self.btn_cancel.pack(fill="x")

        # تطبيق الثيم تلقائياً
        self.themed_window.apply_to_widget(self.btn_cancel, 'button')

        # SSO buttons (if configured) - مضغوطة
        if LOGIN_CONFIG.get("sso", {}).get("enabled", False):
            self._create_compact_sso_buttons(button_frame)

    def _create_compact_sso_buttons(self, parent):
        """Create compact SSO login buttons"""
        sso_frame = ctk.CTkFrame(parent, fg_color="transparent")
        sso_frame.pack(fill="x", pady=(10, 0))

        # Divider مضغوط
        divider_frame = ctk.CTkFrame(sso_frame, fg_color="transparent")
        divider_frame.pack(fill="x", pady=(0, 8))

        line_left = ctk.CTkFrame(divider_frame, height=1, fg_color=self._get_color('input_border'))
        line_left.pack(side="left", fill="x", expand=True)

        ctk.CTkLabel(
            divider_frame,
            text=self.lang_manager.get("or_login_with", "Or login with"),
            font=ctk.CTkFont(size=11),
            text_color=self._get_color('text_secondary')
        ).pack(side="left", padx=8)

        line_right = ctk.CTkFrame(divider_frame, height=1, fg_color=self._get_color('input_border'))
        line_right.pack(side="left", fill="x", expand=True)

        # SSO buttons مضغوطة
        sso_providers = LOGIN_CONFIG.get("sso", {}).get("providers", [])
        sso_button_height = 35

        for provider in sso_providers:
            btn = ctk.CTkButton(
                sso_frame,
                text=f"{provider.get('icon', '🔗')} {provider.get('name', 'SSO')}",
                command=lambda p=provider: self._sso_login(p),
                height=sso_button_height,
                fg_color=self._get_color('input_bg'),
                hover_color=self._get_color('input_border'),
                text_color=self._get_color('text_primary'),
                border_width=1,
                border_color=self._get_color('input_border'),
                font=ctk.CTkFont(size=12),
                corner_radius=8
            )
            btn.pack(fill="x", pady=3)

    def _create_compact_status_area(self, parent):
        """إنشاء منطقة حالة مضغوطة"""
        container_height = 45
        status_font_size = 12
        security_font_size = 10
        padding_y = (5, 8)

        self.status_container = ctk.CTkFrame(parent, fg_color="transparent", height=container_height)
        self.status_container.pack(fill="x", pady=padding_y)
        self.status_container.pack_propagate(False)

        # تسمية الحالة المضغوطة
        self.status_label = ctk.CTkLabel(
            self.status_container,
            text="",
            font=ctk.CTkFont(family="Helvetica", size=status_font_size),
            wraplength=340
        )
        self.status_label.pack(expand=True)

        # شريط التقدم المضغوط
        progress_height = 3
        self.progress = ctk.CTkProgressBar(
            parent,
            mode="indeterminate",
            height=progress_height,
            corner_radius=progress_height//2,
            progress_color=self._get_color('primary'),
            fg_color=self._get_color('input_border')
        )

        # Security status مضغوط
        if self.enable_encryption or self.enable_rate_limiting:
            security_frame = ctk.CTkFrame(parent, fg_color="transparent")
            security_frame.pack(fill="x", pady=(3, 0))

            security_items = []
            if self.enable_encryption:
                security_items.append("🔐 Encrypted")
            if self.enable_rate_limiting:
                security_items.append("🛡️ Protected")

            ctk.CTkLabel(
                security_frame,
                text=" • ".join(security_items),
                font=ctk.CTkFont(size=security_font_size),
                text_color=self._get_color('text_secondary')
            ).pack()

    def _create_compact_footer(self, parent):
        """إنشاء تذييل مضغوط"""
        # خط فاصل رفيع
        separator = ctk.CTkFrame(parent, height=1, fg_color=self._get_color('input_border'))
        separator.pack(fill="x", pady=(8, 10))

        footer_frame = ctk.CTkFrame(parent, fg_color="transparent")
        footer_frame.pack(fill="x")

        # أزرار التحكم المضغوطة
        controls_frame = ctk.CTkFrame(footer_frame, fg_color="transparent")
        controls_frame.pack(pady=(0, 8))

        button_configs = [
            ("🌐", "English" if self.lang_manager.current_lang == "ar" else "عربي", self._toggle_language),
            ("🎨", self.lang_manager.get("theme", "Theme"), self._toggle_theme),
            ("💬", self.lang_manager.get("help", "Help"), self._show_help)
        ]

        # إضافة زر لوحة الألوان إذا كانت اللوحات متاحة والوضع فاتح
        if COLOR_PALETTES_AVAILABLE and self.theme_manager.get_current_appearance_mode() == "light":
            button_configs.insert(2, ("🎨", self.lang_manager.get("palette", "Colors"), self._show_palette_menu))

        # أحجام الأزرار المضغوطة
        button_width = 80
        button_height = 28
        button_font_size = 10

        for i, (icon, text, command) in enumerate(button_configs):
            btn = ctk.CTkButton(
                controls_frame,
                text=f"{icon} {text}",
                width=button_width,
                height=button_height,
                command=command,
                font=ctk.CTkFont(family="Helvetica", size=button_font_size),
                corner_radius=6,
                fg_color=self._get_color('input_bg'),
                hover_color=self._get_color('input_border'),
                text_color=self._get_color('text_secondary'),
                border_width=1,
                border_color=self._get_color('input_border')
            )
            btn.pack(side="left", padx=3)

            if i == 0:
                self.btn_language = btn
            elif i == 1:
                self.btn_theme = btn
            elif text == self.lang_manager.get("palette", "Colors"):
                self.btn_palette = btn
            elif text == self.lang_manager.get("help", "Help"):
                self.btn_help = btn

        # معلومات الإصدار المضغوطة
        version_label = ctk.CTkLabel(
            footer_frame,
            text="FTS Sales Manager v2.0 © 2024",
            font=ctk.CTkFont(family="Helvetica", size=9),
            text_color=self._get_color('text_secondary')
        )
        version_label.pack(pady=(4, 0))

    def _create_workarea_sso_buttons(self, parent):
        """Create SSO login buttons for workarea layout"""
        sso_frame = ctk.CTkFrame(parent, fg_color="transparent")
        sso_frame.pack(fill="x", pady=(15, 0))

        # Divider
        divider_frame = ctk.CTkFrame(sso_frame, fg_color="transparent")
        divider_frame.pack(fill="x", pady=(0, 10))

        line_left = ctk.CTkFrame(divider_frame, height=2, fg_color=self._get_color('input_border'))
        line_left.pack(side="left", fill="x", expand=True)

        ctk.CTkLabel(
            divider_frame,
            text=self.lang_manager.get("or_login_with", "Or login with"),
            font=ctk.CTkFont(size=12),
            text_color=self._get_color('text_secondary')
        ).pack(side="left", padx=12)

        line_right = ctk.CTkFrame(divider_frame, height=2, fg_color=self._get_color('input_border'))
        line_right.pack(side="left", fill="x", expand=True)

        # SSO buttons
        sso_providers = LOGIN_CONFIG.get("sso", {}).get("providers", [])
        sso_button_height = 40

        for provider in sso_providers:
            btn = ctk.CTkButton(
                sso_frame,
                text=f"{provider.get('icon', '🔗')} {provider.get('name', 'SSO')}",
                command=lambda p=provider: self._sso_login(p),
                height=sso_button_height,
                fg_color=self._get_color('input_bg'),
                hover_color=self._get_color('input_border'),
                text_color=self._get_color('text_primary'),
                border_width=2,
                border_color=self._get_color('input_border'),
                font=ctk.CTkFont(size=13),
                corner_radius=10
            )
            btn.pack(fill="x", pady=4)

    def _create_workarea_status_area(self, parent):
        """إنشاء منطقة حالة محسنة للارتفاع الكامل"""
        container_height = 50
        status_font_size = 13
        security_font_size = 11
        padding_y = (5, 10)

        self.status_container = ctk.CTkFrame(parent, fg_color="transparent", height=container_height)
        self.status_container.pack(fill="x", pady=padding_y)
        self.status_container.pack_propagate(False)

        # تسمية الحالة
        self.status_label = ctk.CTkLabel(
            self.status_container,
            text="",
            font=ctk.CTkFont(family="Helvetica", size=status_font_size),
            wraplength=350
        )
        self.status_label.pack(expand=True)

        # شريط التقدم
        progress_height = 4
        self.progress = ctk.CTkProgressBar(
            parent,
            mode="indeterminate",
            height=progress_height,
            corner_radius=progress_height//2,
            progress_color=self._get_color('primary'),
            fg_color=self._get_color('input_border')
        )

        # Security status
        if self.enable_encryption or self.enable_rate_limiting:
            security_frame = ctk.CTkFrame(parent, fg_color="transparent")
            security_frame.pack(fill="x", pady=(5, 0))

            security_items = []
            if self.enable_encryption:
                security_items.append("🔐 Encrypted")
            if self.enable_rate_limiting:
                security_items.append("🛡️ Protected")

            ctk.CTkLabel(
                security_frame,
                text=" • ".join(security_items),
                font=ctk.CTkFont(size=security_font_size),
                text_color=self._get_color('text_secondary')
            ).pack()

    def _create_workarea_footer(self, parent):
        """إنشاء تذييل محسن للارتفاع الكامل"""
        # خط فاصل
        separator = ctk.CTkFrame(parent, height=2, fg_color=self._get_color('input_border'))
        separator.pack(fill="x", pady=(15, 12))

        footer_frame = ctk.CTkFrame(parent, fg_color="transparent")
        footer_frame.pack(fill="x")

        # أزرار التحكم
        controls_frame = ctk.CTkFrame(footer_frame, fg_color="transparent")
        controls_frame.pack(pady=(0, 10))

        button_configs = [
            ("🌐", "English" if self.lang_manager.current_lang == "ar" else "عربي", self._toggle_language),
            ("🎨", self.lang_manager.get("theme", "Theme"), self._toggle_theme),
            ("💬", self.lang_manager.get("help", "Help"), self._show_help)
        ]

        # إضافة زر لوحة الألوان إذا كانت اللوحات متاحة والوضع فاتح
        if COLOR_PALETTES_AVAILABLE and self.theme_manager.get_current_appearance_mode() == "light":
            button_configs.insert(2, ("🎨", self.lang_manager.get("palette", "Colors"), self._show_palette_menu))

        # أحجام الأزرار محسنة
        button_width = 90
        button_height = 32
        button_font_size = 11

        for i, (icon, text, command) in enumerate(button_configs):
            btn = ctk.CTkButton(
                controls_frame,
                text=f"{icon} {text}",
                width=button_width,
                height=button_height,
                command=command,
                font=ctk.CTkFont(family="Helvetica", size=button_font_size),
                corner_radius=8,
                fg_color=self._get_color('input_bg'),
                hover_color=self._get_color('input_border'),
                text_color=self._get_color('text_secondary'),
                border_width=1,
                border_color=self._get_color('input_border')
            )
            btn.pack(side="left", padx=4)

            if i == 0:
                self.btn_language = btn
            elif i == 1:
                self.btn_theme = btn
            elif text == self.lang_manager.get("palette", "Colors"):
                self.btn_palette = btn
            elif text == self.lang_manager.get("help", "Help"):
                self.btn_help = btn

        # معلومات الإصدار
        version_label = ctk.CTkLabel(
            footer_frame,
            text="FTS Sales Manager v2.0 © 2024",
            font=ctk.CTkFont(family="Helvetica", size=10),
            text_color=self._get_color('text_secondary')
        )
        version_label.pack(pady=(5, 0))

    def _show_palette_menu(self):
        """عرض قائمة اختيار لوحة الألوان محسنة"""
        if not COLOR_PALETTES_AVAILABLE:
            return

        # حجم النافذة محسن
        palette_window_size = "350x450"
        options_height = 250
        title_font = 18
        desc_font = 12
        radio_font = 13
        button_width = 110
        button_height = 36

        # إنشاء نافذة فرعية لاختيار اللوحة
        palette_window = ctk.CTkToplevel(self)
        palette_window.title(self.lang_manager.get("choose_palette", "Choose Color Palette"))
        palette_window.geometry(palette_window_size)
        palette_window.resizable(False, False)

        # تكوين النافذة
        palette_window.transient(self)
        palette_window.grab_set()

        # العنوان
        title = ctk.CTkLabel(
            palette_window,
            text=self.lang_manager.get("select_palette", "Select Color Palette"),
            font=ctk.CTkFont(size=title_font, weight="bold")
        )
        title.pack(pady=(20, 10))

        # الوصف
        desc = ctk.CTkLabel(
            palette_window,
            text=self.lang_manager.get("palette_desc", "Choose your preferred color scheme for light theme"),
            font=ctk.CTkFont(size=desc_font),
            text_color=self._get_color('text_secondary')
        )
        desc.pack(pady=(0, 15))

        # إطار للخيارات
        options_frame = ctk.CTkScrollableFrame(
            palette_window,
            width=300,
            height=options_height
        )
        options_frame.pack(pady=10, padx=20)

        # قاموس أسماء اللوحات
        palette_names = {
            'modern_purple': ('🟣', self.lang_manager.get("purple_modern", "Modern Purple")),
            'modern_blue': ('🔵', self.lang_manager.get("blue_modern", "Modern Blue")),
            'modern_emerald': ('🟢', self.lang_manager.get("emerald_modern", "Modern Emerald")),
            'modern_pink': ('🩷', self.lang_manager.get("pink_modern", "Modern Pink")),
            'modern_orange': ('🟠', self.lang_manager.get("orange_warm", "Warm Orange")),
            'modern_indigo': ('🟪', self.lang_manager.get("indigo_elegant", "Elegant Indigo")),
            'classic_blue': ('🔷', self.lang_manager.get("blue_classic", "Classic Blue"))
        }

        # الحصول على اللوحة الحالية
        current_palette = 'modern_purple'
        if hasattr(self, 'controller') and hasattr(self.controller, 'config_manager'):
            current_palette = self.controller.config_manager.get('light_color_palette', 'modern_purple')

        # متغير لتتبع الاختيار
        selected_palette = ctk.StringVar(value=current_palette)

        # إنشاء خيارات الراديو
        for palette_key in self._get_available_color_palettes():
            if palette_key in palette_names:
                icon, name = palette_names[palette_key]

                # إطار للخيار
                option_frame = ctk.CTkFrame(options_frame, fg_color="transparent")
                option_frame.pack(fill="x", pady=4)

                # زر الراديو
                radio = ctk.CTkRadioButton(
                    option_frame,
                    text=f"{icon} {name}",
                    variable=selected_palette,
                    value=palette_key,
                    font=ctk.CTkFont(size=radio_font),
                    fg_color=get_color_palette(palette_key)['primary']
                )
                radio.pack(side="left", padx=10)

                # معاينة صغيرة للألوان
                preview_frame = ctk.CTkFrame(option_frame, fg_color="transparent")
                preview_frame.pack(side="right", padx=10)

                colors = get_color_palette(palette_key)
                for color_key in ['primary', 'success', 'danger']:
                    color_box = ctk.CTkFrame(
                        preview_frame,
                        width=18,
                        height=18,
                        corner_radius=4,
                        fg_color=colors[color_key]
                    )
                    color_box.pack(side="left", padx=1)

        # إطار الأزرار
        button_frame = ctk.CTkFrame(palette_window, fg_color="transparent")
        button_frame.pack(pady=20)

        def apply_palette():
            """تطبيق اللوحة المختارة"""
            new_palette = selected_palette.get()
            self._save_color_palette_preference(new_palette)

            self._show_status(
                self.lang_manager.get("palette_saved", "Color palette saved. Please reopen the window."),
                "success"
            )

            palette_window.destroy()
            self.after(1500, self._on_close)

        # أزرار
        apply_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("apply", "Apply"),
            command=apply_palette,
            width=button_width,
            height=button_height,
            fg_color=self._get_color('primary'),
            hover_color=self._get_color('primary_hover')
        )
        apply_btn.pack(side="left", padx=5)

        # زر الإلغاء
        cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=palette_window.destroy,
            width=button_width,
            height=button_height,
            fg_color="transparent",
            hover_color=self._get_color('input_bg'),
            text_color=self._get_color('text_primary'),
            border_width=1,
            border_color=self._get_color('input_border')
        )
        cancel_btn.pack(side="left", padx=5)

        # توسيط النافذة
        palette_window.update_idletasks()
        x = (palette_window.winfo_screenwidth() - palette_window.winfo_width()) // 2
        y = (palette_window.winfo_screenheight() - palette_window.winfo_height()) // 2
        palette_window.geometry(f"+{x}+{y}")

    def _on_field_focus(self, field_container, focused):
        """معالجة تأثيرات التركيز على الحقول"""
        if focused:
            field_container.configure(
                border_color=self._get_color('input_focus'),
                border_width=3,
                fg_color=self._get_color('surface')
            )
        else:
            field_container.configure(
                border_color=self._get_color('input_border'),
                border_width=2,
                fg_color=self._get_color('input_bg')
            )

    def _validate_username(self) -> bool:
        """Validate username input"""
        username = self.entry_username.get().strip()

        if not username:
            return True

        if InputValidator:
            is_valid, error_msg = InputValidator.validate_username(username)
        else:
            is_valid = len(username) >= 3 and re.match(r'^[a-zA-Z0-9_.-]+$', username)
            error_msg = "" if is_valid else self.lang_manager.get("invalid_username", "Invalid username format")

        if not is_valid:
            self.username_error.configure(text=error_msg)
            self.username_error.pack(anchor="w", pady=(2, 0))
            return False
        else:
            self.username_error.pack_forget()
            return True

    def _update_password_strength(self, event=None):
        """تحديث مؤشر قوة كلمة المرور محسن للارتفاع الكامل"""
        password = self.entry_password.get()

        if not password:
            self.strength_bar.set(0)
            self.strength_label.configure(text="")
            self.requirements_text.configure(text="")
            return

        # حساب القوة
        has_length = len(password) >= 8
        has_upper = bool(re.search(r'[A-Z]', password))
        has_lower = bool(re.search(r'[a-z]', password))
        has_digit = bool(re.search(r'\d', password))
        has_special = bool(re.search(r'[!@#$%^&*(),.?":{}|<>]', password))

        score = sum([has_length, has_upper, has_lower, has_digit, has_special])
        progress = score / 5
        self.strength_bar.set(progress)

        # تحديد المستوى واللون
        if score <= 2:
            text = self.lang_manager.get("pwd_weak", "Weak")
            color = self._get_color('danger')
            req_text = "Need more variety"
        elif score <= 3:
            text = self.lang_manager.get("pwd_fair", "Fair")
            color = "#F59E0B"
            req_text = "Add more elements"
        elif score <= 4:
            text = self.lang_manager.get("pwd_good", "Good")
            color = "#10B981"
            req_text = "Almost perfect!"
        else:
            text = self.lang_manager.get("pwd_strong", "Strong")
            color = self._get_color('success')
            req_text = "Perfect ✓"

        # تحديث الواجهة
        self.strength_bar.configure(progress_color=color)
        self.strength_label.configure(text=text, text_color=color)
        self.requirements_text.configure(text=req_text)

    def _toggle_password_visibility(self):
        """Toggle password visibility"""
        self._show_password = not self._show_password
        if self._show_password:
            self.entry_password.configure(show="")
            self.toggle_pass_btn.configure(text="👁‍🗨")
        else:
            self.entry_password.configure(show="•")
            self.toggle_pass_btn.configure(text="👁")
        self._update_activity()

    def _generate_strong_password(self):
        """Generate a strong password"""
        import string

        length = 16
        chars = string.ascii_letters + string.digits + string.punctuation

        password = ''.join(secrets.choice(chars) for _ in range(length))

        while not all([
            any(c.isupper() for c in password),
            any(c.islower() for c in password),
            any(c.isdigit() for c in password),
            any(c in string.punctuation for c in password)
        ]):
            password = ''.join(secrets.choice(chars) for _ in range(length))

        self.entry_password.delete(0, "end")
        self.entry_password.insert(0, password)
        self._show_password = True
        self._toggle_password_visibility()
        self._toggle_password_visibility()

        self._update_password_strength()

        self._show_status(
            self.lang_manager.get("password_generated", "Strong password generated"),
            "success"
        )

    def _toggle_language(self):
        """Toggle language"""
        new_lang = "en" if self.lang_manager.current_lang == "ar" else "ar"
        self.lang_manager.set_language(new_lang)

        self._update_ui_texts()

        lang_text = "English" if new_lang == "ar" else "عربي"
        self.btn_language.configure(text=f"🌐 {lang_text}")

        self._update_activity()

    def _toggle_theme(self):
        """تبديل الثيم مع التحديث الموحد"""
        # تبديل الوضع
        self.theme_manager.toggle_appearance_mode()
        self._apply_theme()

        # تحديث النظام الموحد
        self.themed_window.refresh_theme()

        # إظهار رسالة بالتغيير
        current_mode = self.theme_manager.get_current_appearance_mode()
        if current_mode == "dark":
            self._show_status(
                self.lang_manager.get("theme_dark", "Dark theme activated"),
                "info"
            )
        else:
            self._show_status(
                self.lang_manager.get("theme_light", "Light theme activated"),
                "info"
            )

        # إعادة تحديث ألوان العناصر
        self._refresh_ui_colors()

        # إعادة بناء الواجهة لتطبيق الألوان الجديدة
        messagebox.showinfo(
            self.lang_manager.get("theme_change", "Theme Changed"),
            self.lang_manager.get("theme_change_msg", "Please reopen the window to apply the new theme colors.")
        )

        self._update_activity()

    def _refresh_ui_colors(self):
        """تحديث ألوان جميع العناصر"""
        # تحديث الأزرار
        self.themed_window.apply_to_widget(self.btn_login, 'button')
        self.themed_window.apply_to_widget(self.btn_cancel, 'button')

        # تحديث الحقول
        for widget in [self.entry_username, self.entry_password]:
            self.themed_window.apply_to_widget(widget, 'entry')

        # تحديث 2FA إذا كان موجوداً
        if hasattr(self, 'entry_2fa'):
            self.themed_window.apply_to_widget(self.entry_2fa, 'entry')

    def _show_help(self):
        """Show help dialog"""
        help_text = self.lang_manager.get(
            "login_help",
            "Login Help:\n\n"
            "• Enter your username and password\n"
            "• Click 'Sign In' or press Enter\n"
            "• Use 'Remember me' to save your username\n"
            "• Contact admin if you forgot your password\n\n"
            "Security Tips:\n"
            "• Use strong passwords (8+ chars, mixed case, numbers, symbols)\n"
            "• Don't share your credentials\n"
            "• Log out when done"
        )

        messagebox.showinfo(
            self.lang_manager.get("help", "Help"),
            help_text
        )

    def _show_forgot_password(self):
        """Show forgot password dialog"""
        messagebox.showinfo(
            self.lang_manager.get("forgot_password", "Forgot Password"),
            self.lang_manager.get("forgot_password_msg",
                                 "Please contact your administrator to reset your password.\n\n"
                                 "Or contact Automation Team:\n"
                                 "Email: eladawy522@gmail.com\nPhone: +201068177086")
        )

    @login_error_handler
    def _login(self):
        """Enhanced login handler with security features"""
        self._update_activity()

        username = self.entry_username.get().strip()
        password = self.entry_password.get().strip()

        if not username:
            self._show_status(
                self.lang_manager.get("error_username_required", "Please enter your username"),
                "error"
            )
            self._flash_window()
            self.entry_username.focus_set()
            return

        if not password:
            self._show_status(
                self.lang_manager.get("error_password_required", "Please enter your password"),
                "error"
            )
            self._flash_window()
            self.entry_password.focus_set()
            return

        if not self._validate_username():
            self._flash_window()
            return

        if self.enable_rate_limiting:
            identifier = f"{username}:{self._get_client_identifier()}"
            allowed, message = self.rate_limiter.check_rate_limit(identifier)

            if not allowed:
                self._show_status(message, "error")
                self._flash_window(count=3)
                self._set_form_state(False)
                return

        twofa_code = None
        if self.enable_2fa and hasattr(self, 'entry_2fa'):
            twofa_code = self.entry_2fa.get().strip()

        remember_user = self.remember_me.get()

        self._set_form_state(False)
        self._show_progress()

        result_queue = queue.Queue()

        def login_process():
            try:
                if self.enable_rate_limiting:
                    self.rate_limiter.record_attempt(identifier)

                user_info = None

                if self.validate_credentials:
                    if self.enable_2fa:
                        try:
                            user_info = self.validate_credentials(username, password, twofa_code)
                        except TypeError:
                            user_info = self.validate_credentials(username, password)
                    else:
                        user_info = self.validate_credentials(username, password)

                elif self.user_mgr and hasattr(self.user_mgr, 'authenticate'):
                    user_info = self.user_mgr.authenticate(username, password)
                else:
                    logger.error("No authentication method available")
                    result_queue.put(("error", "Authentication service not available"))
                    return

                if user_info:
                    if self.enable_rate_limiting:
                        self.rate_limiter.clear_attempts(identifier)

                    if remember_user:
                        self._save_credentials(username)
                    else:
                        self._clear_saved_credentials()

                    self._session_token = secrets.token_urlsafe(32)

                    user_info['session_token'] = self._session_token
                    user_info['login_time'] = datetime.now().isoformat()

                    result_queue.put(("success", user_info))
                else:
                    self._login_attempts += 1
                    result_queue.put(("failed", None))

            except Exception as e:
                logger.error(f"Login error: {e}", exc_info=True)
                result_queue.put(("error", str(e)))

        thread = threading.Thread(target=login_process, daemon=True)
        thread.start()

        def check_result():
            try:
                result = result_queue.get_nowait()
                status, data = result

                if status == "success":
                    self._on_login_success(data)
                elif status == "failed":
                    self._on_login_failed()
                elif status == "error":
                    self._on_login_error(data)

            except queue.Empty:
                if not self._closing and self.winfo_exists():
                    self.after(100, check_result)
            except Exception as e:
                logger.error(f"Error checking login result: {e}")
                self._on_login_error(str(e))

        self.after(100, check_result)

    def _on_login_success(self, user_info):
        """Handle successful login"""
        if self._closing or not self.winfo_exists():
            return

        self._hide_progress()

        username = user_info.get('username', 'Unknown')
        logger.info(f"Login successful for user: {username}")

        self._show_status(
            self.lang_manager.get("login_success", "Login successful! Welcome back."),
            "success"
        )

        if WINDOW_MANAGER_AVAILABLE:
            WindowManager.flash_window(self, count=1, interval=200)

        if self.on_login_success:
            self.after(500, lambda: self.on_login_success(user_info))

        self.after(800, self._on_close)

    def _on_login_failed(self):
        """Handle failed login"""
        if self._closing or not self.winfo_exists():
            return

        self._hide_progress()
        self._set_form_state(True)

        self._flash_window(count=2)

        remaining = LoginConstants.MAX_LOGIN_ATTEMPTS - self._login_attempts

        if remaining > 0:
            msg = self.lang_manager.get("invalid_credentials", "Invalid username or password")
            msg += f"\n{remaining} {self.lang_manager.get('attempts_remaining', 'attempts remaining')}"
            self._show_status(msg, "error")

            self.entry_password.delete(0, "end")
            self.entry_password.focus_set()

            if self.enable_2fa and self._login_attempts > 2:
                self.twofa_frame.pack(fill="x", pady=(8, 0))
        else:
            self._show_status(
                self.lang_manager.get("account_locked",
                                    "Too many failed attempts.\nPlease contact administrator."),
                "error"
            )
            self._set_form_state(False)
            self._flash_window(count=5)

    def _on_login_error(self, error_msg):
        """Handle login error"""
        if self._closing or not self.winfo_exists():
            return

        self._hide_progress()
        self._set_form_state(True)

        self._show_status(
            f"{self.lang_manager.get('error', 'Error')}: {error_msg}",
            "error"
        )

        self._flash_window()

    def _get_client_identifier(self) -> str:
        """Get client identifier for rate limiting"""
        return platform.node()

    def _flash_window(self, count: int = 2, interval: int = 300):
        """Flash window for attention"""
        if WINDOW_MANAGER_AVAILABLE:
            try:
                WindowManager.flash_window(self, count=count, interval=self.WINDOW_FLASH_INTERVAL)
            except Exception as e:
                logger.debug(f"Error flashing window: {e}")
                self.bell()
        else:
            self.bell()

    def _show_status(self, message: str, status_type: str = "info"):
        """عرض رسالة الحالة بتصميم محسن مع الألوان الموحدة"""
        colors = {
            "info": self._get_color('primary'),
            "success": self._get_color('success'),
            "error": self._get_color('danger'),
            "warning": "#F59E0B"
        }

        color = colors.get(status_type, colors["info"])

        if hasattr(self, 'status_label') and self.status_label.winfo_exists():
            icons = {
                "info": "ℹ️",
                "success": "✅",
                "error": "❌",
                "warning": "⚠️"
            }
            icon = icons.get(status_type, "")

            display_message = f"{icon} {message}" if icon else message
            self.status_label.configure(text=display_message, text_color=color)

    def _show_progress(self):
        """Show progress bar"""
        if hasattr(self, 'progress') and self.progress.winfo_exists():
            self.status_label.configure(text="")
            self.progress.pack(fill="x", pady=(0, 5))
            self.progress.start()

    def _hide_progress(self):
        """Hide progress bar"""
        try:
            if hasattr(self, 'progress') and self.progress and self.progress.winfo_exists():
                self.progress.stop()
                self.progress.pack_forget()
        except:
            pass

    def _set_form_state(self, enabled: bool):
        """Enable/disable form elements"""
        if self._closing or not self.winfo_exists():
            return

        state = "normal" if enabled else "disabled"

        elements = [
            'entry_username', 'entry_password', 'btn_login', 'btn_cancel',
            'remember_check', 'toggle_pass_btn', 'gen_pass_btn',
            'btn_language', 'btn_theme', 'btn_help', 'forgot_btn',
            'entry_2fa'
        ]

        for element_name in elements:
            if hasattr(self, element_name):
                element = getattr(self, element_name)
                try:
                    if element and element.winfo_exists():
                        element.configure(state=state)
                except:
                    pass

    def _save_credentials(self, username: str):
        """Save login credentials securely"""
        try:
            data = {
                "username": username,
                "remember": True,
                "timestamp": datetime.now().isoformat()
            }

            if self.enable_encryption:
                encrypted_data = self.encryption_manager.encrypt_data(json.dumps(data))
                save_data = {"encrypted": True, "data": encrypted_data}
            else:
                save_data = data

            os.makedirs("data", exist_ok=True)

            with open("data/login_cache.json", "w", encoding="utf-8") as f:
                json.dump(save_data, f, ensure_ascii=False, indent=2)

            logger.debug(f"Saved credentials for user: {username}")

        except Exception as e:
            logger.error(f"Error saving credentials: {e}")

    def _load_saved_credentials(self):
        """Load saved login credentials"""
        try:
            cache_file = "data/login_cache.json"

            if os.path.exists(cache_file):
                with open(cache_file, "r", encoding="utf-8") as f:
                    save_data = json.load(f)

                if save_data.get("encrypted") and self.enable_encryption:
                    decrypted = self.encryption_manager.decrypt_data(save_data["data"])
                    data = json.loads(decrypted)
                else:
                    data = save_data

                if data.get("remember") and data.get("username"):
                    self.entry_username.insert(0, data["username"])
                    self.remember_me.set(True)
                    logger.debug(f"Loaded saved credentials for: {data['username']}")

        except Exception as e:
            logger.error(f"Error loading saved credentials: {e}")

    def _clear_saved_credentials(self):
        """Clear saved login credentials"""
        try:
            cache_file = "data/login_cache.json"

            if os.path.exists(cache_file):
                os.remove(cache_file)
                logger.debug("Cleared saved credentials")

        except Exception as e:
            logger.error(f"Error clearing saved credentials: {e}")

    def _update_ui_texts(self):
        """Update all UI texts"""
        self.title(self.lang_manager.get("login_window_title", "Login - FTS Sales Manager"))

        self.subtitle_label.configure(text=self.lang_manager.get("login_subtitle", "Secure access to your sales dashboard"))

        if hasattr(self, 'username_label'):
            self.username_label.configure(text=self.lang_manager.get("username", "Username"))
        self.password_label.configure(text=self.lang_manager.get("password", "Password"))

        self.entry_username.configure(placeholder_text=self.lang_manager.get("enter_username", "Enter your username"))
        self.entry_password.configure(placeholder_text=self.lang_manager.get("enter_password", "Enter your password"))

        self.remember_check.configure(text=self.lang_manager.get("remember_me", "Remember me"))
        self.forgot_btn.configure(text=self.lang_manager.get("forgot_password", "Forgot password?"))

        self.btn_login.configure(text=self.lang_manager.get("login", "Sign In"))
        self.btn_cancel.configure(text=self.lang_manager.get("cancel", "Cancel"))
        self.btn_theme.configure(text="🎨 " + self.lang_manager.get("theme", "Theme"))
        self.btn_help.configure(text="💬 " + self.lang_manager.get("help", "Help"))

        self.caps_lock_warning.configure(text="⚠️ " + self.lang_manager.get("caps_lock_on", "Caps Lock is ON"))

        if hasattr(self, 'twofa_label'):
            self.twofa_label.configure(text=self.lang_manager.get("2fa_code", "2FA Code"))
            self.entry_2fa.configure(placeholder_text=self.lang_manager.get("enter_2fa_code", "Enter 6-digit code"))

    def _sso_login(self, provider: dict):
        """Handle SSO login"""
        self._show_status(
            f"Logging in with {provider.get('name', 'SSO')}...",
            "info"
        )
        # Implement SSO logic here

    def _on_close(self):
        """Enhanced close handler"""
        if self._closing:
            return

        self._closing = True
        logger.info("Closing login window")

        try:
            for after_id in self.tk.call('after', 'info'):
                try:
                    self.after_cancel(after_id)
                except:
                    pass
        except:
            pass

        try:
            if hasattr(self, 'progress') and self.progress and self.progress.winfo_exists():
                self.progress.stop()
        except:
            pass

        try:
            if hasattr(self, 'entry_password') and self.entry_password.winfo_exists():
                self.entry_password.delete(0, "end")
        except:
            pass

        try:
            self.quit()
            self.destroy()
        except:
            pass

============================================================
FILE: views\main_window.py
SIZE: 55631 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/main_window.py - النسخة المحسنة والمقللة

النافذة الرئيسية مع دمج جميع المميزات المتقدمة في كود مبسط
تفتح في وضع ملء الشاشة كوضع افتراضي مع معالجة شاملة للأخطاء
"""

import customtkinter as ctk
import threading
import os
import tkinter as tk
from tkinter import messagebox
from typing import Any, Dict, List
from datetime import datetime
import platform
import weakref
from functools import wraps

# الاستيرادات الأساسية
from core.language_manager import LanguageManager
from core.theme_manager import ThemeManager
from core.theme_color_manager import ThemeColorManager, ThemedWindow
from core.logger import logger
from core.permissions import permission_manager
from utils.window_manager import WindowManager

# الأنظمة المحسنة الجديدة
from core.state_manager import StateManager, WindowState
from core.event_system import EventBus
from utils.async_operations import AsyncOperationManager

# استيراد المكونات
from views.components.header import HeaderComponent
from views.components.sidebar import SidebarComponent
from views.components.data_table import DataTableComponent
from views.components.toolbar import ToolbarComponent
from views.components.status_bar import StatusBarComponent
from views.components.menu_bar import MenuBarComponent
from utils.image_utils import setup_window_icon


def safe_operation(func):
    """Decorator للعمليات الآمنة"""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        if not self._is_window_valid():
            return None
        try:
            return func(self, *args, **kwargs)
        except Exception as e:
            logger.debug(f"Safe operation error in {func.__name__}: {e}")
            return None
    return wrapper


def error_handler(func):
    """Decorator لمعالجة الأخطاء العامة"""
    @wraps(func)
    def wrapper(self, *args, **kwargs):
        try:
            return func(self, *args, **kwargs)
        except Exception as e:
            logger.error(f"Error in {func.__name__}: {e}")
            return None
    return wrapper


class SafeAfterManager:
    """مدير آمن مبسط للعمليات المجدولة"""

    def __init__(self, window):
        self.window_ref = weakref.ref(window)
        self.operations = {}
        self.next_id = 1
        self._shutdown = False

    def schedule(self, delay, operation, *args, **kwargs):
        if self._shutdown:
            return None

        window = self.window_ref()
        if not window or not self._is_window_valid(window):
            return None

        operation_id = f"op_{self.next_id}"
        self.next_id += 1

        def safe_wrapper():
            self.operations.pop(operation_id, None)
            current_window = self.window_ref()
            if not self._shutdown and current_window and self._is_window_valid(current_window):
                try:
                    operation(*args, **kwargs)
                except Exception as e:
                    logger.debug(f"Scheduled operation error: {e}")

        try:
            after_id = window.after(delay, safe_wrapper)
            self.operations[operation_id] = after_id
            return operation_id
        except:
            return None

    def cancel_all(self):
        self._shutdown = True
        window = self.window_ref()
        if window and self._is_window_valid(window):
            for after_id in self.operations.values():
                try:
                    window.after_cancel(after_id)
                except:
                    pass
        self.operations.clear()

    def _is_window_valid(self, window):
        try:
            return window.winfo_exists() and not getattr(window, '_window_destroyed', False)
        except:
            return False


class MainWindow(ctk.CTk):
    """النافذة الرئيسية المحسنة مع كود مبسط"""

    def __init__(self, lang_manager: LanguageManager, theme_manager: ThemeManager,
                 airtable_model: Any, controller: Any, user_record: Dict[str, Any],
                 parent_window: Any = None):
        super().__init__()

        # تهيئة المتغيرات الأساسية
        self.parent_window = parent_window
        self.lang_manager = lang_manager
        self.theme_manager = theme_manager
        self.airtable_model = airtable_model
        self.controller = controller
        self.user_record = user_record

        # النظام الموحد والبيانات
        self.themed_window = ThemedWindow(self, theme_manager)
        self.all_records = []
        self.filtered_records = []
        self.selected_records = []
        self.current_page = 1
        self.records_per_page = 50

        # متغيرات الحالة
        self._is_fullscreen = False
        self._closing = False
        self._window_destroyed = False

        # مدير العمليات المجدولة
        self.safe_after = SafeAfterManager(self)

        # تهيئة الأنظمة الجديدة
        self._init_systems()

        # إعداد وبناء الواجهة
        self._setup_window()
        self._apply_theme()
        self._build_ui()

        # إعداد النافذة والاختصارات
        WindowManager.setup_window(self, parent=self.parent_window, center=False,
                                 modal=False, focus=True, topmost_duration=500,
                                 min_size=(1200, 700), fullscreen_default=True)

        self._setup_shortcuts()

        # تطبيق ملء الشاشة وتحميل البيانات
        self.safe_after.schedule(100, self._apply_fullscreen_mode)
        self.safe_after.schedule(500, self._load_data)

        # معالج الإغلاق
        self.protocol("WM_DELETE_WINDOW", self._on_close)
        self.bind("<Destroy>", self._on_window_destroy)

    def _init_systems(self):
        """تهيئة الأنظمة الجديدة"""
        try:
            self.state_manager = StateManager()
            self.event_bus = EventBus()
            self.async_manager = AsyncOperationManager()

            self.window_state = WindowState()
            self.state_manager.register_state("main_window", self.window_state)

            if self.event_bus:
                self.event_bus.subscribe("data_loaded", self._on_data_loaded_event)
                self.event_bus.subscribe("search_completed", self._on_search_completed_event)
                self.event_bus.subscribe("error_occurred", self._on_error_event)
        except Exception as e:
            logger.warning(f"Failed to initialize some systems: {e}")
            self.state_manager = None
            self.event_bus = None
            self.async_manager = None

    def _on_window_destroy(self, event=None):
        """معالج تدمير النافذة"""
        if event and event.widget == self:
            self._window_destroyed = True
            self._closing = True
            if hasattr(self, 'safe_after'):
                self.safe_after.cancel_all()

    def _is_window_valid(self):
        """فحص صحة النافذة"""
        try:
            return not self._window_destroyed and not self._closing and self.winfo_exists()
        except:
            self._window_destroyed = True
            return False

    @safe_operation
    def _safe_status_update(self, message, status_type="info"):
        """تحديث آمن لشريط الحالة"""
        if hasattr(self, 'status_bar') and self.status_bar:
            try:
                self.status_bar.set_status(message, status_type)
            except:
                pass

    @safe_operation
    def _safe_toolbar_update(self, **kwargs):
        """تحديث آمن لشريط الأدوات"""
        if hasattr(self, 'toolbar') and self.toolbar:
            for method_name, value in kwargs.items():
                if hasattr(self.toolbar, method_name):
                    try:
                        getattr(self.toolbar, method_name)(value)
                    except:
                        pass

    def _setup_window(self):
        """إعداد النافذة"""
        username = self.user_record.get('fields', {}).get('Username', 'User')
        self.title(f"{self.lang_manager.get('main_window_title', 'FTS Sales Manager')} - {username}")

        self._set_window_icon()

        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()
        self.geometry(f"{screen_width}x{screen_height}+0+0")
        self.minsize(1200, 700)

    def _set_window_icon(self):
        """تعيين أيقونة النافذة"""
        icon_paths = [
            "resources/app_icon.ico", "resources/fts_icon.ico", "resources/icon.ico",
            "assets/icon.ico", "resources/app_icon.png", "resources/company_logo.png",
            "resources/icon.png", "assets/icon.png"
        ]
        setup_window_icon(self, icon_paths)

    def _apply_theme(self):
        """تطبيق الثيم الموحد"""
        self.themed_window.apply_theme()
        if hasattr(self.theme_manager, 'is_windows7_theme') and self.theme_manager.is_windows7_theme():
            self._apply_windows7_theme()

    def _apply_windows7_theme(self):
        """تطبيق ثيم Windows 7"""
        try:
            if hasattr(self.theme_manager, 'get_theme_colors'):
                colors = self.theme_manager.get_theme_colors()
                self.configure(fg_color=colors.get("window_bg", self.themed_window.get_color('background')))
            if platform.system() == "Windows":
                self.wm_attributes('-alpha', 0.98)
        except Exception as e:
            logger.debug(f"Error applying Windows 7 theme: {e}")

    def _build_ui(self):
        """بناء الواجهة"""
        # الحاوية الرئيسية
        self.main_container = ctk.CTkFrame(self, corner_radius=0, fg_color="transparent")
        self.main_container.pack(fill="both", expand=True)

        # إنشاء شريط القوائم
        self._create_menu_bar()

        # إنشاء المكونات
        self._create_header()
        self._create_separator()
        self._create_content_area()
        self._create_status_bar()

    def _create_menu_bar(self):
        """إنشاء شريط القوائم"""
        if hasattr(self.theme_manager, 'is_windows7_theme') and self.theme_manager.is_windows7_theme():
            self._create_windows7_menu_bar()
        else:
            self._create_standard_menu_bar()

    def _create_windows7_menu_bar(self):
        """شريط قوائم Windows 7"""
        colors = getattr(self.theme_manager, 'get_theme_colors', lambda: {
            "menu_bg": "#F0F0F0", "text_color": "#000000",
            "menu_hover": "#E5F1FB", "menu_border": "#D4D4D4"
        })()

        menubar_frame = ctk.CTkFrame(self, height=28, fg_color=colors.get("menu_bg", "#F0F0F0"), corner_radius=0)
        menubar_frame.pack(fill="x")
        menubar_frame.pack_propagate(False)

        # إضافة border وقوائم
        menu_border = ctk.CTkFrame(menubar_frame, height=1, fg_color=colors.get("menu_border", "#D4D4D4"))
        menu_border.pack(side="bottom", fill="x")

        menu_items = [
            (self.lang_manager.get("menu_file", "File"), self._show_menu),
            (self.lang_manager.get("menu_edit", "Edit"), self._show_menu),
            (self.lang_manager.get("menu_view", "View"), self._show_menu),
            (self.lang_manager.get("menu_tools", "Tools"), self._show_menu),
            (self.lang_manager.get("menu_help", "Help"), self._show_menu)
        ]

        for item_text, command in menu_items:
            btn = ctk.CTkButton(menubar_frame, text=item_text, width=70, height=26, corner_radius=0,
                              fg_color="transparent", text_color=colors.get("text_color", "#000000"),
                              hover_color=colors.get("menu_hover", "#E5F1FB"),
                              font=ctk.CTkFont(family="Segoe UI", size=12), command=command)
            btn.pack(side="left", padx=2, pady=1)

        self.windows7_menubar = menubar_frame

    def _create_standard_menu_bar(self):
        """شريط القوائم القياسي"""
        menu_callbacks = {
            'logout': self._logout, 'export': self._export_data, 'close': self._on_close,
            'add': self._add_record, 'edit': self._edit_record, 'delete': self._delete_record,
            'select_all': self._select_all, 'clear_selection': self._clear_selection,
            'toggle_theme': self._toggle_theme, 'change_language': self._change_language_from_menu,
            'refresh': self._refresh_data, 'fullscreen_changed': self._on_fullscreen_changed,
            'performance_mode': self._on_performance_mode_changed, 'search': self._focus_search,
            'statistics': self._show_statistics, 'reports': self._show_reports,
            'user_management': self._show_placeholder, 'config_editor': self._show_placeholder,
            'clear_cache': self._clear_cache, 'view_logs': self._show_placeholder,
            'shortcuts': self._show_help, 'user_guide': self._show_user_guide,
            'about': self._show_about, 'themes_menu': self._show_placeholder,
        }

        self.menu_bar = MenuBarComponent(parent_window=self, lang_manager=self.lang_manager,
                                       user_record=self.user_record, callbacks=menu_callbacks)

    def _create_header(self):
        """إنشاء الهيدر"""
        header_frame = ctk.CTkFrame(self.main_container, height=80, corner_radius=0,
                                  fg_color=self.themed_window.get_color('surface'))
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)

        self.header = HeaderComponent(header_frame, lang_manager=self.lang_manager,
                                    user_record=self.user_record, controller=self.controller,
                                    on_search=self._on_search, on_refresh=self._refresh_data,
                                    on_language_change=self._handle_language_change,
                                    on_theme_change=self._handle_theme_change)
        self.header.pack(fill="both", expand=True, padx=20, pady=10)

        self._add_language_button()

    def _add_language_button(self):
        """إضافة زر اللغة"""
        current_lang = self.lang_manager.current_lang
        button_text = "🌐 EN" if current_lang == "ar" else "🌐 AR"

        parent = getattr(self.header, 'right_frame', self.header)
        self.language_button = ctk.CTkButton(parent, text=button_text, width=100, height=36,
                                           command=self._toggle_language, font=ctk.CTkFont(size=14, weight="bold"),
                                           corner_radius=8, fg_color=("#007ACC", "#0E639C"),
                                           hover_color=("#005A9E", "#1177BB"))
        self.language_button.pack(side="right", padx=10)

    def _create_separator(self):
        """إنشاء خط فاصل"""
        separator = ctk.CTkFrame(self.main_container, height=2, fg_color=self.themed_window.get_color('border'))
        separator.pack(fill="x")

    def _create_content_area(self):
        """إنشاء منطقة المحتوى"""
        content_frame = ctk.CTkFrame(self.main_container, corner_radius=0, fg_color="transparent")
        content_frame.pack(fill="both", expand=True)

        # الشريط الجانبي
        self._create_sidebar(content_frame)

        # منطقة العمل
        self._create_work_area(content_frame)

    def _create_sidebar(self, parent):
        """إنشاء الشريط الجانبي"""
        self.sidebar_container = ctk.CTkFrame(parent, width=280, corner_radius=0,
                                            fg_color=self.themed_window.get_color('input_bg'))
        self.sidebar_container.pack(side="left", fill="y")
        self.sidebar_container.pack_propagate(False)

        shadow_frame = ctk.CTkFrame(self.sidebar_container, width=2, fg_color=self.themed_window.get_color('border'))
        shadow_frame.pack(side="right", fill="y")

        self.sidebar = SidebarComponent(self.sidebar_container, self.lang_manager, on_navigate=self._on_navigate)
        self.sidebar.pack(fill="both", expand=True, padx=15, pady=15)

    def _create_work_area(self, parent):
        """إنشاء منطقة العمل"""
        work_area_container = ctk.CTkFrame(parent, corner_radius=0, fg_color=self.themed_window.get_color('surface'))
        work_area_container.pack(side="left", fill="both", expand=True)

        work_area = ctk.CTkFrame(work_area_container, corner_radius=10, fg_color=self.themed_window.get_color('background'))
        work_area.pack(fill="both", expand=True, padx=20, pady=15)

        # شريط الأدوات
        self._create_toolbar(work_area)

        # جدول البيانات
        self._create_data_table(work_area)

    def _create_toolbar(self, parent):
        """إنشاء شريط الأدوات"""
        toolbar_container = ctk.CTkFrame(parent, height=60, corner_radius=8, fg_color=self.themed_window.get_color('surface'))
        toolbar_container.pack(fill="x", padx=15, pady=(15, 10))
        toolbar_container.pack_propagate(False)

        self.toolbar = ToolbarComponent(toolbar_container, self.lang_manager, on_add=self._add_record,
                                      on_edit=self._edit_record, on_delete=self._delete_record,
                                      on_refresh=self._refresh_data, on_export=self._export_data)
        self.toolbar.pack(fill="both", expand=True, padx=10, pady=10)

    def _create_data_table(self, parent):
        """إنشاء جدول البيانات"""
        table_container = ctk.CTkFrame(parent, corner_radius=8, fg_color=self.themed_window.get_color('surface'))
        table_container.pack(fill="both", expand=True, padx=15, pady=(0, 15))

        # عنوان الجدول
        table_header = ctk.CTkFrame(table_container, height=40, corner_radius=0, fg_color=self.themed_window.get_color('input_bg'))
        table_header.pack(fill="x")
        table_header.pack_propagate(False)

        self.table_title = ctk.CTkLabel(table_header, text=self.lang_manager.get("bookings_list", "Bookings List"),
                                      font=ctk.CTkFont(size=16, weight="bold"),
                                      text_color=self.themed_window.get_color('text_primary'))
        self.table_title.pack(side="left", padx=20, pady=10)

        # الجدول
        self.data_table = DataTableComponent(table_container, self.lang_manager,
                                           on_row_double_click=self._on_row_double_click,
                                           on_selection_change=self._on_selection_change)
        self.data_table.pack(fill="both", expand=True, padx=15, pady=15)

    def _create_status_bar(self):
        """إنشاء شريط الحالة"""
        status_container = ctk.CTkFrame(self.main_container, height=35, corner_radius=0,
                                      fg_color=self.themed_window.get_color('input_bg'))
        status_container.pack(fill="x", side="bottom")
        status_container.pack_propagate(False)

        status_separator = ctk.CTkFrame(status_container, height=1, fg_color=self.themed_window.get_color('border'))
        status_separator.pack(fill="x", side="top")

        self.status_bar = StatusBarComponent(status_container, self.lang_manager)
        self.status_bar.pack(fill="both", expand=True, padx=20, pady=5)

    def _setup_shortcuts(self):
        """إعداد اختصارات لوحة المفاتيح"""
        WindowManager.setup_window_shortcuts(self)

        shortcuts = {
            "<Control-n>": lambda e: self._add_record(), "<Control-e>": lambda e: self._edit_record(),
            "<Delete>": lambda e: self._delete_record(), "<F5>": lambda e: self._refresh_data(),
            "<Control-f>": lambda e: self._focus_search(), "<Control-a>": lambda e: self._select_all(),
            "<Control-s>": lambda e: self._export_data(), "<F1>": lambda e: self._show_help(),
            "<Control-l>": lambda e: self._toggle_language(), "<Control-t>": lambda e: self._toggle_theme(),
            "<Control-Shift-L>": lambda e: self._logout(), "<Control-Shift-F>": lambda e: self._show_placeholder(),
            "<Control-p>": lambda e: self._show_placeholder(), "<F11>": lambda e: self._toggle_fullscreen(),
            "<Escape>": lambda e: self._exit_fullscreen(), "<Alt-Return>": lambda e: self._toggle_fullscreen(),
        }

        for key, command in shortcuts.items():
            self.bind(key, command)

    @error_handler
    def _apply_fullscreen_mode(self):
        """تطبيق وضع ملء الشاشة"""
        try:
            system = platform.system()
            if system == "Windows":
                self.state('zoomed')
            elif system == "Linux":
                try:
                    self.attributes('-zoomed', True)
                except:
                    self.attributes('-fullscreen', True)
            elif system == "Darwin":
                self.attributes('-fullscreen', True)

            self._is_fullscreen = True
            self._safe_status_update(self.lang_manager.get("fullscreen_enabled", "Fullscreen mode enabled"), "success")
            if self._is_window_valid():
                self.update_idletasks()
        except Exception as e:
            logger.error(f"Fullscreen error: {e}")
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()
            self.geometry(f"{screen_width-100}x{screen_height-100}+50+50")
            self._is_fullscreen = False

    @error_handler
    def _toggle_fullscreen(self):
        """تبديل وضع ملء الشاشة"""
        system = platform.system()

        if system == "Windows":
            current_state = self.state()
            if current_state == 'zoomed':
                self.state('normal')
                self._is_fullscreen = False
            else:
                self.state('zoomed')
                self._is_fullscreen = True
        else:
            try:
                current_state = self.attributes('-fullscreen')
                new_state = not current_state
                self.attributes('-fullscreen', new_state)
                self._is_fullscreen = new_state
            except:
                if system == "Linux":
                    current_state = self.attributes('-zoomed')
                    new_state = not current_state
                    self.attributes('-zoomed', new_state)
                    self._is_fullscreen = new_state

        status = "enabled" if self._is_fullscreen else "disabled"
        self._safe_status_update(self.lang_manager.get(f"fullscreen_{status}", f"Fullscreen {status}"), "info")

        if hasattr(self, 'menu_bar') and self.menu_bar:
            try:
                self.menu_bar.update_fullscreen_state(self._is_fullscreen)
            except:
                pass

    @safe_operation
    def _exit_fullscreen(self):
        """الخروج من وضع ملء الشاشة"""
        if self._is_fullscreen:
            system = platform.system()
            if system == "Windows":
                self.state('normal')
            else:
                try:
                    self.attributes('-fullscreen', False)
                except:
                    if system == "Linux":
                        self.attributes('-zoomed', False)

            self._is_fullscreen = False
            self._safe_status_update(self.lang_manager.get("fullscreen_disabled", "Fullscreen disabled"), "info")

    # ==================== دوال البيانات ====================

    @error_handler
    def _load_data(self):
        """تحميل البيانات"""
        self._safe_status_update(self.lang_manager.get("loading_data", "Loading data..."))
        self._safe_toolbar_update(set_loading=True)

        if self.window_state:
            self.window_state.is_loading = True

        def load_thread():
            try:
                records = self.controller.fetch_all_records()
                if self._is_window_valid():
                    self.safe_after.schedule(0, self._on_data_loaded, records)
            except Exception as e:
                if self._is_window_valid():
                    self.safe_after.schedule(0, self._on_load_error, str(e))

        threading.Thread(target=load_thread, daemon=True).start()

    @safe_operation
    def _on_data_loaded(self, records):
        """معالج تحميل البيانات"""
        self.all_records = records
        self.filtered_records = records

        if self.window_state:
            self.window_state.update_records(records)
            self.window_state.is_loading = False

        if hasattr(self, 'data_table') and self.data_table:
            try:
                self.data_table.display_data(records)
            except Exception as e:
                logger.error(f"Display data error: {e}")

        status_msg = self.lang_manager.get("status_load_complete", "{} records loaded").format(len(records))
        self._safe_status_update(status_msg, "success")
        self._safe_toolbar_update(set_loading=False)
        self._update_stats()

        if self.event_bus:
            self.event_bus.emit("data_loaded", {"count": len(records), "timestamp": datetime.now()})

    @safe_operation
    def _on_load_error(self, error_message):
        """معالج أخطاء التحميل"""
        self._safe_status_update(f"{self.lang_manager.get('error', 'Error')}: {error_message}", "error")
        self._safe_toolbar_update(set_loading=False)

        try:
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showerror(self.lang_manager.get("error", "Error"),
                               f"{self.lang_manager.get('error_load', 'Failed to load data')}:\n{error_message}")
        except:
            pass

    @error_handler
    def _refresh_data(self):
        """تحديث البيانات"""
        self._safe_status_update(self.lang_manager.get("refreshing_data", "Refreshing data..."))
        self._safe_toolbar_update(set_loading=True)

        def refresh_thread():
            try:
                records = self.controller.fetch_all_records(force_refresh=True)
                if self._is_window_valid():
                    self.safe_after.schedule(0, self._on_data_refreshed, records)
            except Exception as e:
                if self._is_window_valid():
                    self.safe_after.schedule(0, self._on_refresh_error, str(e))

        threading.Thread(target=refresh_thread, daemon=True).start()

    @safe_operation
    def _on_data_refreshed(self, records):
        """معالج تحديث البيانات"""
        self.all_records = records
        self.filtered_records = records

        if hasattr(self, 'data_table') and self.data_table:
            try:
                self.data_table.display_data(records)
            except Exception as e:
                logger.error(f"Display refreshed data error: {e}")

        status_msg = self.lang_manager.get("success_update", "Data updated successfully") + f" - {len(records)} " + \
                    self.lang_manager.get("total_records", "records")
        self._safe_status_update(status_msg, "success")
        self._safe_toolbar_update(set_loading=False)
        self._update_stats()

        self.selected_records = []
        self._safe_toolbar_update(update_selection=0)

    @safe_operation
    def _on_refresh_error(self, error_message):
        """معالج أخطاء التحديث"""
        self._safe_status_update(f"{self.lang_manager.get('error_update', 'Update error')}: {error_message}", "error")
        self._safe_toolbar_update(set_loading=False)

        try:
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showerror(self.lang_manager.get("error", "Error"),
                               f"{self.lang_manager.get('error_update', 'Failed to update data')}:\n{error_message}")
        except:
            pass

    @safe_operation
    def _on_search(self, search_text):
        """معالج البحث"""
        if not search_text:
            self.filtered_records = self.all_records
        else:
            search_lower = search_text.lower()
            self.filtered_records = [r for r in self.all_records
                                   if search_lower in str(r.get('fields', {})).lower()]

        if self.window_state:
            self.window_state.filtered_records = self.filtered_records
            self.window_state.search_query = search_text

        if hasattr(self, 'data_table') and self.data_table:
            try:
                self.data_table.display_data(self.filtered_records)
            except Exception as e:
                logger.error(f"Display search results error: {e}")

        status_msg = (f"{self.lang_manager.get('showing', 'Showing')} {len(self.filtered_records)} "
                     f"{self.lang_manager.get('of', 'of')} {len(self.all_records)} "
                     f"{self.lang_manager.get('total_records', 'records')}")
        self._safe_status_update(status_msg)

        if self.event_bus:
            self.event_bus.emit("search_completed", {"query": search_text, "results": len(self.filtered_records)})

    def _update_stats(self):
        """تحديث الإحصائيات"""
        try:
            if hasattr(self, 'sidebar') and self.sidebar and hasattr(self.sidebar, 'update_stats'):
                stats = {
                    'total': len(self.all_records),
                    'today': self._count_records('today'),
                    'pending': self._count_records('pending')
                }
                self.sidebar.update_stats(stats)
        except Exception as e:
            logger.debug(f"Update stats error: {e}")

    def _count_records(self, count_type):
        """عد السجلات حسب النوع"""
        try:
            if count_type == 'today':
                today = str(datetime.now().date())
                return sum(1 for r in self.all_records
                          if r.get('fields', {}).get('Date Trip', '')[:10] == today)
            elif count_type == 'pending':
                return sum(1 for r in self.all_records
                          if r.get('fields', {}).get('Booking Status', '').lower() == 'pending')
            return 0
        except Exception as e:
            logger.debug(f"Count records error: {e}")
            return 0

    # ==================== دوال CRUD ====================

    @error_handler
    def _add_record(self):
        """إضافة حجز جديد"""
        try:
            WindowManager.bring_to_front(self, duration=100)
            self.controller.open_add_form()
            self.safe_after.schedule(1000, self._refresh_data)
        except Exception as e:
            messagebox.showerror(self.lang_manager.get("error", "Error"),
                               self.lang_manager.get("error_add_form", "Failed to open add form"))

    @error_handler
    def _edit_record(self):
        """تعديل الحجز المحدد"""
        if not self.selected_records:
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showwarning(self.lang_manager.get("warning", "Warning"),
                                 self.lang_manager.get("select_booking_edit", "Please select a booking to edit"))
            return

        if len(self.selected_records) > 1:
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showwarning(self.lang_manager.get("warning", "Warning"),
                                 self.lang_manager.get("select_one_booking_only", "You can only edit one booking at a time"))
            return

        try:
            WindowManager.bring_to_front(self, duration=100)
            record = self.selected_records[0]
            self.controller.set_selected_record(record)
            self.controller.open_edit_form()
            self.safe_after.schedule(1000, self._refresh_data)
        except Exception as e:
            messagebox.showerror(self.lang_manager.get("error", "Error"),
                               self.lang_manager.get("error_edit_form", "Failed to open edit form"))

    @error_handler
    def _delete_record(self):
        """حذف الحجز المحدد"""
        if not self.selected_records:
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showwarning(self.lang_manager.get("warning", "Warning"),
                                 self.lang_manager.get("select_booking_delete", "Please select a booking to delete"))
            return

        # تأكيد الحذف
        count = len(self.selected_records)
        if count > 1:
            msg = self.lang_manager.get("confirm_delete_multiple", "Are you sure you want to delete {} bookings?").format(count)
        else:
            msg = self.lang_manager.get("confirm_delete", "Are you sure you want to delete this booking?")

        if not messagebox.askyesno(self.lang_manager.get("confirm", "Confirm"), msg):
            return

        def delete_thread():
            try:
                success_count = 0
                for record in self.selected_records:
                    self.controller.set_selected_record(record)
                    if self.controller.delete_record():
                        success_count += 1

                if self._is_window_valid():
                    self.safe_after.schedule(0, self._on_delete_complete, success_count, len(self.selected_records))
            except Exception as e:
                if self._is_window_valid():
                    self.safe_after.schedule(0, self._show_delete_error, str(e))

        self._safe_status_update(self.lang_manager.get("processing", "Processing..."))
        threading.Thread(target=delete_thread, daemon=True).start()

    @safe_operation
    def _on_delete_complete(self, success_count, total_count):
        """معالج اكتمال الحذف"""
        if success_count == total_count:
            msg = self.lang_manager.get("success_delete", "Deleted successfully") + f" ({success_count})"
            self._safe_status_update(msg, "success")
            messagebox.showinfo(self.lang_manager.get("success", "Success"), msg)
        else:
            msg = f"{success_count} {self.lang_manager.get('of', 'of')} {total_count} {self.lang_manager.get('deleted', 'deleted')}"
            self._safe_status_update(msg, "warning")
            WindowManager.flash_window(self, count=2, interval=300)
            messagebox.showwarning(self.lang_manager.get("warning", "Warning"), msg)

        self._refresh_data()
        if hasattr(self, 'data_table') and self.data_table:
            try:
                self.data_table.clear_selection()
            except:
                pass

        self.selected_records = []
        self._safe_toolbar_update(update_selection=0)

    @safe_operation
    def _show_delete_error(self, error_msg):
        """عرض خطأ الحذف"""
        try:
            messagebox.showerror(self.lang_manager.get("error", "Error"),
                               f"{self.lang_manager.get('error_delete', 'Failed to delete record')}:\n{error_msg}")
        except:
            pass

    # ==================== دوال الواجهة ====================

    @safe_operation
    def _on_row_double_click(self, record):
        """معالج النقر المزدوج"""
        if record:
            self.selected_records = [record]
            self._safe_toolbar_update(update_selection=1)
            self._edit_record()

    @safe_operation
    def _on_selection_change(self, selected_records):
        """معالج تغيير التحديد"""
        self.selected_records = selected_records
        count = len(selected_records)
        self._safe_toolbar_update(update_selection=count)

        if count == 0:
            status_msg = f"{self.lang_manager.get('showing', 'Showing')} {len(self.filtered_records)} {self.lang_manager.get('total_records', 'records')}"
        else:
            status_msg = self.lang_manager.get("selected_count", "Selected: {} booking(s)").format(count)

        self._safe_status_update(status_msg)

    @safe_operation
    def _on_navigate(self, destination):
        """معالج التنقل"""
        self._safe_status_update(f"{self.lang_manager.get('navigating_to', 'Navigating to')}: {destination}")

    # ==================== دوال اللغة والثيم ====================

    @error_handler
    def _toggle_language(self):
        """تبديل اللغة"""
        current_lang = self.lang_manager.current_lang
        new_lang = "en" if current_lang == "ar" else "ar"

        confirm_msg = self.lang_manager.get("confirm_change_language", "Change language?")
        if messagebox.askyesno(self.lang_manager.get("menu_change_language", "Change Language"), confirm_msg):
            self.lang_manager.set_language(new_lang)

            button_text = "🌐 EN" if new_lang == "ar" else "🌐 AR"
            if hasattr(self, 'language_button') and self.language_button:
                try:
                    self.language_button.configure(text=button_text)
                except:
                    pass

            self._update_all_texts()

            if hasattr(self.controller, 'update_all_windows_language'):
                try:
                    self.controller.update_all_windows_language()
                except:
                    pass

            self._safe_status_update(self.lang_manager.get("success_save", "Language changed successfully"), "success")

    @error_handler
    def _toggle_theme(self):
        """تبديل الثيم"""
        current_mode = self.theme_manager.get_current_appearance_mode()
        new_mode = "dark" if current_mode == "light" else "light"

        self.theme_manager.apply_appearance_mode(new_mode)
        ctk.set_appearance_mode(new_mode)

        self.themed_window.refresh_theme()
        self._refresh_all_components_theme()

        theme_name = "Dark" if new_mode == "dark" else "Light"
        self._safe_status_update(f"Theme changed to {theme_name}", "success")

    @safe_operation
    def _handle_language_change(self, new_language):
        """معالج تغيير اللغة من الهيدر"""
        self.lang_manager.set_language(new_language)

        button_text = "🌐 EN" if new_language == "ar" else "🌐 AR"
        if hasattr(self, 'language_button') and self.language_button:
            try:
                self.language_button.configure(text=button_text)
            except:
                pass

        self._update_all_texts()

        if hasattr(self.controller, 'update_all_windows_language'):
            try:
                self.controller.update_all_windows_language()
            except:
                pass

        self._safe_status_update(self.lang_manager.get("success_save", "Language changed successfully"), "success")

    @safe_operation
    def _handle_theme_change(self, new_theme):
        """معالج تغيير الثيم من الهيدر"""
        ctk.set_appearance_mode(new_theme.lower())

        if hasattr(self.theme_manager, 'apply_appearance_mode'):
            self.theme_manager.apply_appearance_mode(new_theme.lower())
        elif hasattr(self.theme_manager, 'current_mode'):
            self.theme_manager.current_mode = new_theme.lower()

        self._apply_theme()
        self.refresh_theme()

        if hasattr(self, 'menu_bar') and self.menu_bar:
            try:
                self.menu_bar.update_dark_mode(new_theme.lower() == "dark")
            except:
                pass

        theme_name = "Dark" if new_theme.lower() == "dark" else "Light"
        self._safe_status_update(f"Theme changed to {theme_name}", "success")

    @safe_operation
    def _update_all_texts(self):
        """تحديث جميع النصوص"""
        username = self.user_record.get('fields', {}).get('Username', 'User')
        self.title(f"{self.lang_manager.get('main_window_title', 'FTS Sales Manager')} - {username}")

        # تحديث المكونات
        components = ['header', 'sidebar', 'toolbar', 'data_table', 'status_bar']
        for component_name in components:
            if hasattr(self, component_name):
                component = getattr(self, component_name)
                if component and hasattr(component, 'update_texts'):
                    try:
                        component.update_texts(self.lang_manager)
                    except Exception as e:
                        logger.debug(f"Update texts error for {component_name}: {e}")

        if hasattr(self, 'menu_bar') and self.menu_bar and hasattr(self.menu_bar, 'update_texts'):
            try:
                self.menu_bar.update_texts()
            except:
                pass

        if hasattr(self, 'table_title') and self.table_title:
            try:
                self.table_title.configure(text=self.lang_manager.get("bookings_list", "Bookings List"))
            except:
                pass

    @safe_operation
    def _refresh_all_components_theme(self):
        """تحديث ثيم جميع المكونات"""
        if hasattr(self, 'main_container') and self.main_container:
            self.themed_window.apply_to_widget(self.main_container, 'frame')

        components = ['header', 'sidebar', 'toolbar', 'data_table', 'status_bar']
        for component_name in components:
            if hasattr(self, component_name):
                component = getattr(self, component_name)
                if component:
                    try:
                        if hasattr(component, 'refresh_theme'):
                            component.refresh_theme()
                        elif hasattr(component, 'apply_theme'):
                            component.apply_theme(self.themed_window)
                    except Exception as e:
                        logger.debug(f"Refresh theme error for {component_name}: {e}")

        if hasattr(self, 'windows7_menubar'):
            self._update_windows7_menubar_theme()

    def _update_windows7_menubar_theme(self):
        """تحديث ثيم شريط قوائم Windows 7"""
        try:
            colors = getattr(self.theme_manager, 'get_theme_colors', lambda: {
                "menu_bg": self.themed_window.get_color('surface'),
                "text_color": self.themed_window.get_color('text_primary'),
                "menu_hover": self.themed_window.get_color('input_bg')
            })()

            if hasattr(self, 'windows7_menubar') and self.windows7_menubar:
                self.windows7_menubar.configure(fg_color=colors.get("menu_bg"))

                for widget in self.windows7_menubar.winfo_children():
                    if isinstance(widget, ctk.CTkButton):
                        widget.configure(text_color=colors.get("text_color"), hover_color=colors.get("menu_hover"))
        except Exception as e:
            logger.debug(f"Windows 7 menubar theme update error: {e}")

    def refresh_theme(self):
        """تحديث الثيم العام"""
        try:
            self._apply_theme()
            if hasattr(self, 'main_container') and self.main_container:
                self.main_container.configure(fg_color="transparent")
            self._refresh_all_components_theme()
        except Exception as e:
            logger.error(f"Refresh theme error: {e}")

    def get_themed_color(self, color_name: str, fallback: str = None) -> str:
        """دالة مساعدة للحصول على الألوان"""
        return self.themed_window.get_color(color_name, fallback)

    # ==================== دوال الاختصارات ====================

    @safe_operation
    def _focus_search(self):
        """التركيز على حقل البحث"""
        if hasattr(self.header, 'search_entry') and self.header.search_entry:
            self.header.search_entry.focus_set()
            WindowManager.bring_to_front(self, duration=100)

    @safe_operation
    def _select_all(self):
        """تحديد جميع السجلات"""
        if hasattr(self.data_table, 'tree') and self.data_table.tree:
            self.data_table.tree.selection_set(self.data_table.tree.get_children())
            self._on_selection_change(self.all_records)

    @safe_operation
    def _clear_selection(self):
        """إلغاء التحديد"""
        if hasattr(self.data_table, 'clear_selection'):
            self.data_table.clear_selection()
        self.selected_records = []
        self._safe_toolbar_update(update_selection=0)

    # ==================== دوال القوائم ====================

    def _show_menu(self):
        """عرض قائمة عامة (Windows 7)"""
        pass

    def _show_placeholder(self):
        """عرض رسالة placeholder للميزات قيد التطوير"""
        self._safe_status_update(self.lang_manager.get("coming_soon", "Coming soon"), "info")

    @error_handler
    def _logout(self):
        """تسجيل الخروج"""
        if messagebox.askyesno(self.lang_manager.get("confirm", "Confirm"),
                             self.lang_manager.get("confirm_logout", "Are you sure you want to logout?")):
            self.destroy()
            if hasattr(self.controller, 'on_logout'):
                try:
                    self.controller.on_logout()
                except:
                    pass
            if hasattr(self.controller, 'run'):
                try:
                    self.controller.run()
                except:
                    pass

    @error_handler
    def _export_data(self):
        """تصدير البيانات"""
        self._safe_status_update(self.lang_manager.get("export", "Export") + " - " +
                                 self.lang_manager.get("coming_soon", "Coming soon"))
        WindowManager.flash_window(self, count=2, interval=300)
        messagebox.showinfo(self.lang_manager.get("info", "Information"),
                          self.lang_manager.get("export_coming_soon", "Export feature coming soon"))

    @safe_operation
    def _change_language_from_menu(self, lang_code: str):
        """تغيير اللغة من القائمة"""
        if self.lang_manager.current_lang != lang_code:
            self.lang_manager.set_language(lang_code)

            button_text = "🌐 EN" if lang_code == "ar" else "🌐 AR"
            if hasattr(self, 'language_button') and self.language_button:
                try:
                    self.language_button.configure(text=button_text)
                except:
                    pass

            self._update_all_texts()

            if hasattr(self.controller, 'update_all_windows_language'):
                try:
                    self.controller.update_all_windows_language()
                except:
                    pass

            self._safe_status_update(self.lang_manager.get("success_save", "Language changed successfully"), "success")

    @safe_operation
    def _on_fullscreen_changed(self, is_fullscreen: bool):
        """معالج تغيير وضع ملء الشاشة"""
        self._is_fullscreen = is_fullscreen
        status = "enabled" if is_fullscreen else "disabled"
        self._safe_status_update(self.lang_manager.get(f"fullscreen_{status}", f"Fullscreen {status}"), "info")

    @safe_operation
    def _on_performance_mode_changed(self, is_enabled: bool):
        """معالج تغيير وضع الأداء العالي"""
        status_key = "performance_mode_enabled" if is_enabled else "performance_mode_disabled"
        self._safe_status_update(self.lang_manager.get(status_key, f"Performance mode {'enabled' if is_enabled else 'disabled'}"), "info")

        if hasattr(self.data_table, 'tree') and self.data_table.tree:
            height = 20 if is_enabled else 15
            self.data_table.tree.configure(height=height)

    @error_handler
    def _show_statistics(self):
        """عرض الإحصائيات"""
        stats_msg = f"""
{self.lang_manager.get("statistics", "Statistics")}:

{self.lang_manager.get("total_records", "Total Records")}: {len(self.all_records)}
{self.lang_manager.get("today_bookings", "Today's Bookings")}: {self._count_records('today')}
{self.lang_manager.get("pending_bookings", "Pending Bookings")}: {self._count_records('pending')}
"""
        messagebox.showinfo(self.lang_manager.get("statistics", "Statistics"), stats_msg)

    @error_handler
    def _show_reports(self):
        """عرض التقارير"""
        self._safe_status_update(self.lang_manager.get("reports_coming_soon", "Reports feature coming soon"), "info")
        messagebox.showinfo(self.lang_manager.get("info", "Information"),
                          self.lang_manager.get("reports_coming_soon", "Reports feature coming soon"))

    @error_handler
    def _clear_cache(self):
        """مسح الذاكرة المؤقتة"""
        if messagebox.askyesno(self.lang_manager.get("confirm", "Confirm"),
                             self.lang_manager.get("confirm_clear_cache", "Clear all cached data?")):
            self._safe_status_update(self.lang_manager.get("cache_cleared", "Cache cleared successfully"), "success")

    @error_handler
    def _show_help(self):
        """عرض المساعدة"""
        help_text = f"""
{self.lang_manager.get("keyboard_shortcuts", "Keyboard Shortcuts")}:

- Ctrl+N - {self.lang_manager.get("add_button", "Add Booking")}
- Ctrl+E - {self.lang_manager.get("edit_button", "Edit Booking")}
- Delete - {self.lang_manager.get("delete_button", "Delete Booking")}
- F5 - {self.lang_manager.get("refresh", "Refresh")}
- Ctrl+F - {self.lang_manager.get("search", "Search")}
- Ctrl+A - {self.lang_manager.get("select_all", "Select All")}
- Escape - {self.lang_manager.get("exit_fullscreen", "Exit Fullscreen")}
- F11 - {self.lang_manager.get("fullscreen", "Toggle Fullscreen")}
- F1 - {self.lang_manager.get("help", "Help")}
"""
        messagebox.showinfo(self.lang_manager.get("keyboard_shortcuts", "Keyboard Shortcuts"), help_text)

    @error_handler
    def _show_user_guide(self):
        """عرض دليل المستخدم"""
        guide_msg = f"""
{self.lang_manager.get("user_guide", "User Guide")}:

1. {self.lang_manager.get("guide_add", "To add a booking: Click Add button or press Ctrl+N")}
2. {self.lang_manager.get("guide_edit", "To edit: Double-click on a booking or press Ctrl+E")}
3. {self.lang_manager.get("guide_delete", "To delete: Select bookings and press Delete")}
4. {self.lang_manager.get("guide_search", "To search: Use the search box or press Ctrl+F")}
5. {self.lang_manager.get("guide_fullscreen", "To toggle fullscreen: Press F11 or Alt+Enter")}
"""
        messagebox.showinfo(self.lang_manager.get("user_guide", "User Guide"), guide_msg)

    @error_handler
    def _show_about(self):
        """عرض معلومات البرنامج"""
        about_msg = f"""
{self.lang_manager.get("app_name", "FTS Sales Manager")}
{self.lang_manager.get("version", "Version")}: 2.0

{self.lang_manager.get("developed_by", "Developed by")}: FTS Development Team
{self.lang_manager.get("copyright", "© 2024 FTS. All rights reserved.")}

{self.lang_manager.get("logged_as", "Logged in as")}: {self.user_record.get('fields', {}).get('Username', 'User')}
{self.lang_manager.get("user_role", "Role")}: {self.user_record.get('fields', {}).get('Role', 'User')}
"""
        messagebox.showinfo(self.lang_manager.get("about", "About"), about_msg)

    # ==================== معالجات الأحداث الجديدة ====================

    def _on_data_loaded_event(self, data):
        """معالج حدث تحميل البيانات"""
        logger.info(f"Data loaded event: {data}")

    def _on_search_completed_event(self, data):
        """معالج حدث اكتمال البحث"""
        logger.info(f"Search completed: {data}")

    def _on_error_event(self, data):
        """معالج حدث الخطأ"""
        logger.error(f"Error event: {data}")

    # ==================== حفظ واستعادة حالة النافذة ====================

    def _save_window_state(self):
        """حفظ حالة النافذة"""
        try:
            window_state = {
                'fullscreen': self._is_fullscreen,
                'geometry': self.geometry() if not self._is_fullscreen else None,
                'state': self.state() if hasattr(self, 'state') else None
            }

            if hasattr(self.controller, 'config_mgr'):
                self.controller.config_mgr.set('main_window_state', window_state)
                logger.debug("Window state saved")
        except Exception as e:
            logger.error(f"Save window state error: {e}")

    def _restore_window_state(self):
        """استعادة حالة النافذة"""
        try:
            if hasattr(self.controller, 'config_mgr'):
                window_state = self.controller.config_mgr.get('main_window_state', {})

                if window_state.get('fullscreen', True):
                    self.safe_after.schedule(200, self._apply_fullscreen_mode)
                elif window_state.get('geometry'):
                    self.geometry(window_state['geometry'])
                else:
                    self.safe_after.schedule(200, self._apply_fullscreen_mode)
        except Exception as e:
            logger.error(f"Restore window state error: {e}")
            self.safe_after.schedule(200, self._apply_fullscreen_mode)

    # ==================== معالج الإغلاق ====================

    def _on_close(self):
        """معالج إغلاق النافذة"""
        if self._closing:
            return

        try:
            if messagebox.askyesno(self.lang_manager.get("confirm", "Confirm"),
                                 self.lang_manager.get("confirm_exit", "Are you sure you want to exit?")):
                self._closing = True
                self._window_destroyed = True

                # حفظ الحالة وتنظيف الموارد
                self._save_window_state()

                if hasattr(self, 'safe_after'):
                    self.safe_after.cancel_all()

                if hasattr(self, 'async_manager') and self.async_manager:
                    try:
                        self.async_manager.shutdown()
                    except:
                        pass

                # إغلاق النوافذ الفرعية
                if hasattr(self.controller, 'open_edit_windows'):
                    for window in list(self.controller.open_edit_windows):
                        try:
                            if hasattr(window, 'winfo_exists') and window.winfo_exists():
                                window.destroy()
                        except:
                            pass
                    try:
                        self.controller.open_edit_windows.clear()
                    except:
                        pass

                # تنظيف المتحكم
                if hasattr(self.controller, 'cleanup'):
                    try:
                        self.controller.cleanup()
                    except:
                        pass

                # إغلاق النافذة
                try:
                    self.quit()
                    self.destroy()
                except:
                    try:
                        self.withdraw()
                    except:
                        pass
        except Exception as e:
            logger.error(f"Close error: {e}")
            self._closing = True
            self._window_destroyed = True
            try:
                self.destroy()
            except:
                pass

============================================================
FILE: views\splash_screen.py
SIZE: 11100 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/splash_screen.py

شاشة ترحيب محسنة مع:
- شعار متحرك
- شريط تقدم
- معلومات الإصدار
- رسائل تحميل ديناميكية
"""

import tkinter as tk
import customtkinter as ctk
from typing import Optional, Callable
import threading
import time
from PIL import Image, ImageTk
import os


class SplashScreen(ctk.CTkToplevel):
    """
    شاشة ترحيب محسنة مع تأثيرات بصرية وتحميل ديناميكي
    """

    def __init__(self,
                 duration: int = 3000,
                 app_name: str = "FTS Sales Manager",
                 version: str = "2.0",
                 logo_path: Optional[str] = None,
                 loading_callback: Optional[Callable[['SplashScreen'], None]] = None,
                 master: Optional[tk.Tk] = None) -> None:
        """
        تهيئة شاشة الترحيب المحسنة

        :param duration: مدة العرض بالمللي ثانية
        :param app_name: اسم التطبيق
        :param version: رقم الإصدار
        :param logo_path: مسار الشعار (اختياري)
        :param loading_callback: دالة للتحميل في الخلفية
        :param master: النافذة الأساسية (لتجنب إنشاء نافذة tk إضافية)
        """
        # إنشاء نافذة أساسية مخفية إذا لم تُمرر
        if master is None:
            self._temp_root = tk.Tk()
            self._temp_root.withdraw()
            super().__init__(self._temp_root)
        else:
            self._temp_root = None
            super().__init__(master)

        self.app_name = app_name
        self.version = version
        self.logo_path = logo_path
        self.loading_callback = loading_callback
        self._loading_complete = False
        self._min_display_time = 1500  # عرض لمدة 1.5 ثانية على الأقل

        # إعدادات النافذة
        self.overrideredirect(True)  # إزالة إطار النافذة
        self.attributes("-topmost", True)  # فوق جميع النوافذ

        # جعل النافذة شفافة قليلاً (Windows/Linux)
        try:
            self.attributes("-alpha", 0.95)
        except:
            pass

        # تطبيق الثيم
        ctk.set_appearance_mode("dark")
        ctk.set_default_color_theme("blue")

        # بناء المحتوى
        self._build_ui()

        # توسيط النافذة
        self._center_window()

        # بدء التحريك
        self._start_animations()

        # جدولة الإغلاق
        if loading_callback:
            # بدء التحميل في الخلفية
            self._start_background_loading()
        else:
            # إغلاق بعد المدة المحددة
            self.after(duration, self._close_splash)

    def _build_ui(self) -> None:
        """بناء محتوى شاشة الترحيب"""
        # الإطار الرئيسي مع خلفية متدرجة
        self.main_frame = ctk.CTkFrame(
            self,
            fg_color=("#1a1a1a", "#1a1a1a"),
            corner_radius=20,
            border_width=2,
            border_color=("#3498db", "#2980b9")
        )
        self.main_frame.pack(expand=True, fill="both", padx=2, pady=2)

        # إطار المحتوى
        content_frame = ctk.CTkFrame(
            self.main_frame,
            fg_color="transparent"
        )
        content_frame.pack(expand=True, fill="both", padx=40, pady=40)

        # الشعار أو الأيقونة
        if self.logo_path and os.path.exists(self.logo_path):
            try:
                # تحميل الصورة
                logo_image = Image.open(self.logo_path)
                logo_image = logo_image.resize((120, 120), Image.Resampling.LANCZOS)
                self.logo_photo = ctk.CTkImage(
                    light_image=logo_image,
                    dark_image=logo_image,
                    size=(120, 120)
                )
                logo_label = ctk.CTkLabel(
                    content_frame,
                    image=self.logo_photo,
                    text=""
                )
                logo_label.pack(pady=(0, 20))
            except:
                # عرض أيقونة نصية في حالة فشل تحميل الصورة
                self._create_text_logo(content_frame)
        else:
            # أيقونة نصية افتراضية
            self._create_text_logo(content_frame)

        # اسم التطبيق
        self.app_label = ctk.CTkLabel(
            content_frame,
            text=self.app_name,
            font=ctk.CTkFont(size=32, weight="bold"),
            text_color=("#ffffff", "#ffffff")
        )
        self.app_label.pack(pady=(0, 10))

        # الإصدار
        version_label = ctk.CTkLabel(
            content_frame,
            text=f"Version {self.version}",
            font=ctk.CTkFont(size=14),
            text_color=("#cccccc", "#cccccc")
        )
        version_label.pack()

        # شريط التقدم
        self.progress_frame = ctk.CTkFrame(
            content_frame,
            fg_color="transparent"
        )
        self.progress_frame.pack(fill="x", pady=(30, 10))

        self.progress_bar = ctk.CTkProgressBar(
            self.progress_frame,
            width=300,
            height=6,
            corner_radius=3,
            fg_color=("#333333", "#333333"),
            progress_color=("#3498db", "#2980b9")
        )
        self.progress_bar.pack()
        self.progress_bar.set(0)

        # نص التحميل
        self.loading_label = ctk.CTkLabel(
            content_frame,
            text="Initializing...",
            font=ctk.CTkFont(size=12),
            text_color=("#aaaaaa", "#aaaaaa")
        )
        self.loading_label.pack()

        # حقوق النشر
        copyright_label = ctk.CTkLabel(
            content_frame,
            text="© 2024 FTS - All Rights Reserved",
            font=ctk.CTkFont(size=10),
            text_color=("#666666", "#666666")
        )
        copyright_label.pack(side="bottom", pady=(20, 0))

    def _create_text_logo(self, parent):
        """إنشاء شعار نصي"""
        logo_frame = ctk.CTkFrame(
            parent,
            fg_color=("#3498db", "#2980b9"),
            corner_radius=60,
            width=120,
            height=120
        )
        logo_frame.pack(pady=(0, 20))
        logo_frame.pack_propagate(False)

        logo_text = ctk.CTkLabel(
            logo_frame,
            text="FTS",
            font=ctk.CTkFont(size=48, weight="bold"),
            text_color=("#ffffff", "#ffffff")
        )
        logo_text.place(relx=0.5, rely=0.5, anchor="center")

    def _center_window(self):
        """توسيط النافذة على الشاشة"""
        # تحديد الحجم
        window_width = 400
        window_height = 500

        # الحصول على أبعاد الشاشة
        screen_width = self.winfo_screenwidth()
        screen_height = self.winfo_screenheight()

        # حساب الموضع
        x = (screen_width - window_width) // 2
        y = (screen_height - window_height) // 2

        # تطبيق الحجم والموضع
        self.geometry(f"{window_width}x{window_height}+{x}+{y}")

    def _start_animations(self):
        """بدء التحريكات"""
        # تأثير fade in
        self._fade_in()

        # تحريك شريط التقدم
        self._animate_progress()

        # تحديث نص التحميل
        self._update_loading_text()

    def _fade_in(self):
        """تأثير الظهور التدريجي"""
        alpha = 0.0

        def update_alpha():
            nonlocal alpha
            if alpha < 0.95:
                alpha += 0.05
                try:
                    self.attributes("-alpha", alpha)
                except:
                    pass
                self.after(20, update_alpha)

        try:
            self.attributes("-alpha", 0.0)
            self.after(10, update_alpha)
        except:
            # في حالة عدم دعم الشفافية
            pass

    def _animate_progress(self):
        """تحريك شريط التقدم"""
        self.progress_value = 0.0

        def update_progress():
            if self.progress_value < 1.0:
                # زيادة بطيئة في البداية، سريعة في النهاية
                if self.progress_value < 0.8:
                    increment = 0.01
                else:
                    increment = 0.02

                self.progress_value += increment
                self.progress_bar.set(min(self.progress_value, 1.0))

                # تحديث كل 50ms
                self.after(50, update_progress)
            elif self._loading_complete:
                # اكتمل التحميل
                self._close_splash()

        update_progress()

    def _update_loading_text(self):
        """تحديث نص التحميل بشكل دوري"""
        messages = [
            "Initializing...",
            "Loading configuration...",
            "Connecting to database...",
            "Loading user data...",
            "Preparing interface...",
            "Almost ready..."
        ]

        index = 0

        def update_text():
            nonlocal index
            if not self._loading_complete:
                self.loading_label.configure(text=messages[index % len(messages)])
                index += 1

                # تحديث كل 500ms
                self.after(500, update_text)

        update_text()

    def _start_background_loading(self):
        """بدء التحميل في الخلفية"""
        start_time = time.time()

        def loading_thread():
            try:
                # استدعاء دالة التحميل
                if self.loading_callback:
                    self.loading_callback(self)
            except Exception as e:
                print(f"Error during loading: {e}")
            finally:
                # التأكد من عرض الشاشة للحد الأدنى من الوقت
                elapsed = (time.time() - start_time) * 1000
                if elapsed < self._min_display_time:
                    time.sleep((self._min_display_time - elapsed) / 1000)

                self._loading_complete = True

        thread = threading.Thread(target=loading_thread, daemon=True)
        thread.start()

    def _close_splash(self):
        """إغلاق شاشة الترحيب مع تأثير fade out"""
        def fade_out(alpha=0.95):
            if alpha > 0.0:
                alpha -= 0.05
                try:
                    self.attributes("-alpha", alpha)
                except:
                    pass
                self.after(20, lambda: fade_out(alpha))
            else:
                # تنظيف النافذة المؤقتة إذا كانت موجودة
                if self._temp_root:
                    self._temp_root.destroy()
                self.destroy()

        # بدء fade out
        fade_out()

    def update_progress(self, value: float, message: str = ""):
        """
        تحديث التقدم يدوياً

        :param value: قيمة التقدم (0.0 - 1.0)
        :param message: رسالة التحميل
        """
        self.progress_value = value
        self.progress_bar.set(value)

        if message:
            self.loading_label.configure(text=message)

    def set_loading_complete(self):
        """وضع علامة اكتمال التحميل"""
        self._loading_complete = True
        self.update_progress(1.0, "Ready!")

        # إغلاق بعد تأخير قصير
        self.after(500, self._close_splash)

============================================================
FILE: views\components\autocomplete_entry.py
SIZE: 19262 characters
============================================================

# -*- coding: utf-8 -*-
"""
components/enhanced_autocomplete_entry.py - النسخة المحسنة والمثبتة

إصلاح جميع المشاكل:
✅ إدارة محسنة للنوافذ المنبثقة
✅ معالجة أحداث مستقرة
✅ بحث مرن فعال
✅ أداء محسن
✅ سهولة الاستخدام
"""

import customtkinter as ctk
import tkinter as tk
from typing import List, Callable, Optional, Any, Union
import threading
import time
from dataclasses import dataclass
from enum import Enum


class SuggestionType(Enum):
    EXACT = "exact"
    STARTS_WITH = "starts"
    CONTAINS = "contains"
    FUZZY = "fuzzy"


@dataclass
class Suggestion:
    text: str
    type: SuggestionType = SuggestionType.EXACT
    score: float = 1.0
    description: str = ""


class EnhancedAutoCompleteEntry(ctk.CTkFrame):
    """حقل إدخال مع إكمال تلقائي محسن ومثبت"""

    def __init__(self,
                 parent,
                 values: List[str] = None,
                 placeholder: str = "ابحث...",
                 width: int = 300,
                 height: int = 35,
                 max_suggestions: int = 8,
                 min_chars: int = 1,
                 enable_fuzzy: bool = True,
                 fuzzy_threshold: float = 0.6,
                 on_select: Callable[[str], None] = None,
                 **kwargs):

        super().__init__(parent, width=width, height=height, **kwargs)

        # الإعدادات
        self.values = values or []
        self.placeholder = placeholder
        self.max_suggestions = max_suggestions
        self.min_chars = min_chars
        self.enable_fuzzy = enable_fuzzy
        self.fuzzy_threshold = fuzzy_threshold
        self.on_select = on_select

        # الحالة
        self.suggestions: List[Suggestion] = []
        self.selected_index = -1
        self.is_popup_open = False
        self.current_value = ""

        # متغيرات واجهة المستخدم
        self.text_var = tk.StringVar()
        self.text_var.trace_add('write', self._on_text_change)

        # بناء الواجهة
        self._build_ui()
        self._setup_bindings()

        # النافذة المنبثقة
        self.popup_window = None
        self.suggestion_widgets = []

        # تخزين مؤقت للبحث
        self._search_cache = {}
        self._last_search_time = 0
        self._search_delay = 0.3  # ثانية

    def _build_ui(self):
        """بناء واجهة المستخدم البسيطة"""
        # إطار البحث
        self.search_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.search_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # أيقونة البحث
        self.search_icon = ctk.CTkLabel(
            self.search_frame,
            text="🔍",
            width=25,
            font=ctk.CTkFont(size=14)
        )
        self.search_icon.pack(side="left", padx=(5, 0))

        # حقل النص
        self.entry = ctk.CTkEntry(
            self.search_frame,
            textvariable=self.text_var,
            placeholder_text=self.placeholder,
            height=self.cget("height") - 4
        )
        self.entry.pack(side="left", fill="both", expand=True, padx=5)

        # زر المسح
        self.clear_btn = ctk.CTkButton(
            self.search_frame,
            text="✕",
            width=25,
            height=25,
            command=self.clear,
            font=ctk.CTkFont(size=10)
        )
        # إخفاء زر المسح بداية

    def _setup_bindings(self):
        """إعداد أحداث لوحة المفاتيح والماوس"""
        # أحداث لوحة المفاتيح
        self.entry.bind('<Down>', self._on_arrow_down)
        self.entry.bind('<Up>', self._on_arrow_up)
        self.entry.bind('<Return>', self._on_enter)
        self.entry.bind('<Escape>', self._on_escape)
        self.entry.bind('<Tab>', self._on_tab)

        # أحداث التركيز
        self.entry.bind('<FocusIn>', self._on_focus_in)
        self.entry.bind('<FocusOut>', self._on_focus_out)

        # أحداث النقر
        self.entry.bind('<Button-1>', self._on_click)

    def _on_text_change(self, *args):
        """معالج تغيير النص المحسن"""
        text = self.text_var.get()
        self.current_value = text

        # إظهار/إخفاء زر المسح
        if text:
            self.clear_btn.pack(side="right", padx=(0, 5))
        else:
            self.clear_btn.pack_forget()

        # تحديث وقت البحث
        self._last_search_time = time.time()

        # جدولة البحث بتأخير
        if hasattr(self, '_search_timer'):
            self.after_cancel(self._search_timer)

        self._search_timer = self.after(
            int(self._search_delay * 1000),
            self._perform_search
        )

    def _perform_search(self):
        """تنفيذ البحث"""
        text = self.current_value.strip()

        if len(text) < self.min_chars:
            self._close_popup()
            return

        # استخدام التخزين المؤقت
        if text in self._search_cache:
            suggestions = self._search_cache[text]
        else:
            suggestions = self._generate_suggestions(text)
            # حفظ في التخزين المؤقت (مع حد أقصى)
            if len(self._search_cache) < 50:
                self._search_cache[text] = suggestions

        self.suggestions = suggestions

        if suggestions:
            self._show_popup()
        else:
            self._close_popup()

    def _generate_suggestions(self, query: str) -> List[Suggestion]:
        """إنشاء قائمة الاقتراحات"""
        suggestions = []
        query_lower = query.lower()

        for value in self.values:
            value_lower = value.lower()

            # تطابق تام
            if query_lower == value_lower:
                suggestions.append(Suggestion(
                    text=value,
                    type=SuggestionType.EXACT,
                    score=1.0
                ))
            # يبدأ بالاستعلام
            elif value_lower.startswith(query_lower):
                suggestions.append(Suggestion(
                    text=value,
                    type=SuggestionType.STARTS_WITH,
                    score=0.9
                ))
            # يحتوي على الاستعلام
            elif query_lower in value_lower:
                suggestions.append(Suggestion(
                    text=value,
                    type=SuggestionType.CONTAINS,
                    score=0.7
                ))
            # بحث مرن
            elif self.enable_fuzzy:
                similarity = self._calculate_similarity(query_lower, value_lower)
                if similarity >= self.fuzzy_threshold:
                    suggestions.append(Suggestion(
                        text=value,
                        type=SuggestionType.FUZZY,
                        score=similarity * 0.6
                    ))

        # ترتيب حسب النقاط
        suggestions.sort(key=lambda s: -s.score)
        return suggestions[:self.max_suggestions]

    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """حساب التشابه بين نصين (بخوارزمية بسيطة)"""
        if not text1 or not text2:
            return 0.0

        # حساب الأحرف المشتركة
        common = sum(1 for c in text1 if c in text2)
        max_len = max(len(text1), len(text2))

        return common / max_len if max_len > 0 else 0.0

    def _show_popup(self):
        """عرض النافذة المنبثقة"""
        if self.is_popup_open:
            self._update_popup()
            return

        try:
            # إنشاء النافذة المنبثقة
            self._create_popup()
            self.is_popup_open = True

        except Exception as e:
            print(f"خطأ في عرض النافذة المنبثقة: {e}")

    def _create_popup(self):
        """إنشاء النافذة المنبثقة"""
        # تدمير النافذة القديمة إن وجدت
        if self.popup_window:
            try:
                self.popup_window.destroy()
            except:
                pass

        # حساب الموقع
        x = self.winfo_rootx()
        y = self.winfo_rooty() + self.winfo_height()
        width = self.winfo_width()
        height = min(250, len(self.suggestions) * 35 + 10)

        # إنشاء النافذة
        self.popup_window = ctk.CTkToplevel(self)
        self.popup_window.wm_overrideredirect(True)
        self.popup_window.geometry(f"{width}x{height}+{x}+{y}")

        # إطار التمرير
        self.scroll_frame = ctk.CTkScrollableFrame(
            self.popup_window,
            width=width-10,
            height=height-10
        )
        self.scroll_frame.pack(fill="both", expand=True, padx=5, pady=5)

        self._populate_suggestions()

    def _populate_suggestions(self):
        """ملء الاقتراحات"""
        # مسح الاقتراحات السابقة
        for widget in self.suggestion_widgets:
            try:
                widget.destroy()
            except:
                pass

        self.suggestion_widgets.clear()

        # إضافة الاقتراحات الجديدة
        for i, suggestion in enumerate(self.suggestions):
            btn = ctk.CTkButton(
                self.scroll_frame,
                text=suggestion.text,
                height=30,
                anchor="w",
                command=lambda s=suggestion: self._select_suggestion(s)
            )
            btn.pack(fill="x", pady=1)

            # ربط أحداث الماوس
            btn.bind('<Enter>', lambda e, idx=i: self._highlight_suggestion(idx))

            self.suggestion_widgets.append(btn)

    def _update_popup(self):
        """تحديث محتوى النافذة المنبثقة"""
        if self.popup_window and self.popup_window.winfo_exists():
            self._populate_suggestions()

    def _close_popup(self):
        """إغلاق النافذة المنبثقة"""
        if self.popup_window:
            try:
                self.popup_window.destroy()
            except:
                pass
            finally:
                self.popup_window = None

        self.is_popup_open = False
        self.selected_index = -1

    def _select_suggestion(self, suggestion: Suggestion):
        """اختيار اقتراح"""
        self.text_var.set(suggestion.text)
        self.current_value = suggestion.text
        self._close_popup()

        # استدعاء callback
        if self.on_select:
            try:
                self.on_select(suggestion.text)
            except Exception as e:
                print(f"خطأ في callback: {e}")

    def _highlight_suggestion(self, index: int):
        """تمييز اقتراح"""
        self.selected_index = index

        # إزالة التمييز من جميع الأزرار
        for btn in self.suggestion_widgets:
            btn.configure(fg_color=["gray75", "gray25"])

        # تمييز الزر المحدد
        if 0 <= index < len(self.suggestion_widgets):
            self.suggestion_widgets[index].configure(fg_color=["gray65", "gray35"])

    # معالجات الأحداث
    def _on_arrow_down(self, event):
        """السهم لأسفل"""
        if not self.is_popup_open or not self.suggestions:
            return

        if self.selected_index < len(self.suggestions) - 1:
            self.selected_index += 1
        else:
            self.selected_index = 0

        self._highlight_suggestion(self.selected_index)
        return "break"

    def _on_arrow_up(self, event):
        """السهم لأعلى"""
        if not self.is_popup_open or not self.suggestions:
            return

        if self.selected_index > 0:
            self.selected_index -= 1
        else:
            self.selected_index = len(self.suggestions) - 1

        self._highlight_suggestion(self.selected_index)
        return "break"

    def _on_enter(self, event):
        """مفتاح Enter"""
        if self.is_popup_open and 0 <= self.selected_index < len(self.suggestions):
            self._select_suggestion(self.suggestions[self.selected_index])
        return "break"

    def _on_escape(self, event):
        """مفتاح Escape"""
        if self.is_popup_open:
            self._close_popup()
        else:
            self.clear()
        return "break"

    def _on_tab(self, event):
        """مفتاح Tab"""
        if self.is_popup_open and 0 <= self.selected_index < len(self.suggestions):
            self._select_suggestion(self.suggestions[self.selected_index])
            return "break"

    def _on_focus_in(self, event):
        """التركيز على الحقل"""
        if self.current_value and len(self.current_value) >= self.min_chars:
            self._perform_search()

    def _on_focus_out(self, event):
        """فقدان التركيز"""
        # تأخير قصير لإتاحة النقر على الاقتراحات
        self.after(100, self._check_focus_out)

    def _check_focus_out(self):
        """فحص فقدان التركيز الفعلي"""
        try:
            focused = self.focus_get()
            if not focused or focused not in [self.entry] + self.suggestion_widgets:
                self._close_popup()
        except:
            self._close_popup()

    def _on_click(self, event):
        """النقر على حقل النص"""
        if self.current_value and len(self.current_value) >= self.min_chars:
            self._perform_search()

    # الواجهة العامة
    def get(self) -> str:
        """الحصول على القيمة"""
        return self.current_value

    def set(self, value: str):
        """تعيين قيمة"""
        self.text_var.set(value)
        self.current_value = value

    def clear(self):
        """مسح المحتوى"""
        self.text_var.set("")
        self.current_value = ""
        self._close_popup()

    def set_values(self, values: List[str]):
        """تحديث قائمة القيم"""
        self.values = values
        self._search_cache.clear()  # مسح التخزين المؤقت

    def add_value(self, value: str):
        """إضافة قيمة جديدة"""
        if value and value not in self.values:
            self.values.append(value)
            self._search_cache.clear()

    def focus_set(self):
        """التركيز على الحقل"""
        self.entry.focus_set()


# مثال للاختبار
if __name__ == "__main__":
    import customtkinter as ctk

    class TestApp:
        def __init__(self):
            ctk.set_appearance_mode("dark")
            ctk.set_default_color_theme("blue")

            self.root = ctk.CTk()
            self.root.title("Enhanced AutoComplete Entry - Test")
            self.root.geometry("600x400")

            # بيانات تجريبية
            self.test_values = [
                "القاهرة", "الإسكندرية", "الجيزة", "شرم الشيخ", "الغردقة",
                "أسوان", "الأقصر", "مرسى مطروح", "طابا", "دهب",
                "Cairo", "Alexandria", "Giza", "Sharm El Sheikh", "Hurghada",
                "Aswan", "Luxor", "Marsa Matrouh", "Taba", "Dahab",
                "New York", "Los Angeles", "Chicago", "Houston",
                "London", "Paris", "Berlin", "Rome", "Madrid"
            ]

            self.setup_ui()

        def setup_ui(self):
            """إعداد واجهة الاختبار"""
            # العنوان
            title = ctk.CTkLabel(
                self.root,
                text="🔍 Enhanced AutoComplete Entry",
                font=ctk.CTkFont(size=24, weight="bold")
            )
            title.pack(pady=20)

            # وصف التحسينات
            improvements = """
✅ أداء محسن ومستقر
✅ بحث مرن فعال
✅ واجهة مستخدم سلسة
✅ معالجة أحداث محسنة
✅ تخزين مؤقت ذكي
            """

            desc_label = ctk.CTkLabel(
                self.root,
                text=improvements,
                font=ctk.CTkFont(size=12),
                justify="left"
            )
            desc_label.pack(pady=10)

            # حقل الاختبار الأول - بحث عادي
            label1 = ctk.CTkLabel(
                self.root,
                text="🌍 بحث المدن (بحث عادي):",
                font=ctk.CTkFont(size=14, weight="bold")
            )
            label1.pack(pady=(20, 5))

            self.autocomplete1 = EnhancedAutoCompleteEntry(
                self.root,
                values=self.test_values,
                placeholder="ابحث عن مدينة...",
                width=500,
                enable_fuzzy=False,
                on_select=self.on_select1
            )
            self.autocomplete1.pack(pady=5)

            # حقل الاختبار الثاني - بحث مرن
            label2 = ctk.CTkLabel(
                self.root,
                text="🔍 بحث مرن (جرب: Cair أو قاهر):",
                font=ctk.CTkFont(size=14, weight="bold")
            )
            label2.pack(pady=(20, 5))

            self.autocomplete2 = EnhancedAutoCompleteEntry(
                self.root,
                values=self.test_values,
                placeholder="البحث المرن...",
                width=500,
                enable_fuzzy=True,
                fuzzy_threshold=0.5,
                on_select=self.on_select2
            )
            self.autocomplete2.pack(pady=5)

            # عرض النتائج
            self.result_label = ctk.CTkLabel(
                self.root,
                text="🎯 لم يتم الاختيار بعد",
                font=ctk.CTkFont(size=16)
            )
            self.result_label.pack(pady=20)

            # أزرار التحكم
            controls_frame = ctk.CTkFrame(self.root)
            controls_frame.pack(pady=20)

            clear_btn = ctk.CTkButton(
                controls_frame,
                text="🗑️ مسح الكل",
                command=self.clear_all,
                width=120
            )
            clear_btn.pack(side="left", padx=5)

            add_btn = ctk.CTkButton(
                controls_frame,
                text="➕ إضافة عنصر",
                command=self.add_item,
                width=120
            )
            add_btn.pack(side="left", padx=5)

        def on_select1(self, value):
            """معالج الاختيار الأول"""
            self.result_label.configure(
                text=f"🌍 اختيار عادي: {value}",
                text_color="green"
            )

        def on_select2(self, value):
            """معالج الاختيار المرن"""
            self.result_label.configure(
                text=f"🔍 اختيار مرن: {value}",
                text_color="blue"
            )

        def clear_all(self):
            """مسح جميع الحقول"""
            self.autocomplete1.clear()
            self.autocomplete2.clear()
            self.result_label.configure(
                text="🗑️ تم مسح جميع الحقول",
                text_color="orange"
            )

        def add_item(self):
            """إضافة عنصر جديد"""
            import random
            new_items = ["طوكيو", "سيدني", "تورونتو", "دبي", "الكويت"]
            new_item = random.choice(new_items)

            self.autocomplete1.add_value(new_item)
            self.autocomplete2.add_value(new_item)

            self.result_label.configure(
                text=f"➕ تم إضافة: {new_item}",
                text_color="purple"
            )

        def run(self):
            """تشغيل التطبيق"""
            self.root.mainloop()

    # تشغيل الاختبار
    app = TestApp()
    app.run()


============================================================
FILE: views\components\combobox.py
SIZE: 70009 characters
============================================================

# -*- coding: utf-8 -*-
"""
enhanced_combobox.py - نسخة محسنة ومبسطة موحدة مع تتبع النافذة - مع إصلاح مشكلة تخطي الأسهم

قائمة منسدلة محسنة مع:
- آلية نقر محسنة (النقر الأول للتركيز، الثاني لفتح القائمة)
- بحث فوري مع ألوان زرقاء للتمرير
- كود مبسط ومنظم
- دمج جميع الميزات في مكون واحد
- تتبع النافذة وتحديث موقع القائمة تلقائياً
- عرض القائمة أسفل أو أعلى حسب المساحة المتاحة
- فلترة حية مع أسهم تعمل بشكل مثالي (مُصلحة - لا تخطي)
"""

import customtkinter as ctk
import tkinter as tk
from typing import List, Callable, Optional
import time


class EnhancedSearchableComboBox(ctk.CTkFrame):
    """قائمة منسدلة محسنة موحدة مع جميع الميزات وتتبع النافذة - مع إصلاح الأسهم"""

    def __init__(self, parent, values: List[str] = None, placeholder: str = "اكتب للبحث...",
                 width: int = 300, height: int = 35, max_results: int = 10,
                 on_select: Callable[[str], None] = None, debug_mode: bool = False, **kwargs):

        super().__init__(parent, width=width, height=height, **kwargs)

        # الإعدادات الأساسية
        self.values = values or []
        self.placeholder = placeholder
        self.max_results = max_results
        self.on_select = on_select
        self.debug_mode = debug_mode

        # الحالة
        self.filtered_values = self.values.copy()
        self.selected_value = ""
        self.selected_index = -1
        self.is_dropdown_open = False

        # متغيرات التحكم في النقر
        self._last_click_time = 0
        self._has_focus = False
        self._updating_text = False
        self._closing = False

        # متغيرات تتبع النافذة
        self._last_window_x = 0
        self._last_window_y = 0
        self._last_entry_x = 0
        self._last_entry_y = 0
        self._position_check_id = None
        self._dropdown_above = False

        # متغيرات الفلترة الحية
        self._last_text = ""
        self._filter_timer = None

        # واجهة المستخدم
        self.text_var = tk.StringVar()
        self.text_var.trace_add('write', self._on_text_change)

        # النافذة المنبثقة
        self.dropdown_window = None
        self.option_buttons = []

        # بناء الواجهة
        self._build_ui()
        self._setup_events()

        if self.debug_mode:
            print(f"✅ تم إنشاء ComboBox مع {len(self.values)} عنصر")

    def _build_ui(self):
        """بناء واجهة المستخدم"""
        self.main_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.main_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # حقل الإدخال
        self.entry = ctk.CTkEntry(
            self.main_frame,
            textvariable=self.text_var,
            placeholder_text=self.placeholder,
            height=self.cget("height") - 4
        )
        self.entry.pack(side="left", fill="both", expand=True, padx=(2, 1))

        # زر القائمة
        self.dropdown_btn = ctk.CTkButton(
            self.main_frame,
            text="▼",
            width=30,
            height=self.cget("height") - 4,
            command=self._toggle_dropdown
        )
        self.dropdown_btn.pack(side="right", padx=(1, 2))

    def _setup_events(self):
        """إعداد الأحداث - مُصلح لتجنب تداخل معالجة الأسهم"""
        # أحداث النقر المحسنة
        self.entry.bind('<Button-1>', self._on_enhanced_click)
        self.entry.bind('<FocusIn>', self._on_focus_in)
        self.entry.bind('<FocusOut>', self._on_focus_out)

        # أحداث لوحة المفاتيح - معالج واحد فقط لتجنب التداخل
        self.entry.bind('<KeyRelease>', self._on_key_release_enhanced)
        self.entry.bind('<KeyPress>', self._on_key_press)

        # تم حذف binds المنفصلة للأسهم لحل مشكلة التخطي:
        # self.entry.bind('<Down>', self._on_arrow_down)      # مُزال
        # self.entry.bind('<Up>', self._on_arrow_up)          # مُزال
        # self.entry.bind('<Return>', self._on_enter)         # مُزال
        # self.entry.bind('<Escape>', self._on_escape)        # مُزال

        # اكتشاف النقر الخارجي
        self._setup_outside_click_detection()

        # تتبع تحرك النافذة
        self._start_position_tracking()

    def _on_key_press(self, event):
        """معالج الضغط على المفاتيح"""
        key = event.keysym

        if self.debug_mode:
            print(f"⌨️ مفتاح مضغوط: {key}")

        # لا نتجاهل أي مفاتيح هنا - نترك للمعالج التالي

    def _on_key_release_enhanced(self, event):
        """معالج تحرير المفاتيح المحسن - معالج واحد لجميع المفاتيح لتجنب التداخل"""
        key = event.keysym

        if self.debug_mode:
            print(f"⌨️ مفتاح محرر: {key} - القائمة مفتوحة: {self.is_dropdown_open} - الفهرس الحالي: {self.selected_index}")

        # معالجة مفاتيح التنقل أولاً - معالج وحيد لتجنب التداخل
        if key == 'Down':
            self._handle_arrow_down_enhanced()
            return "break"
        elif key == 'Up':
            self._handle_arrow_up_enhanced()
            return "break"
        elif key == 'Return':
            self._handle_enter_enhanced()
            return "break"
        elif key == 'Escape':
            self._handle_escape_enhanced()
            return "break"

        # للمفاتيح الأخرى، تنفيذ الفلترة الحية
        control_keys = ['Tab', 'Shift_L', 'Shift_R', 'Control_L', 'Control_R', 'Alt_L', 'Alt_R',
                       'Left', 'Right', 'Home', 'End', 'Page_Up', 'Page_Down']

        if key not in control_keys and not self._updating_text:
            # إلغاء التايمر السابق
            if self._filter_timer:
                self.after_cancel(self._filter_timer)

            # جدولة البحث بتأخير قصير
            self._filter_timer = self.after(50, self._perform_live_filtering)

    def _handle_arrow_down_enhanced(self):
        """معالج السهم لأسفل المحسن - مع تمرير ذكي وطبيعي ودعم التنقل الدائري"""
        if self.debug_mode:
            print(f"⬇️ سهم أسفل - مفتوحة: {self.is_dropdown_open}, أزرار: {len(self.option_buttons)}, الفهرس الحالي: {self.selected_index}")

        if not self.is_dropdown_open:
            self._open_dropdown()
            return

        if not self.option_buttons:
            if self.debug_mode:
                print("⚠️ لا توجد أزرار للتنقل بينها")
            return

        # حساب الفهرس الجديد بعناية مع دعم التنقل الدائري
        old_index = self.selected_index
        if self.selected_index == -1:
            new_index = 0
        else:
            new_index = (self.selected_index + 1) % len(self.option_buttons)

        # تحديد نوع التنقل (عادي أم دائري)
        is_circular_navigation = (old_index == len(self.option_buttons) - 1 and new_index == 0)

        # تطبيق التحديد الجديد أولاً
        self._highlight_option(new_index)

        # معالجة التمرير حسب نوع التنقل
        if is_circular_navigation:
            # تمرير للأعلى (العودة للبداية)
            self._scroll_to_top_smooth()
            if self.debug_mode:
                print(f"🔄 تنقل دائري: العودة للأول - {old_index} → {new_index}")
        else:
            # تمرير عادي
            self._scroll_to_option_smooth(new_index, direction="down")

        if self.debug_mode:
            print(f"⬇️ تحديد مؤكد: {old_index} → {new_index} (العنصر: {self.filtered_values[new_index] if new_index < len(self.filtered_values) else 'N/A'})")

    def _handle_arrow_up_enhanced(self):
        """معالج السهم لأعلى المحسن - مع تمرير ذكي وطبيعي ودعم التنقل الدائري"""
        if self.debug_mode:
            print(f"⬆️ سهم أعلى - مفتوحة: {self.is_dropdown_open}, أزرار: {len(self.option_buttons)}, الفهرس الحالي: {self.selected_index}")

        if not self.is_dropdown_open:
            return

        if not self.option_buttons:
            if self.debug_mode:
                print("⚠️ لا توجد أزرار للتنقل بينها")
            return

        # حساب الفهرس الجديد بعناية مع دعم التنقل الدائري
        old_index = self.selected_index
        if self.selected_index == -1:
            new_index = len(self.option_buttons) - 1
        else:
            new_index = (self.selected_index - 1) % len(self.option_buttons)

        # تحديد نوع التنقل (عادي أم دائري)
        is_circular_navigation = (old_index == 0 and new_index == len(self.option_buttons) - 1)

        # تطبيق التحديد الجديد أولاً
        self._highlight_option(new_index)

        # معالجة التمرير حسب نوع التنقل
        if is_circular_navigation:
            # تمرير للأسفل (الذهاب للنهاية)
            self._scroll_to_bottom_smooth()
            if self.debug_mode:
                print(f"🔄 تنقل دائري: الذهاب للآخر - {old_index} → {new_index}")
        else:
            # تمرير عادي
            self._scroll_to_option_smooth(new_index, direction="up")

        if self.debug_mode:
            print(f"⬆️ تحديد مؤكد: {old_index} → {new_index} (العنصر: {self.filtered_values[new_index] if new_index < len(self.filtered_values) else 'N/A'})")

    def _handle_enter_enhanced(self):
        """معالج مفتاح Enter المحسن"""
        if self.debug_mode:
            print(f"⏎ Enter - مفتوحة: {self.is_dropdown_open}, محدد: {self.selected_index}")

        if self.is_dropdown_open and 0 <= self.selected_index < len(self.filtered_values):
            selected_value = self.filtered_values[self.selected_index]
            if self.debug_mode:
                print(f"⏎ اختيار: {selected_value}")
            self._select_value(selected_value)

    def _handle_escape_enhanced(self):
        """معالج مفتاح Escape المحسن"""
        if self.debug_mode:
            print(f"⎋ Escape - مفتوحة: {self.is_dropdown_open}")

        if self.is_dropdown_open:
            self._close_dropdown()
        else:
            self.clear()

    def _perform_live_filtering(self):
        """تنفيذ الفلترة الحية - نسخة محسنة"""
        try:
            current_text = self.entry.get()

            # تجنب الفلترة المتكررة
            if current_text == self._last_text:
                return

            self._last_text = current_text

            if self.debug_mode:
                print(f"🔄 فلترة حية: '{current_text}' - مفتوحة: {self.is_dropdown_open}")

            # حفظ القيمة المحددة حالياً
            previously_selected_value = None
            if 0 <= self.selected_index < len(self.filtered_values):
                previously_selected_value = self.filtered_values[self.selected_index]

            # البحث والفلترة
            previous_count = len(self.filtered_values)
            self._search_values(current_text)
            current_count = len(self.filtered_values)

            # إذا كانت القائمة مفتوحة، حدثها
            if self.is_dropdown_open:
                if self.debug_mode:
                    print(f"🔄 تحديث القائمة: {previous_count} → {current_count}")

                self._update_dropdown_live()

                # إعادة تحديد العنصر أو تحديد الأول
                if previously_selected_value and previously_selected_value in self.filtered_values:
                    new_index = self.filtered_values.index(previously_selected_value)
                    self._highlight_option(new_index)
                elif self.filtered_values:
                    self._highlight_option(0)

                # تحديث حجم القائمة إذا تغير عدد العناصر
                if current_count != previous_count:
                    self._resize_dropdown_for_new_content()

            elif current_text.strip() and self._has_focus and len(self.filtered_values) > 0:
                # فتح القائمة تلقائياً إذا كان هناك نتائج
                if self.debug_mode:
                    print(f"🎯 فتح تلقائي مع {len(self.filtered_values)} نتيجة")
                self._open_dropdown_with_animation()

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في الفلترة الحية: {e}")
                import traceback
                traceback.print_exc()

    def _start_position_tracking(self):
        """بدء تتبع موقع النافذة"""
        def track_position():
            try:
                if self.is_dropdown_open and self.dropdown_window:
                    self._update_dropdown_position_if_needed()

                # جدولة التحقق التالي
                self._position_check_id = self.after(50, track_position)
            except:
                if self._position_check_id:
                    self.after_cancel(self._position_check_id)
                    self._position_check_id = None

        self._position_check_id = self.after(100, track_position)

    def _update_dropdown_position_if_needed(self):
        """تحديث موقع القائمة إذا تغير موقع النافذة أو الحقل"""
        try:
            # الحصول على موقع النافذة الحالي
            main_window = self.winfo_toplevel()
            current_window_x = main_window.winfo_x()
            current_window_y = main_window.winfo_y()

            # الحصول على موقع الحقل الحالي
            current_entry_x = self.winfo_rootx()
            current_entry_y = self.winfo_rooty()

            # التحقق من تغيير الموقع
            if (current_window_x != self._last_window_x or
                current_window_y != self._last_window_y or
                current_entry_x != self._last_entry_x or
                current_entry_y != self._last_entry_y):

                # تحديث الموقع المحفوظ
                self._last_window_x = current_window_x
                self._last_window_y = current_window_y
                self._last_entry_x = current_entry_x
                self._last_entry_y = current_entry_y

                # تحديث موقع القائمة
                self._reposition_dropdown()

                if self.debug_mode:
                    print(f"🔄 تحديث موقع القائمة: ({current_entry_x}, {current_entry_y})")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في تتبع الموقع: {e}")

    def _calculate_best_dropdown_position(self):
        """حساب أفضل موقع للقائمة (أعلى أو أسفل) مع دعم الفلترة الحية"""
        try:
            # الحصول على معلومات الشاشة
            screen_width = self.winfo_screenwidth()
            screen_height = self.winfo_screenheight()

            # موقع وحجم الحقل
            entry_x = self.winfo_rootx()
            entry_y = self.winfo_rooty()
            entry_width = self.winfo_width()
            entry_height = self.winfo_height()

            # حجم القائمة المتوقع مع مراعاة الفلترة
            dropdown_width = max(entry_width, 300)

            # حساب ارتفاع القائمة بناءً على عدد النتائج المفلترة
            items_count = len(self.filtered_values) if self.filtered_values else 1  # 1 للرسالة
            dropdown_height = min(items_count * 35 + 20, 350)  # حد أقصى 350 بكسل

            # إضافة مساحة إضافية للتمرير إذا كان هناك عدد كبير من العناصر
            if items_count > 10:
                dropdown_height = min(10 * 35 + 20, 350)

            # المساحة المتاحة أسفل وأعلى الحقل
            space_below = screen_height - (entry_y + entry_height)
            space_above = entry_y

            # تحديد الموقع الأمثل
            show_above = space_below < dropdown_height and space_above > space_below

            if show_above:
                # عرض أعلى الحقل
                final_y = entry_y - dropdown_height
                self._dropdown_above = True
            else:
                # عرض أسفل الحقل
                final_y = entry_y + entry_height
                self._dropdown_above = False

            # التأكد من عدم خروج القائمة من حدود الشاشة
            final_x = max(0, min(entry_x, screen_width - dropdown_width))
            final_y = max(0, min(final_y, screen_height - dropdown_height))

            if self.debug_mode:
                direction = "أعلى" if show_above else "أسفل"
                print(f"📍 موقع القائمة: {direction} - ({final_x}, {final_y}) - {dropdown_width}x{dropdown_height} - عناصر: {items_count}")

            return final_x, final_y, dropdown_width, dropdown_height

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في حساب الموقع: {e}")
            # قيم افتراضية في حالة الخطأ
            return self.winfo_rootx(), self.winfo_rooty() + self.winfo_height(), 300, 200

    def _reposition_dropdown(self):
        """إعادة تموضع القائمة المنسدلة"""
        if not self.dropdown_window:
            return

        try:
            x, y, width, height = self._calculate_best_dropdown_position()
            self.dropdown_window.geometry(f"{width}x{height}+{x}+{y}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في إعادة التموضع: {e}")

    def _on_enhanced_click(self, event):
        """آلية النقر المحسنة: الأول للتركيز، الثاني للقائمة"""
        current_time = time.time()
        time_since_last = current_time - self._last_click_time

        if self.debug_mode:
            print(f"🖱️ نقر - التركيز: {self._has_focus}, القائمة: {self.is_dropdown_open}")

        if not self._has_focus:
            # النقرة الأولى: التركيز وتحديد النص
            self._handle_first_click()
        elif time_since_last < 0.5:
            # النقرة الثانية: فتح/إغلاق القائمة
            self._toggle_dropdown()
        else:
            # نقرة بعد فترة: إعادة وضع المؤشر
            self._position_cursor(event)

        self._last_click_time = current_time
        return "break"

    def _handle_first_click(self):
        """معالجة النقرة الأولى"""
        self.entry.focus_set()
        self._has_focus = True

        # تحديد النص الموجود
        current_text = self.entry.get()
        if current_text:
            self.entry.select_range(0, 'end')

        if self.debug_mode:
            print(f"🎯 التركيز الأول - النص: '{current_text}'")

    def _position_cursor(self, event):
        """وضع المؤشر في موقع النقر"""
        try:
            text = self.entry.get()
            if text:
                # تقدير موقع المؤشر
                entry_width = self.entry.winfo_width()
                char_width = entry_width / max(len(text), 1)
                cursor_pos = min(len(text), max(0, int(event.x / char_width)))
                self.entry.icursor(cursor_pos)
        except:
            self.entry.icursor(tk.END)

    def _on_focus_in(self, event):
        """الحصول على التركيز"""
        self._has_focus = True
        if self.debug_mode:
            print("🎯 حصل على التركيز")

    def _on_focus_out(self, event):
        """فقدان التركيز"""
        self._has_focus = False
        if self.debug_mode:
            print("🔍 فقد التركيز")

        # تأخير قصير للتحقق من إغلاق القائمة
        self.after(50, self._check_and_close)

    def _check_and_close(self):
        """فحص وإغلاق القائمة إذا لزم الأمر"""
        if not self.is_dropdown_open or self._closing:
            return

        try:
            focused = self.focus_get()
            if not self._is_focus_inside(focused):
                self._close_dropdown()
        except:
            self._close_dropdown()

    def _is_focus_inside(self, widget):
        """فحص إذا كان التركيز داخل المكون"""
        if not widget:
            return False

        safe_widgets = [self, self.entry, self.dropdown_btn, self.main_frame]
        if self.dropdown_window:
            safe_widgets.append(self.dropdown_window)
        safe_widgets.extend(self.option_buttons)

        # فحص مباشر وهرمي محدود
        current = widget
        for _ in range(5):
            if current in safe_widgets:
                return True
            try:
                current = current.master
            except:
                break
        return False

    def _setup_outside_click_detection(self):
        """إعداد اكتشاف النقر الخارجي"""
        def check_outside():
            try:
                if self.is_dropdown_open and not self._is_focus_inside(self.focus_get()):
                    self._close_dropdown()
            except:
                pass
            self.after(100, check_outside)

        self.after(100, check_outside)

    def _toggle_dropdown(self):
        """تبديل حالة القائمة"""
        if self.is_dropdown_open:
            self._close_dropdown()
        else:
            self._open_dropdown()

    def _open_dropdown(self):
        """فتح القائمة المنسدلة - النسخة المحسنة"""
        if self.is_dropdown_open or self._closing:
            return

        try:
            # تحضير البيانات مع الفلترة
            current_text = self.entry.get().strip()
            if current_text:
                self._search_values(current_text)
            else:
                self.filtered_values = self.values.copy()

            # إنشاء النافذة حتى لو لم توجد نتائج (لعرض رسالة)
            self._create_dropdown_window()
            self.is_dropdown_open = True

            # تحديث رمز الزر حسب موقع القائمة
            self.dropdown_btn.configure(text="▲")

            # عرض المحتوى أو رسالة عدم وجود نتائج
            if not self.filtered_values and current_text:
                self._show_no_results_message()
            elif self.filtered_values:
                self._populate_dropdown()
                # تحديد العنصر الأول تلقائياً لتمكين التنقل بالأسهم
                if self.option_buttons:
                    self._highlight_option(0)
                    if self.debug_mode:
                        print(f"🎯 تحديد العنصر الأول تلقائياً: {self.filtered_values[0]}")

            if self.debug_mode:
                direction = "أعلى" if self._dropdown_above else "أسفل"
                if self.filtered_values:
                    print(f"✅ فتح القائمة {direction} مع {len(self.filtered_values)} عنصر")
                else:
                    print(f"✅ فتح القائمة {direction} - لا توجد نتائج")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في فتح القائمة: {e}")

    def _create_dropdown_window(self):
        """إنشاء نافذة القائمة المنسدلة"""
        # تنظيف سابق
        if self.dropdown_window:
            try:
                self.dropdown_window.destroy()
            except:
                pass

        self.option_buttons.clear()

        try:
            # حساب الموقع والحجم الأمثل
            x, y, width, height = self._calculate_best_dropdown_position()

            # حفظ المواقع الحالية
            self._last_window_x = self.winfo_toplevel().winfo_x()
            self._last_window_y = self.winfo_toplevel().winfo_y()
            self._last_entry_x = self.winfo_rootx()
            self._last_entry_y = self.winfo_rooty()

            # إنشاء النافذة
            main_window = self.winfo_toplevel()
            self.dropdown_window = ctk.CTkToplevel(main_window)
            self.dropdown_window.wm_overrideredirect(True)
            self.dropdown_window.geometry(f"{width}x{height}+{x}+{y}")

            # التأكد من أن النافذة تظهر فوق النافذة الرئيسية
            self.dropdown_window.lift()
            self.dropdown_window.attributes('-topmost', True)

            # إطار قابل للتمرير
            self.list_frame = ctk.CTkScrollableFrame(
                self.dropdown_window,
                width=width-10,
                height=height-10
            )
            self.list_frame.pack(fill="both", expand=True, padx=5, pady=5)

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في إنشاء النافذة: {e}")

    def _populate_dropdown(self):
        """ملء القائمة بالخيارات - محسن للعمل مع الأسهم"""
        if not self.filtered_values:
            if self.debug_mode:
                print("⚠️ لا توجد قيم لعرضها في القائمة")
            return

        if self.debug_mode:
            print(f"📋 ملء القائمة بـ {len(self.filtered_values)} عنصر")

        for i, value in enumerate(self.filtered_values):
            try:
                btn = ctk.CTkButton(
                    self.list_frame,
                    text=value,
                    height=35,
                    anchor="w",
                    fg_color="transparent",
                    text_color=("#1976D2", "#FFFFFF"),
                    hover_color=("#E3F2FD", "#1E90FF"),  # الألوان الزرقاء
                    command=lambda v=value: self._select_value(v)
                )
                btn.pack(fill="x", pady=1, padx=2)

                # أحداث التمرير بالماوس فقط (لا تتدخل مع الأسهم)
                btn.bind('<Enter>', lambda e, idx=i: self._on_mouse_enter(idx))
                btn.bind('<Leave>', lambda e, idx=i: self._on_mouse_leave(idx))

                self.option_buttons.append(btn)

                if self.debug_mode and i < 3:  # طباعة أول 3 عناصر فقط
                    print(f"  ✅ تم إنشاء زر {i}: {value}")

            except Exception as e:
                if self.debug_mode:
                    print(f"❌ خطأ في إنشاء الزر {i}: {e}")

        # فرض تحديث العرض
        try:
            self.list_frame.update_idletasks()
            if self.debug_mode:
                print(f"✅ تم ملء القائمة بنجاح: {len(self.option_buttons)} زر")
        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في تحديث العرض: {e}")

    def _select_value(self, value: str):
        """اختيار قيمة"""
        if self.debug_mode:
            print(f"🎯 اختيار: {value}")

        self._updating_text = True
        try:
            self.selected_value = value
            self.text_var.set(value)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, value)

            self._close_dropdown()
            self.entry.focus_set()

            # استدعاء callback
            if self.on_select:
                self.after(20, lambda: self.on_select(value))

        finally:
            self._updating_text = False

    def _close_dropdown(self):
        """إغلاق القائمة مع إعادة تعيين الفلترة"""
        if not self.is_dropdown_open or self._closing:
            return

        self._closing = True
        try:
            if self.dropdown_window:
                self.dropdown_window.destroy()
                self.dropdown_window = None

            self.option_buttons.clear()
            self.is_dropdown_open = False
            self.selected_index = -1
            self.dropdown_btn.configure(text="▼")
            self._dropdown_above = False

            # إعادة تعيين الفلترة للقيم الكاملة عند الإغلاق
            if not self.entry.get().strip():
                self.filtered_values = self.values.copy()

            if self.debug_mode:
                print("🔒 تم إغلاق القائمة مع إعادة تعيين الفلترة")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في الإغلاق: {e}")
        finally:
            self._closing = False

    def _search_values(self, query: str):
        """البحث في القيم مع دعم الفلترة الحية المحسنة"""
        if not query:
            self.filtered_values = self.values.copy()
            if self.debug_mode:
                print(f"🔍 مسح البحث: عودة لجميع القيم ({len(self.filtered_values)} عنصر)")
            return

        query_lower = query.lower().strip()
        if not query_lower:
            self.filtered_values = self.values.copy()
            return

        results = []
        exact_matches = []
        start_matches = []
        contains_matches = []

        # تصنيف النتائج حسب نوع التطابق لفلترة أفضل
        for value in self.values:
            value_lower = value.lower()

            if value_lower == query_lower:
                # تطابق تام
                exact_matches.append(value)
            elif value_lower.startswith(query_lower):
                # تطابق من البداية
                start_matches.append(value)
            elif query_lower in value_lower:
                # تطابق في أي مكان
                contains_matches.append(value)

        # ترتيب النتائج: التطابق التام أولاً، ثم من البداية، ثم في أي مكان
        results = exact_matches + start_matches + contains_matches
        self.filtered_values = results[:self.max_results]

        if self.debug_mode:
            total_matches = len(exact_matches) + len(start_matches) + len(contains_matches)
            print(f"🔍 بحث محسن '{query}':")
            print(f"  📊 النتائج: {len(exact_matches)} تام + {len(start_matches)} بداية + {len(contains_matches)} محتوى = {total_matches}")
            print(f"  📋 معروض: {len(self.filtered_values)} من أصل {total_matches}")
            if self.filtered_values:
                print(f"  🎯 أول 3 نتائج: {self.filtered_values[:3]}")

    def _on_text_change(self, *args):
        """معالج تغيير النص - يتكامل مع الفلترة الحية"""
        if self._updating_text:
            return

        # الفلترة الحية ستتم عبر _on_key_release_enhanced

    def _update_dropdown_live(self):
        """تحديث القائمة المنسدلة بالفلترة الحية - محسن"""
        if not self.dropdown_window or not self.list_frame:
            if self.debug_mode:
                print("❌ لا توجد نافذة قائمة لتحديثها")
            return

        try:
            if self.debug_mode:
                print(f"🔄 تحديث القائمة: {len(self.filtered_values)} عنصر")

            # مسح المحتوى السابق
            for widget in self.list_frame.winfo_children():
                widget.destroy()

            # إعادة تعيين قائمة الأزرار والفهرس
            self.option_buttons.clear()
            self.selected_index = -1  # سيتم إعادة تعيينه في _perform_live_filtering

            # عرض المحتوى الجديد
            current_text = self.entry.get().strip()

            if not self.filtered_values and current_text:
                # عرض رسالة عدم وجود نتائج
                self._show_no_results_message()
            elif not self.filtered_values and not current_text:
                # إذا تم مسح النص، أعد عرض جميع القيم
                self.filtered_values = self.values.copy()
                self._populate_dropdown()
            else:
                # عرض النتائج المفلترة
                self._populate_dropdown()

            # فرض تحديث العرض
            self.list_frame.update_idletasks()
            self.dropdown_window.update_idletasks()

            if self.debug_mode:
                print(f"✅ تم تحديث القائمة: {len(self.option_buttons)} زر معروض")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التحديث الحي: {e}")
                import traceback
                traceback.print_exc()

    def _show_no_results_message(self):
        """عرض رسالة عدم وجود نتائج"""
        if not self.dropdown_window or not self.list_frame:
            return

        try:
            if self.debug_mode:
                print("📭 عرض رسالة عدم وجود نتائج")

            # مسح المحتوى السابق
            for widget in self.list_frame.winfo_children():
                widget.destroy()

            self.option_buttons.clear()
            self.selected_index = -1

            # إضافة رسالة "لا توجد نتائج"
            no_results_frame = ctk.CTkFrame(self.list_frame, fg_color="transparent")
            no_results_frame.pack(fill="both", expand=True, pady=10, padx=10)

            no_results_label = ctk.CTkLabel(
                no_results_frame,
                text="🔍 لا توجد نتائج مطابقة",
                height=35,
                text_color=("gray", "lightgray"),
                font=ctk.CTkFont(size=12, slant="italic")
            )
            no_results_label.pack(expand=True)

            # فرض تحديث العرض
            self.list_frame.update_idletasks()
            self.dropdown_window.update_idletasks()

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في عرض رسالة عدم النتائج: {e}")

    def _resize_dropdown_for_new_content(self):
        """تغيير حجم القائمة حسب المحتوى الجديد"""
        if not self.dropdown_window:
            return

        try:
            # حساب الحجم الجديد
            x, y, width, height = self._calculate_best_dropdown_position()

            # تطبيق الحجم الجديد مع تأثير سلس
            current_geometry = self.dropdown_window.geometry()
            if f"{width}x{height}+{x}+{y}" != current_geometry:
                self.dropdown_window.geometry(f"{width}x{height}+{x}+{y}")

                # تحديث إطار القائمة
                if hasattr(self, 'list_frame'):
                    self.list_frame.configure(width=width-10, height=height-10)

                if self.debug_mode:
                    print(f"📏 تغيير حجم القائمة إلى: {width}x{height}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في تغيير الحجم: {e}")

    def _open_dropdown_with_animation(self):
        """فتح القائمة تلقائياً مع تأثير سلس"""
        if self.is_dropdown_open or self._closing:
            return

        try:
            # فتح القائمة
            self._open_dropdown()

            # إضافة تأثير ظهور سلس
            if self.dropdown_window:
                # بداية بشفافية منخفضة
                self.dropdown_window.attributes('-alpha', 0.7)

                # زيادة الشفافية تدريجياً
                def fade_in(alpha=0.7):
                    if alpha < 1.0 and self.dropdown_window:
                        try:
                            self.dropdown_window.attributes('-alpha', alpha)
                            self.after(20, lambda: fade_in(min(1.0, alpha + 0.1)))
                        except:
                            pass

                fade_in()

                if self.debug_mode:
                    print("✨ فتح القائمة تلقائياً مع تأثير")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في الفتح التلقائي: {e}")

    def _highlight_option(self, index: int):
        """تمييز خيار بالأسهم - مُصلح لضمان تحديث الفهرس بدقة"""
        if not (0 <= index < len(self.option_buttons)):
            if self.debug_mode:
                print(f"⚠️ فهرس غير صالح للتمييز: {index} (المتاح: 0-{len(self.option_buttons)-1})")
            return

        try:
            # إزالة التمييز من جميع الأزرار
            for i, btn in enumerate(self.option_buttons):
                btn.configure(fg_color="transparent")

            # تمييز الزر المحدد بالأزرق
            self.option_buttons[index].configure(fg_color=("#E3F2FD", "#1E90FF"))

            # تحديث الفهرس المحدد - هذا مهم لتجنب التخطي!
            self.selected_index = index

            if self.debug_mode:
                value = self.filtered_values[index] if index < len(self.filtered_values) else "غير معروف"
                print(f"🎯 تمييز مؤكد: العنصر {index}: {value} - الفهرس محدث إلى: {self.selected_index}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في تمييز الخيار {index}: {e}")

    def _on_mouse_enter(self, index: int):
        """تمييز عند التمرير بالماوس (لا يغير selected_index)"""
        if not (0 <= index < len(self.option_buttons)):
            return

        try:
            # تمييز بصري خفيف فقط
            if index != self.selected_index:
                self.option_buttons[index].configure(fg_color=("#F8F9FA", "#2A2D3A"))
        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في تمييز الماوس {index}: {e}")

    def _on_mouse_leave(self, index: int):
        """إزالة تمييز الماوس (الحفاظ على تحديد الأسهم)"""
        if 0 <= index < len(self.option_buttons):
            try:
                if index != self.selected_index:
                    self.option_buttons[index].configure(fg_color="transparent")
            except Exception as e:
                if self.debug_mode:
                    print(f"❌ خطأ في إزالة تمييز الماوس {index}: {e}")

    def _scroll_to_option(self, index: int):
        """تمرير ذكي وتدريجي للقائمة - يعرض العناصر التالية عند الحاجة فقط"""
        if not (0 <= index < len(self.option_buttons)) or not hasattr(self, 'list_frame'):
            return

        try:
            # الحصول على canvas الخاص بالإطار القابل للتمرير
            if not hasattr(self.list_frame, '_parent_canvas') or not self.list_frame._parent_canvas:
                return

            canvas = self.list_frame._parent_canvas

            # الحصول على معلومات التمرير الحالية
            canvas_height = canvas.winfo_height()
            scroll_top, scroll_bottom = canvas.yview()

            # حساب موقع العنصر المحدد
            item_height = 37  # ارتفاع كل عنصر (35 + padding)
            item_top = index * item_height
            item_bottom = item_top + item_height

            # حساب المنطقة المرئية الحالية
            total_height = len(self.option_buttons) * item_height
            visible_top = scroll_top * total_height
            visible_bottom = scroll_bottom * total_height

            # هامش أمان للتمرير (لإظهار العنصر بوضوح)
            margin = item_height * 0.5

            # فحص ما إذا كان العنصر مرئياً بالفعل
            is_visible = (item_top >= visible_top - margin and
                         item_bottom <= visible_bottom + margin)

            if is_visible:
                # العنصر مرئي - لا حاجة للتمرير
                if self.debug_mode:
                    print(f"📜 العنصر {index} مرئي بالفعل - لا تمرير")
                return

            # تحديد نوع التمرير المطلوب
            if item_top < visible_top:
                # العنصر أعلى المنطقة المرئية - تمرير لأعلى
                self._scroll_up_to_show(canvas, index, item_height, total_height)
            else:
                # العنصر أسفل المنطقة المرئية - تمرير لأسفل
                self._scroll_down_to_show(canvas, index, item_height, total_height)

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير الذكي: {e}")

    def _scroll_up_to_show(self, canvas, index, item_height, total_height):
        """تمرير تدريجي لأعلى لإظهار العنصر"""
        try:
            # حساب الموقع المطلوب (مع هامش صغير)
            target_top = max(0, (index - 1) * item_height)
            new_scroll_position = target_top / total_height

            # التمرير التدريجي
            current_position = canvas.yview()[0]
            step = min(0.1, abs(new_scroll_position - current_position) / 3)

            if new_scroll_position < current_position:
                target_position = max(new_scroll_position, current_position - step)
                canvas.yview_moveto(target_position)

                if self.debug_mode:
                    print(f"📜⬆️ تمرير لأعلى: العنصر {index} (موقع: {target_position:.3f})")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير لأعلى: {e}")

    def _scroll_down_to_show(self, canvas, index, item_height, total_height):
        """تمرير تدريجي لأسفل لإظهار العناصر التالية"""
        try:
            canvas_height = canvas.winfo_height()
            visible_items = max(1, int(canvas_height / item_height))

            # حساب الموقع المطلوب لإظهار العنصر في أسفل القائمة المرئية
            target_bottom_item = min(len(self.option_buttons) - 1, index + 1)
            target_top_item = max(0, target_bottom_item - visible_items + 1)

            target_top = target_top_item * item_height
            new_scroll_position = min(1.0, target_top / total_height)

            # التمرير التدريجي
            current_position = canvas.yview()[0]
            step = min(0.1, abs(new_scroll_position - current_position) / 3)

            if new_scroll_position > current_position:
                target_position = min(new_scroll_position, current_position + step)
                canvas.yview_moveto(target_position)

                if self.debug_mode:
                    print(f"📜⬇️ تمرير لأسفل: العنصر {index} (موقع: {target_position:.3f}) - عناصر مرئية: {visible_items}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير لأسفل: {e}")

    def _scroll_to_option_smooth(self, index: int, direction: str = "auto"):
        """تمرير سلس ومحسن للعنصر مع مراعاة الاتجاه"""
        if not (0 <= index < len(self.option_buttons)) or not hasattr(self, 'list_frame'):
            return

        try:
            # الحصول على canvas الخاص بالإطار القابل للتمرير
            if not hasattr(self.list_frame, '_parent_canvas') or not self.list_frame._parent_canvas:
                return

            canvas = self.list_frame._parent_canvas

            # تأخير قصير للسماح للتحديد بالحدوث أولاً
            def perform_smooth_scroll():
                try:
                    # الحصول على معلومات التمرير الحالية
                    canvas_height = canvas.winfo_height()
                    scroll_top, scroll_bottom = canvas.yview()

                    # حساب موقع العنصر المحدد
                    item_height = 37  # ارتفاع كل عنصر
                    item_top = index * item_height
                    item_bottom = item_top + item_height

                    # حساب المنطقة المرئية الحالية
                    total_height = len(self.option_buttons) * item_height
                    visible_top = scroll_top * total_height
                    visible_bottom = scroll_bottom * total_height

                    # هامش أمان (نصف عنصر)
                    margin = item_height * 0.5

                    # فحص ما إذا كان العنصر مرئياً بالكامل
                    is_fully_visible = (item_top >= visible_top + margin and
                                       item_bottom <= visible_bottom - margin)

                    if is_fully_visible:
                        if self.debug_mode:
                            print(f"📜✅ العنصر {index} مرئي بالكامل - لا تمرير مطلوب")
                        return

                    # حساب التمرير المطلوب حسب الاتجاه
                    if direction == "down":
                        self._smart_scroll_down(canvas, index, item_height, total_height, canvas_height)
                    elif direction == "up":
                        self._smart_scroll_up(canvas, index, item_height, total_height, canvas_height)
                    else:
                        # تمرير تلقائي حسب الموقع
                        self._scroll_to_option(index)

                except Exception as e:
                    if self.debug_mode:
                        print(f"❌ خطأ في التمرير السلس: {e}")

            # تنفيذ التمرير بتأخير قصير
            self.after(10, perform_smooth_scroll)

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في إعداد التمرير السلس: {e}")

    def _smart_scroll_down(self, canvas, index, item_height, total_height, canvas_height):
        """تمرير ذكي لأسفل - يعرض العناصر التالية تدريجياً"""
        try:
            visible_items = max(1, int(canvas_height / item_height) - 1)  # ترك مساحة للتمرير

            # إذا كان العنصر في النصف السفلي من القائمة المرئية، قم بالتمرير
            current_scroll_top = canvas.yview()[0]
            current_top_item = int((current_scroll_top * total_height) / item_height)

            # إذا كان العنصر المحدد قريباً من نهاية القائمة المرئية
            if index >= current_top_item + visible_items - 2:
                # حساب موقع التمرير الجديد لإظهار عناصر إضافية
                new_top_item = min(len(self.option_buttons) - visible_items,
                                 max(0, index - visible_items + 3))

                new_scroll_position = (new_top_item * item_height) / total_height
                new_scroll_position = min(1.0, new_scroll_position)

                # تطبيق التمرير
                canvas.yview_moveto(new_scroll_position)

                if self.debug_mode:
                    print(f"📜⬇️ تمرير ذكي لأسفل: العنصر {index} - عرض من {new_top_item}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير الذكي لأسفل: {e}")

    def _smart_scroll_up(self, canvas, index, item_height, total_height, canvas_height):
        """تمرير ذكي لأعلى - يعرض العناصر السابقة تدريجياً"""
        try:
            visible_items = max(1, int(canvas_height / item_height) - 1)

            # إذا كان العنصر في النصف العلوي من القائمة المرئية، قم بالتمرير
            current_scroll_top = canvas.yview()[0]
            current_top_item = int((current_scroll_top * total_height) / item_height)

            # إذا كان العنصر المحدد قريباً من بداية القائمة المرئية
            if index <= current_top_item + 1:
                # حساب موقع التمرير الجديد لإظهار عناصر سابقة إضافية
                new_top_item = max(0, index - 2)

                new_scroll_position = (new_top_item * item_height) / total_height
                new_scroll_position = max(0.0, new_scroll_position)

                # تطبيق التمرير
                canvas.yview_moveto(new_scroll_position)

                if self.debug_mode:
                    print(f"📜⬆️ تمرير ذكي لأعلى: العنصر {index} - عرض من {new_top_item}")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير الذكي لأعلى: {e}")

    def _scroll_to_top_smooth(self):
        """تمرير سلس للأعلى (للتنقل الدائري - العودة للبداية)"""
        if not hasattr(self, 'list_frame') or not hasattr(self.list_frame, '_parent_canvas'):
            return

        try:
            canvas = self.list_frame._parent_canvas
            if not canvas:
                return

            # تمرير تدريجي للأعلى
            def smooth_scroll_to_top(current_position=None):
                if current_position is None:
                    current_position = canvas.yview()[0]

                if current_position <= 0.05:  # وصل للأعلى تقريباً
                    canvas.yview_moveto(0.0)  # تأكيد الوصول للأعلى تماماً
                    if self.debug_mode:
                        print("🔄⬆️ وصل للأعلى - تنقل دائري مكتمل")
                    return

                # تمرير تدريجي
                step = min(0.15, current_position / 3)
                new_position = max(0.0, current_position - step)
                canvas.yview_moveto(new_position)

                # الاستمرار في التمرير
                self.after(30, lambda: smooth_scroll_to_top(new_position))

            smooth_scroll_to_top()

            if self.debug_mode:
                print("🔄⬆️ بدء التمرير السلس للأعلى (تنقل دائري)")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير للأعلى: {e}")

    def _scroll_to_bottom_smooth(self):
        """تمرير سلس للأسفل (للتنقل الدائري - الذهاب للنهاية)"""
        if not hasattr(self, 'list_frame') or not hasattr(self.list_frame, '_parent_canvas'):
            return

        try:
            canvas = self.list_frame._parent_canvas
            if not canvas:
                return

            # تمرير تدريجي للأسفل
            def smooth_scroll_to_bottom(current_position=None):
                if current_position is None:
                    current_position = canvas.yview()[0]

                if current_position >= 0.95:  # وصل للأسفل تقريباً
                    canvas.yview_moveto(1.0)  # تأكيد الوصول للأسفل تماماً
                    if self.debug_mode:
                        print("🔄⬇️ وصل للأسفل - تنقل دائري مكتمل")
                    return

                # تمرير تدريجي
                step = min(0.15, (1.0 - current_position) / 3)
                new_position = min(1.0, current_position + step)
                canvas.yview_moveto(new_position)

                # الاستمرار في التمرير
                self.after(30, lambda: smooth_scroll_to_bottom(new_position))

            smooth_scroll_to_bottom()

            if self.debug_mode:
                print("🔄⬇️ بدء التمرير السلس للأسفل (تنقل دائري)")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التمرير للأسفل: {e}")

    # معالجات لوحة المفاتيح الأصلية (للتوافق - لكن لن تستخدم بعد الآن)
    def _on_arrow_down(self, event):
        """السهم لأسفل - للتوافق فقط (مُعطل لتجنب التداخل)"""
        if self.debug_mode:
            print("⚠️ تم استدعاء _on_arrow_down المكرر (مُتجاهل لتجنب التخطي)")
        # لا نفعل شيئاً لتجنب التداخل
        return "break"

    def _on_arrow_up(self, event):
        """السهم لأعلى - للتوافق فقط (مُعطل لتجنب التداخل)"""
        if self.debug_mode:
            print("⚠️ تم استدعاء _on_arrow_up المكرر (مُتجاهل لتجنب التخطي)")
        # لا نفعل شيئاً لتجنب التداخل
        return "break"

    def _on_enter(self, event):
        """مفتاح Enter - للتوافق فقط (مُعطل لتجنب التداخل)"""
        if self.debug_mode:
            print("⚠️ تم استدعاء _on_enter المكرر (مُتجاهل لتجنب التخطي)")
        # لا نفعل شيئاً لتجنب التداخل
        return "break"

    def _on_escape(self, event):
        """مفتاح Escape - للتوافق فقط (مُعطل لتجنب التداخل)"""
        if self.debug_mode:
            print("⚠️ تم استدعاء _on_escape المكرر (مُتجاهل لتجنب التخطي)")
        # لا نفعل شيئاً لتجنب التداخل
        return "break"

    # الواجهة العامة
    def get(self) -> str:
        """الحصول على القيمة"""
        return self.selected_value

    def set(self, value: str):
        """تعيين قيمة"""
        if self.debug_mode:
            print(f"🔧 تعيين: '{value}'")

        self._updating_text = True
        try:
            if value and value not in self.values:
                self.add_value(value)

            self.selected_value = value
            self.text_var.set(value)
            self.entry.delete(0, tk.END)
            self.entry.insert(0, value)
        finally:
            self._updating_text = False

    def clear(self):
        """مسح القيمة"""
        self._updating_text = True
        try:
            self.selected_value = ""
            self.text_var.set("")
            self.entry.delete(0, tk.END)
            self.filtered_values = self.values.copy()
            if self.is_dropdown_open:
                self._close_dropdown()
        finally:
            self._updating_text = False

    def set_values(self, values: List[str]):
        """تحديث قائمة القيم"""
        self.values = values.copy() if values else []
        self.filtered_values = self.values.copy()
        if self.debug_mode:
            print(f"📋 تحديث: {len(self.values)} عنصر")

    def add_value(self, value: str):
        """إضافة قيمة جديدة"""
        if value and value not in self.values:
            self.values.append(value)
            self.filtered_values = self.values.copy()

    def is_valid_selection(self) -> bool:
        """التحقق من صحة الاختيار"""
        return self.selected_value in self.values

    def focus_set(self):
        """التركيز على الحقل"""
        self.entry.focus_set()
        self._has_focus = True

    def apply_blue_theme(self, theme_manager=None):
        """تطبيق الثيم الأزرق"""
        try:
            blue_colors = {
                'entry_bg': '#F8F9FA',
                'border_color': '#2196F3',
                'text_color': '#1976D2',
                'button_hover': '#E3F2FD'
            }

            # تطبيق على حقل الإدخال
            if hasattr(self, 'entry'):
                self.entry.configure(
                    fg_color=blue_colors['entry_bg'],
                    border_color=blue_colors['border_color'],
                    text_color=blue_colors['text_color']
                )

            # تطبيق على زر القائمة
            if hasattr(self, 'dropdown_btn'):
                self.dropdown_btn.configure(
                    hover_color=blue_colors['button_hover'],
                    border_color=blue_colors['border_color']
                )

            if self.debug_mode:
                print("✅ تم تطبيق الثيم الأزرق")

        except Exception as e:
            if self.debug_mode:
                print(f"❌ فشل تطبيق الثيم: {e}")

    def destroy(self):
        """تنظيف الموارد عند الحذف"""
        try:
            # إيقاف التايمرات
            if hasattr(self, '_filter_timer') and self._filter_timer:
                self.after_cancel(self._filter_timer)
                self._filter_timer = None

            # إيقاف تتبع الموقع
            if self._position_check_id:
                self.after_cancel(self._position_check_id)
                self._position_check_id = None

            # إغلاق القائمة
            if self.is_dropdown_open:
                self._close_dropdown()

            # استدعاء destroy الأساسي
            super().destroy()

        except Exception as e:
            if self.debug_mode:
                print(f"❌ خطأ في التنظيف: {e}")


# الأسماء البديلة للتوافق
EnhancedSearchableComboBoxImproved = EnhancedSearchableComboBox
SearchableComboBox = EnhancedSearchableComboBox


def create_enhanced_dropdown_with_improved_click(parent, field_name: str, initial_value: str = "",
                                                values: List[str] = None, themed_window=None,
                                                debug_mode: bool = False, theme_manager=None):
    """إنشاء قائمة منسدلة محسنة مع آلية النقر المحسنة وتتبع النافذة"""

    # تحضير القيم
    if not values:
        values = []

    if initial_value and initial_value not in values:
        values = [initial_value] + values

    # إنشاء المكون
    combo = EnhancedSearchableComboBox(
        parent=parent,
        values=values,
        placeholder=f"ابحث في {field_name}...",
        width=300,
        height=35,
        max_results=15,
        debug_mode=debug_mode
    )

    # تطبيق الثيم
    if theme_manager:
        try:
            combo.apply_blue_theme(theme_manager)
        except Exception as e:
            print(f"⚠️ فشل في تطبيق الثيم: {e}")

    if themed_window:
        try:
            themed_window.apply_to_widget(combo.entry, 'entry')
            themed_window.apply_to_widget(combo.dropdown_btn, 'button_secondary')
        except Exception as e:
            print(f"تحذير: فشل في تطبيق الثيم العادي: {e}")

    # تعيين القيمة الأولية
    if initial_value:
        combo.set(initial_value)

    # إنشاء متغير للتوافق
    var = tk.StringVar(value=initial_value)

    # ربط المتغير مع المكون
    def sync_var():
        try:
            current_value = combo.get()
            if var.get() != current_value:
                var.set(current_value)
        except:
            pass

    def sync_combo(*args):
        try:
            current_value = var.get()
            if current_value != combo.get():
                combo.set(current_value)
        except:
            pass

    # ربط التحديثات
    var.trace('w', sync_combo)

    # تحديث دوري
    def periodic_sync():
        try:
            sync_var()
            combo.after(2000, periodic_sync)
        except:
            pass

    combo.after(100, periodic_sync)

    return var, combo


def create_airtable_combo_for_field(parent, field_name: str, dropdown_manager=None,
                                   themed_window=None, values: List[str] = None,
                                   debug_mode: bool = False, **kwargs):
    """إنشاء قائمة منسدلة لحقل Airtable مع تتبع النافذة"""

    placeholder_map = {
        "Agency": "ابحث عن وكالة...",
        "Guide": "ابحث عن مرشد...",
        "Option": "ابحث عن خيار...",
        "des": "ابحث عن وجهة...",
        "trip Name": "ابحث عن اسم رحلة...",
        "Management Option": "ابحث عن خيار إدارة...",
        "Add-on": "ابحث عن إضافة..."
    }

    if not kwargs.get('placeholder'):
        kwargs['placeholder'] = placeholder_map.get(field_name, f"ابحث في {field_name}...")

    kwargs.setdefault('max_results', 15)
    kwargs.setdefault('debug_mode', debug_mode)

    if values:
        kwargs['values'] = values

    return EnhancedSearchableComboBox(parent=parent, **kwargs)


# دالة اختبار مُحدثة مع التأكيد على إصلاح مشكلة تخطي الأسهم
def test_natural_scroll_navigation():
    """اختبار التنقل الطبيعي مع التمرير الذكي والتنقل الدائري المحسن"""

    app = ctk.CTk()
    app.title("🌊 اختبار التنقل الدائري والتمرير الذكي")
    app.geometry("700x650")

    # قائمة كبيرة للاختبار (أكثر من المساحة المرئية)
    test_values = [f"العنصر رقم {i+1:02d}" for i in range(25)]

    # متغيرات تتبع التنقل
    navigation_log = []
    scroll_log = []
    circular_navigation_count = 0

    def log_navigation(action, old_index, new_index):
        """تسجيل حركات التنقل مع التعرف على التنقل الدائري"""
        nonlocal circular_navigation_count

        # تحديد نوع التنقل
        is_circular = False
        if (old_index == len(test_values) - 1 and new_index == 0):
            is_circular = True
            action = "🔄 تنقل دائري (النهاية→البداية)"
            circular_navigation_count += 1
        elif (old_index == 0 and new_index == len(test_values) - 1):
            is_circular = True
            action = "🔄 تنقل دائري (البداية→النهاية)"
            circular_navigation_count += 1

        log_entry = f"{action}: {old_index} → {new_index}"
        if is_circular:
            log_entry += " ✨"

        navigation_log.append(log_entry)
        log_text.configure(text="\n".join(navigation_log[-6:]))  # آخر 6 حركات

        # تحديث عداد التنقل الدائري
        circular_count_label.configure(text=f"تنقلات دائرية: {circular_navigation_count} 🔄")

    def log_scroll(action):
        """تسجيل أحداث التمرير"""
        scroll_log.append(action)
        scroll_text.configure(text="\n".join(scroll_log[-4:]))  # آخر 4 أحداث تمرير

    # تعليمات الاختبار المحدثة
    instructions = ctk.CTkLabel(
        app,
        text="🌊 اختبار التنقل الدائري والتمرير الذكي:\n\n" +
             "✨ الميزات الجديدة:\n" +
             "• تنقل دائري: من النهاية للبداية والعكس 🔄\n" +
             "• تمرير ذكي وسلس للتنقل الدائري\n" +
             "• عرض طبيعي مثل التطبيقات الحديثة\n\n" +
             "🧪 جرب الوصول لنهاية القائمة ثم اضغط ↓:",
        font=ctk.CTkFont(size=12, weight="bold"),
        justify="center"
    )
    instructions.pack(pady=15)

    # ComboBox مُحسن مع تتبع التنقل الدائري
    class CircularNavigationComboBox(EnhancedSearchableComboBox):
        def _highlight_option(self, index: int):
            """تمييز مع تسجيل التنقل الدائري"""
            old_index = self.selected_index
            super()._highlight_option(index)
            new_index = self.selected_index

            if old_index != new_index:
                action = "تنقل بالأسهم"
                log_navigation(action, old_index, new_index)

                if new_index < len(self.filtered_values):
                    value = self.filtered_values[new_index]
                    position_info = ""
                    if new_index == 0:
                        position_info = " (البداية ⬆️)"
                    elif new_index == len(self.filtered_values) - 1:
                        position_info = " (النهاية ⬇️)"

                    current_selection.configure(text=f"محدد: {value} (فهرس: {new_index}){position_info}")

        def _scroll_to_top_smooth(self):
            """تمرير للأعلى مع تسجيل"""
            log_scroll("🔄⬆️ تمرير دائري للأعلى")
            super()._scroll_to_top_smooth()

        def _scroll_to_bottom_smooth(self):
            """تمرير للأسفل مع تسجيل"""
            log_scroll("🔄⬇️ تمرير دائري للأسفل")
            super()._scroll_to_bottom_smooth()

        def _smart_scroll_down(self, canvas, index, item_height, total_height, canvas_height):
            """تمرير ذكي مع تسجيل"""
            log_scroll(f"⬇️ تمرير عادي للعنصر {index}")
            super()._smart_scroll_down(canvas, index, item_height, total_height, canvas_height)

        def _smart_scroll_up(self, canvas, index, item_height, total_height, canvas_height):
            """تمرير ذكي مع تسجيل"""
            log_scroll(f"⬆️ تمرير عادي للعنصر {index}")
            super()._smart_scroll_up(canvas, index, item_height, total_height, canvas_height)

    # إنشاء ComboBox محسن
    combo_frame = ctk.CTkFrame(app)
    combo_frame.pack(pady=20, padx=20, fill="x")

    combo_label = ctk.CTkLabel(
        combo_frame,
        text="📋 قائمة طويلة (25 عنصر) - اختبار التنقل الدائري:",
        font=ctk.CTkFont(size=12, weight="bold")
    )
    combo_label.pack(pady=(10, 5))

    combo = CircularNavigationComboBox(
        parent=combo_frame,
        values=test_values,
        placeholder="افتح القائمة واختبر التنقل الدائري...",
        width=500,
        height=40,
        max_results=25,  # عرض جميع العناصر
        debug_mode=True
    )
    combo.pack(pady=10)

    # عرض العنصر المحدد حالياً
    current_selection = ctk.CTkLabel(
        app,
        text="محدد حالياً: لا شيء",
        font=ctk.CTkFont(size=14, weight="bold"),
        text_color=("#2196F3", "#64B5F6")
    )
    current_selection.pack(pady=10)

    # عداد التنقل الدائري
    circular_count_label = ctk.CTkLabel(
        app,
        text="تنقلات دائرية: 0 🔄",
        font=ctk.CTkFont(size=12, weight="bold"),
        text_color=("#FF9800", "#FFA726")
    )
    circular_count_label.pack(pady=5)

    # إطار لعرض السجلات
    logs_frame = ctk.CTkFrame(app)
    logs_frame.pack(pady=20, padx=20, fill="both", expand=True)

    # سجل حركات التنقل
    nav_frame = ctk.CTkFrame(logs_frame)
    nav_frame.pack(side="left", fill="both", expand=True, padx=(0, 10))

    nav_title = ctk.CTkLabel(
        nav_frame,
        text="📋 سجل التنقل (آخر 6 حركات):",
        font=ctk.CTkFont(size=11, weight="bold")
    )
    nav_title.pack(pady=(10, 5))

    log_text = ctk.CTkLabel(
        nav_frame,
        text="لم يتم التنقل بعد...",
        font=ctk.CTkFont(size=10, family="monospace"),
        justify="left",
        anchor="w"
    )
    log_text.pack(pady=10, padx=10, fill="both", expand=True)

    # سجل أحداث التمرير
    scroll_frame = ctk.CTkFrame(logs_frame)
    scroll_frame.pack(side="right", fill="both", expand=True, padx=(10, 0))

    scroll_title = ctk.CTkLabel(
        scroll_frame,
        text="📜 سجل التمرير (آخر 4 أحداث):",
        font=ctk.CTkFont(size=11, weight="bold")
    )
    scroll_title.pack(pady=(10, 5))

    scroll_text = ctk.CTkLabel(
        scroll_frame,
        text="لم يحدث تمرير بعد...",
        font=ctk.CTkFont(size=10, family="monospace"),
        justify="left",
        anchor="w"
    )
    scroll_text.pack(pady=10, padx=10, fill="both", expand=True)

    # إرشادات الاختبار المحدثة
    test_guide = ctk.CTkFrame(app)
    test_guide.pack(pady=10, padx=20, fill="x")

    guide_text = [
        "🧪 اختبارات التنقل الدائري المحسن:",
        "• افتح القائمة واستخدم ↓ للوصول لنهاية القائمة",
        "• عند الوصول للعنصر الأخير، اضغط ↓ → سينتقل للأول 🔄",
        "• من العنصر الأول، اضغط ↑ → سينتقل للأخير 🔄",
        "• راقب التمرير السلس أثناء التنقل الدائري",
        "• التنقل الدائري مميز بـ ✨ في السجل"
    ]

    for i, text in enumerate(guide_text):
        label = ctk.CTkLabel(
            test_guide,
            text=text,
            font=ctk.CTkFont(size=10, weight="bold" if i == 0 else "normal"),
            text_color=("#2196F3", "#64B5F6") if i == 0 else ("gray", "lightgray"),
            anchor="e"
        )
        label.pack(pady=1, padx=10, anchor="e")

    # أزرار التحكم المحدثة
    button_frame = ctk.CTkFrame(app)
    button_frame.pack(pady=10)

    def open_and_select_first():
        combo._open_dropdown()
        if combo.option_buttons:
            combo._highlight_option(0)

    def open_and_select_last():
        combo._open_dropdown()
        if combo.option_buttons:
            last_index = len(combo.option_buttons) - 1
            combo._highlight_option(last_index)
            combo._scroll_to_bottom_smooth()

    def test_circular_down():
        """اختبار التنقل الدائري لأسفل"""
        if not combo.is_dropdown_open:
            combo._open_dropdown()
        if combo.option_buttons:
            last_index = len(combo.option_buttons) - 1
            combo._highlight_option(last_index)
            combo._scroll_to_bottom_smooth()
            combo.after(1000, lambda: combo._handle_arrow_down_enhanced())

    def test_circular_up():
        """اختبار التنقل الدائري لأعلى"""
        if not combo.is_dropdown_open:
            combo._open_dropdown()
        if combo.option_buttons:
            combo._highlight_option(0)
            combo._scroll_to_top_smooth()
            combo.after(1000, lambda: combo._handle_arrow_up_enhanced())

    def clear_logs():
        nonlocal circular_navigation_count
        navigation_log.clear()
        scroll_log.clear()
        circular_navigation_count = 0
        log_text.configure(text="تم مسح سجل التنقل...")
        scroll_text.configure(text="تم مسح سجل التمرير...")
        circular_count_label.configure(text="تنقلات دائرية: 0 🔄")
        current_selection.configure(text="محدد حالياً: لا شيء")

    ctk.CTkButton(button_frame, text="فتح + الأول",
                  command=open_and_select_first).pack(side="left", padx=2)
    ctk.CTkButton(button_frame, text="فتح + الأخير",
                  command=open_and_select_last).pack(side="left", padx=2)
    ctk.CTkButton(button_frame, text="اختبار ↓ دائري",
                  command=test_circular_down,
                  text_color=("#FF9800", "#FFA726")).pack(side="left", padx=2)
    ctk.CTkButton(button_frame, text="اختبار ↑ دائري",
                  command=test_circular_up,
                  text_color=("#FF9800", "#FFA726")).pack(side="left", padx=2)
    ctk.CTkButton(button_frame, text="مسح السجلات",
                  command=clear_logs).pack(side="left", padx=2)
    ctk.CTkButton(button_frame, text="إغلاق",
                  command=combo._close_dropdown).pack(side="left", padx=2)

    print("🌊 بدء اختبار التنقل الدائري والتمرير الذكي")
    print("✨ الميزات الجديدة:")
    print("  🔄 تنقل دائري - من النهاية للبداية والعكس")
    print("  🎯 تمرير ذكي - يحدث عند الحاجة فقط")
    print("  📱 سلوك طبيعي - مثل التطبيقات الحديثة")
    print("  💫 تمرير سلس للتنقل الدائري")
    print("=" * 60)

    app.mainloop()


# تحديث الدوال للتوافق
def test_enhanced_combobox_arrow_fix():
    """دالة للتوافق - تستدعي اختبار التمرير الطبيعي"""
    print("📌 استدعاء اختبار التمرير الطبيعي المحسن...")
    return test_natural_scroll_navigation()

def test_enhanced_combobox_with_live_filtering():
    """دالة للتوافق مع الاسم السابق"""
    print("📌 استدعاء اختبار التمرير الطبيعي...")
    return test_natural_scroll_navigation()

def test_enhanced_combobox_with_tracking():
    """دالة للتوافق مع الاسم السابق"""
    print("📌 استدعاء اختبار التمرير الطبيعي...")
    return test_natural_scroll_navigation()

def test_enhanced_combobox():
    """دالة اختبار بسيطة للتوافق مع الإصدار السابق"""
    print("📌 استدعاء اختبار التمرير الطبيعي...")
    return test_natural_scroll_navigation()


if __name__ == "__main__":
    test_natural_scroll_navigation()


# ✅ ملخص الإصلاحات والتحسينات المطبقة:
#
# 🔧 إصلاح مشكلة تخطي الأسهم:
#   1. إزالة المعالجات المكررة في _setup_events()
#   2. معالج واحد فقط: _on_key_release_enhanced()
#   3. تحسين _highlight_option() لضمان تحديث الفهرس
#   4. تعطيل الدوال المكررة لتجنب التداخل
#
# 🔄 إضافة التنقل الدائري المحسن:
#   1. من النهاية للبداية عند الضغط على ↓
#   2. من البداية للنهاية عند الضغط على ↑
#   3. تمرير سلس ومتحرك للتنقل الدائري
#   4. كشف تلقائي للتنقل الدائري مع تسجيل مميز
#
# 🌊 تحسين التمرير الطبيعي:
#   1. _scroll_to_option() الآن ذكي - يفحص الرؤية أولاً
#   2. تمرير تدريجي بدلاً من القفز المباشر
#   3. _smart_scroll_down() و _smart_scroll_up() للتمرير الطبيعي
#   4. _scroll_to_top_smooth() و _scroll_to_bottom_smooth() للتنقل الدائري
#   5. التمرير يحدث فقط عند الحاجة (وصول لحافة القائمة)
#
# 🎯 النتائج:
#   ✅ تنقل صحيح عنصر واحد بكل ضغطة سهم
#   ✅ تنقل دائري سلس من النهاية للبداية والعكس 🔄
#   ✅ تمرير طبيعي وذكي مثل التطبيقات الحديثة
#   ✅ لا مزيد من القفزات المفاجئة في التمرير
#   ✅ سلوك بديهي ومألوف للمستخدم
#   ✅ تأثيرات بصرية سلسة للتنقل الدائري
#
# 🧪 للاختبار: python combobox.py

============================================================
FILE: views\components\data_table.py
SIZE: 20968 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/data_table.py

مكون جدول البيانات المحسن لعرض السجلات مع تصميم احترافي
"""

import customtkinter as ctk
import tkinter as tk
from tkinter import ttk
from typing import Callable, List, Dict, Any
from datetime import datetime

from core.language_manager import LanguageManager


class DataTableComponent(ctk.CTkFrame):
    """مكون جدول البيانات المحسن"""

    def __init__(
        self,
        parent,
        lang_manager: LanguageManager,
        on_row_double_click: Callable = None,
        on_selection_change: Callable = None,
        **kwargs
    ):
        # تطبيق إعدادات احترافية للإطار
        kwargs.setdefault('corner_radius', 8)
        kwargs.setdefault('fg_color', ("#ffffff", "#2b2b2b"))
        super().__init__(parent, **kwargs)

        self.lang_manager = lang_manager
        self.on_row_double_click = on_row_double_click
        self.on_selection_change = on_selection_change

        self.selected_records = []
        self.all_records = []

        self._build_ui()
        self._apply_professional_style()

    def _build_ui(self):
        """بناء الواجهة المحسنة"""
        # إطار الجدول مع padding محسن
        table_container = ctk.CTkFrame(
            self,
            corner_radius=0,
            fg_color="transparent"
        )
        table_container.pack(fill="both", expand=True, padx=2, pady=2)

        # إنشاء الجدول
        self._create_treeview(table_container)

        # شريط التمرير المحسن
        self._create_scrollbars(table_container)

    def _create_treeview(self, parent):
        """إنشاء جدول TreeView محسن"""
        # الأعمدة
        columns = self._get_column_names()

        # إنشاء TreeView مع إعدادات محسنة
        self.tree = ttk.Treeview(
            parent,
            columns=columns,
            show="tree headings",
            selectmode="extended",
            height=15  # عدد الصفوف المرئية
        )

        # إعداد الأعمدة مع عرض محسن
        self.tree.column("#0", width=50, stretch=False)

        column_configs = [
            ("booking_nr", 130, "center"),
            ("date_trip", 110, "center"),
            ("customer_name", 180, "w"),
            ("hotel_name", 180, "w"),
            ("pickup_time", 100, "center"),
            ("price", 120, "e"),
            ("status", 120, "center")
        ]

        for i, (col, width, anchor) in enumerate(column_configs):
            if i < len(columns):
                self.tree.column(columns[i], width=width, anchor=anchor, minwidth=80)
                self.tree.heading(
                    columns[i],
                    text=col,
                    command=lambda c=columns[i]: self._sort_by_column(c)
                )

        # تطبيق النمط الاحترافي
        self._apply_treeview_style()

        # ربط الأحداث
        self.tree.bind("<Double-1>", self._on_double_click)
        self.tree.bind("<<TreeviewSelect>>", self._on_selection_change)
        self.tree.bind("<Button-3>", self._on_right_click)  # قائمة سياق

        # وضع الجدول
        self.tree.grid(row=0, column=0, sticky="nsew")
        parent.grid_rowconfigure(0, weight=1)
        parent.grid_columnconfigure(0, weight=1)

        # تحديث عناوين الأعمدة
        self._update_column_headers()

    def _apply_treeview_style(self):
        """تطبيق النمط الاحترافي للجدول"""
        style = ttk.Style()

        # فرض إعادة تحديث النمط
        try:
            style.theme_use("clam")
        except:
            pass

        # ألوان احترافية للوضع الفاتح والداكن
        if ctk.get_appearance_mode() == "Dark":
            # الوضع الداكن
            bg_color = "#2b2b2b"
            fg_color = "#ffffff"
            selected_bg = "#1976d2"
            selected_fg = "#ffffff"
            header_bg = "#1e1e1e"
            header_fg = "#ffffff"
            row_hover = "#3a3a3a"
            alt_row_bg = "#323232"
        else:
            # الوضع الفاتح
            bg_color = "#ffffff"
            fg_color = "#333333"
            selected_bg = "#e3f2fd"
            selected_fg = "#1976d2"
            header_bg = "#f8f9fa"
            header_fg = "#333333"
            row_hover = "#f5f5f5"
            alt_row_bg = "#f9f9f9"

        # تكوين Treeview
        style.configure(
            "Treeview",
            background=bg_color,
            foreground=fg_color,
            rowheight=35,
            fieldbackground=bg_color,
            borderwidth=0,
            relief="flat",
            font=('Segoe UI', 10)
        )

        # تكوين رأس الجدول
        style.configure(
            "Treeview.Heading",
            background=header_bg,
            foreground=header_fg,
            relief="flat",
            borderwidth=0,
            font=('Segoe UI', 11, 'bold')
        )

        # تأثيرات التحديد والتمرير
        style.map(
            "Treeview",
            background=[
                ('selected', selected_bg),
                ('active', row_hover)
            ],
            foreground=[
                ('selected', selected_fg),
                ('active', fg_color)
            ]
        )

        # تأثيرات رأس الجدول عند التمرير
        style.map(
            "Treeview.Heading",
            background=[
                ('active', selected_bg),
                ('pressed', selected_bg)
            ],
            foreground=[
                ('active', selected_fg),
                ('pressed', selected_fg)
            ]
        )

        # تطبيق الصفوف المتناوبة
        self.tree.tag_configure('oddrow', background=bg_color)
        self.tree.tag_configure('evenrow', background=alt_row_bg)

        # فرض تحديث الجدول
        self.tree.update_idletasks()

    def _create_scrollbars(self, parent):
        """إنشاء أشرطة تمرير محسنة"""
        # شريط تمرير عمودي محسن
        vsb_frame = ctk.CTkFrame(parent, width=16, fg_color="transparent")
        vsb_frame.grid(row=0, column=1, sticky="ns", padx=(2, 0))

        vsb = ttk.Scrollbar(
            vsb_frame,
            orient="vertical",
            command=self.tree.yview,
            style="Vertical.TScrollbar"
        )
        vsb.pack(fill="y", expand=True)
        self.tree.configure(yscrollcommand=vsb.set)

        # شريط تمرير أفقي محسن
        hsb_frame = ctk.CTkFrame(parent, height=16, fg_color="transparent")
        hsb_frame.grid(row=1, column=0, sticky="ew", pady=(2, 0))

        hsb = ttk.Scrollbar(
            hsb_frame,
            orient="horizontal",
            command=self.tree.xview,
            style="Horizontal.TScrollbar"
        )
        hsb.pack(fill="x", expand=True)
        self.tree.configure(xscrollcommand=hsb.set)

        # تطبيق نمط أشرطة التمرير
        self._style_scrollbars()

    def _style_scrollbars(self):
        """تطبيق نمط احترافي لأشرطة التمرير"""
        style = ttk.Style()

        if ctk.get_appearance_mode() == "Dark":
            bg_color = "#2b2b2b"
            thumb_color = "#555555"
            thumb_hover = "#666666"
            arrow_color = "#999999"
        else:
            bg_color = "#f0f0f0"
            thumb_color = "#cccccc"
            thumb_hover = "#aaaaaa"
            arrow_color = "#666666"

        # نمط شريط التمرير العمودي
        style.configure(
            "Vertical.TScrollbar",
            gripcount=0,
            background=thumb_color,
            darkcolor=bg_color,
            lightcolor=bg_color,
            troughcolor=bg_color,
            bordercolor=bg_color,
            arrowcolor=arrow_color,
            arrowsize=14
        )

        style.map(
            "Vertical.TScrollbar",
            background=[
                ('active', thumb_hover),
                ('pressed', thumb_hover),
                ('!active', thumb_color)
            ]
        )

        # نمط شريط التمرير الأفقي
        style.configure(
            "Horizontal.TScrollbar",
            gripcount=0,
            background=thumb_color,
            darkcolor=bg_color,
            lightcolor=bg_color,
            troughcolor=bg_color,
            bordercolor=bg_color,
            arrowcolor=arrow_color,
            arrowsize=14
        )

        style.map(
            "Horizontal.TScrollbar",
            background=[
                ('active', thumb_hover),
                ('pressed', thumb_hover),
                ('!active', thumb_color)
            ]
        )

    def display_data(self, records: List[Dict[str, Any]]):
        """عرض البيانات في الجدول مع تحسينات بصرية"""
        # حفظ السجلات
        self.all_records = records

        # مسح الجدول
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            return
        for item in self.tree.get_children():
            self.tree.delete(item)

        # إضافة السجلات مع تحسينات
        for idx, record in enumerate(records):
            fields = record.get('fields', {})

            # تحضير البيانات
            values = (
                fields.get('Booking Nr.', ''),
                self._format_date(fields.get('Date Trip', '')),
                fields.get('Customer Name', ''),
                fields.get('Hotel Name', ''),
                self._format_time(fields.get('pickup time', '')),
                self._format_currency(fields.get('Net Rate', 0)),
                self._translate_status(fields.get('Booking Status', ''))
            )

            # تحديد التاجات
            tags = []

            # تاج الصف (زوجي/فردي)
            if idx % 2 == 0:
                tags.append('evenrow')
            else:
                tags.append('oddrow')

            # تاج الحالة
            status = fields.get('Booking Status', '').lower()
            if status == 'confirmed':
                tags.append('confirmed')
            elif status == 'pending':
                tags.append('pending')
            elif status == 'cancelled':
                tags.append('cancelled')
            elif status == 'completed':
                tags.append('completed')

            # إضافة الصف
            item = self.tree.insert("", "end", values=values, tags=tags)

        # تطبيق ألوان الحالات المحسنة
        self._apply_status_colors()

    def _apply_status_colors(self):
        """تطبيق ألوان احترافية للحالات"""
        if ctk.get_appearance_mode() == "Dark":
            # ألوان الوضع الداكن
            self.tree.tag_configure('confirmed', background='#1b5e20', foreground='#ffffff')
            self.tree.tag_configure('pending', background='#f57c00', foreground='#ffffff')
            self.tree.tag_configure('cancelled', background='#b71c1c', foreground='#ffffff')
            self.tree.tag_configure('completed', background='#0d47a1', foreground='#ffffff')
        else:
            # ألوان الوضع الفاتح
            self.tree.tag_configure('confirmed', background='#d4edda', foreground='#155724')
            self.tree.tag_configure('pending', background='#fff3cd', foreground='#856404')
            self.tree.tag_configure('cancelled', background='#f8d7da', foreground='#721c24')
            self.tree.tag_configure('completed', background='#cce5ff', foreground='#004085')

    def _format_date(self, date_str):
        """تنسيق التاريخ بشكل احترافي"""
        if not date_str:
            return ""
        try:
            date = datetime.fromisoformat(date_str[:10])
            if self.lang_manager and self.lang_manager.current_lang == "ar":
                # تنسيق عربي مع أسماء الأيام
                days_ar = ['الإثنين', 'الثلاثاء', 'الأربعاء', 'الخميس', 'الجمعة', 'السبت', 'الأحد']
                day_name = days_ar[date.weekday()]
                return f"{day_name} {date.strftime('%d/%m/%Y')}"
            else:
                # تنسيق إنجليزي
                return date.strftime("%a %d %b %Y")
        except:
            return date_str

    def _format_time(self, time_str):
        """تنسيق الوقت بشكل احترافي"""
        if not time_str:
            return ""
        try:
            # محاولة تحويل الوقت
            if ":" in time_str:
                time_parts = time_str.split(":")
                hour = int(time_parts[0])
                minute = int(time_parts[1]) if len(time_parts) > 1 else 0

                # تنسيق 12 ساعة
                period = "PM" if hour >= 12 else "AM"
                if self.lang_manager and self.lang_manager.current_lang == "ar":
                    period = "م" if hour >= 12 else "ص"

                hour_12 = hour % 12
                if hour_12 == 0:
                    hour_12 = 12

                return f"{hour_12:02d}:{minute:02d} {period}"
            return time_str
        except:
            return time_str

    def _format_currency(self, amount):
        """تنسيق العملة بشكل احترافي"""
        try:
            formatted = f"{float(amount):,.2f}"
            if self.lang_manager and self.lang_manager.current_lang == "ar":
                # استبدال الفاصلة بالفاصلة العربية
                formatted = formatted.replace(",", "،")
                return f"{formatted} $"
            else:
                return f"${formatted}"
        except:
            return "$0.00"

    def _translate_status(self, status):
        """ترجمة الحالة مع أيقونة"""
        if not self.lang_manager:
            return status

        # قاموس الحالات مع الأيقونات
        status_map = {
            'confirmed': ('✓', 'status_confirmed', 'Confirmed'),
            'pending': ('⏳', 'status_pending', 'Pending'),
            'cancelled': ('✗', 'status_cancelled', 'Cancelled'),
            'completed': ('✔', 'status_completed', 'Completed')
        }

        status_lower = status.lower()
        if status_lower in status_map:
            icon, key, default = status_map[status_lower]
            translated = self.lang_manager.get(key, default)
            return f"{icon} {translated}"

        return status

    def _on_right_click(self, event):
        """معالج النقر بالزر الأيمن (قائمة سياق)"""
        # تحديد الصف المنقور
        item = self.tree.identify('item', event.x, event.y)
        if item:
            self.tree.selection_set(item)

            # إنشاء قائمة سياق
            context_menu = tk.Menu(self, tearoff=0)
            context_menu.configure(
                bg=("#ffffff" if ctk.get_appearance_mode() == "Light" else "#2b2b2b"),
                fg=("#000000" if ctk.get_appearance_mode() == "Light" else "#ffffff"),
                activebackground=("#e3f2fd" if ctk.get_appearance_mode() == "Light" else "#1976d2"),
                activeforeground=("#1976d2" if ctk.get_appearance_mode() == "Light" else "#ffffff"),
                font=('Segoe UI', 10)
            )

            # إضافة عناصر القائمة
            context_menu.add_command(
                label=f"✏️ {self.lang_manager.get('edit', 'Edit')}",
                command=lambda: self._context_edit(item)
            )
            context_menu.add_command(
                label=f"📋 {self.lang_manager.get('copy', 'Copy')}",
                command=lambda: self._context_copy(item)
            )
            context_menu.add_separator()
            context_menu.add_command(
                label=f"🗑️ {self.lang_manager.get('delete', 'Delete')}",
                command=lambda: self._context_delete(item)
            )

            # عرض القائمة
            context_menu.tk_popup(event.x_root, event.y_root)

    def _context_edit(self, item):
        """تعديل من القائمة السياقية"""
        index = self.tree.index(item)
        if 0 <= index < len(self.all_records):
            record = self.all_records[index]
            if self.on_row_double_click:
                self.on_row_double_click(record)

    def _context_copy(self, item):
        """نسخ من القائمة السياقية"""
        values = self.tree.item(item)['values']
        if values:
            # نسخ رقم الحجز
            self.clipboard_clear()
            self.clipboard_append(str(values[0]))

    def _context_delete(self, item):
        """حذف من القائمة السياقية"""
        # يمكن تنفيذ منطق الحذف هنا
        pass

    def _sort_by_column(self, column):
        """ترتيب حسب العمود مع مؤشر بصري"""
        # TODO: تنفيذ الترتيب مع إضافة سهم للإشارة لاتجاه الترتيب
        pass

    def _apply_professional_style(self):
        """تطبيق تحسينات إضافية للمظهر الاحترافي"""
        # يمكن إضافة المزيد من التحسينات البصرية هنا
        pass

    def _get_column_names(self):
        """الحصول على أسماء الأعمدة الداخلية"""
        return ["booking_nr", "date_trip", "customer_name", "hotel_name",
                "pickup_time", "price", "status"]

    def _on_double_click(self, event):
        """معالج النقر المزدوج المحسن"""
        selection = self.tree.selection()
        if selection and self.on_row_double_click:
            item = selection[0]
            index = self.tree.index(item)
            if 0 <= index < len(self.all_records):
                record = self.all_records[index]
                self.on_row_double_click(record)

    def _on_selection_change(self, event):
        """معالج تغيير التحديد المحسن"""
        selection = self.tree.selection()
        self.selected_records = []

        for item in selection:
            index = self.tree.index(item)
            if 0 <= index < len(self.all_records):
                self.selected_records.append(self.all_records[index])

        if self.on_selection_change:
            self.on_selection_change(self.selected_records)

    def get_selected_records(self):
        """الحصول على السجلات المحددة"""
        return self.selected_records

    def clear_selection(self):
        """مسح التحديد"""
        self.tree.selection_remove(self.tree.selection())
        self.selected_records = []

    def update_texts(self, lang_manager: LanguageManager):
        """تحديث جميع النصوص عند تغيير اللغة"""
        self.lang_manager = lang_manager

        # تحديث عناوين الأعمدة
        self._update_column_headers()

        # إعادة عرض البيانات لتحديث الترجمات
        if self.all_records:
            self.display_data(self.all_records)

    def _update_column_headers(self):
        """تحديث عناوين الأعمدة بناءً على اللغة الحالية"""
        if not hasattr(self, 'tree') or not self.tree.winfo_exists():
            return

        # تعريف الأعمدة مع مفاتيح الترجمة
        columns_map = [
            ("booking_number", "Booking Nr.", "رقم الحجز"),
            ("trip_date", "Trip Date", "تاريخ الرحلة"),
            ("customer_name", "Customer Name", "اسم العميل"),
            ("hotel", "Hotel", "الفندق"),
            ("pickup_time", "Pickup Time", "وقت الاستلام"),
            ("price", "Price", "السعر"),
            ("status", "Status", "الحالة")
        ]

        # الحصول على اللغة الحالية
        current_lang = self.lang_manager.current_lang if self.lang_manager else "ar"

        # تحديث عناوين الأعمدة
        columns = self.tree["columns"]
        for i, (trans_key, en_name, ar_name) in enumerate(columns_map):
            if i < len(columns):
                # الحصول على النص المترجم
                if self.lang_manager:
                    translated_text = self.lang_manager.get(trans_key, en_name if current_lang == "en" else ar_name)
                else:
                    translated_text = en_name if current_lang == "en" else ar_name

                # تحديث عنوان العمود
                self.tree.heading(columns[i], text=translated_text)

    def set_loading(self, is_loading: bool):
        """عرض حالة التحميل"""
        if is_loading:
            # يمكن إضافة مؤشر تحميل هنا
            pass
        else:
            # إخفاء مؤشر التحميل
            pass

    def refresh_theme(self):
        """تحديث الثيم عند تغييره"""
        # إعادة تطبيق أنماط TreeView
        self._apply_treeview_style()

        # إعادة تطبيق أنماط أشرطة التمرير
        self._style_scrollbars()

        # إعادة تطبيق ألوان الحالات
        self._apply_status_colors()

        # تحديث إطار الجدول
        self.configure(fg_color=("#ffffff", "#2b2b2b"))

        # إعادة عرض البيانات لتطبيق الألوان الجديدة
        if self.all_records:
            # حفظ التحديد الحالي
            current_selection = self.tree.selection()

            # إعادة عرض البيانات
            self.display_data(self.all_records)

            # استعادة التحديد
            if current_selection:
                try:
                    for item in current_selection:
                        self.tree.selection_add(item)
                except:
                    pass

============================================================
FILE: views\components\dropdown_dialogs.py
SIZE: 54108 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/dropdown_dialogs.py

نوافذ حوار القائمة المنسدلة المحدثة والمتكاملة مع بنية التطبيق
"""

import customtkinter as ctk
from typing import Dict, Any, Callable, Optional, List
import webbrowser
from datetime import datetime
import json
import os
from tkinter import messagebox, filedialog

from core.language_manager import LanguageManager
from core.theme_manager import ThemeManager
from core.config_manager import ConfigManager
from core.logger import logger


class ProfileWindow(ctk.CTkToplevel):
    """نافذة عرض وتعديل الملف الشخصي - محدثة لجلب البيانات من Airtable"""

    def __init__(self, parent, controller, lang_manager):
        super().__init__(parent)

        self.controller = controller
        self.lang_manager = lang_manager

        # إعدادات النافذة
        self.title(lang_manager.get("profile_title", "User Profile"))
        self.geometry("450x600")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        # تحميل بيانات المستخدم
        self._load_user_data()

        # بناء الواجهة
        self._build_ui()

        # توسيط النافذة
        self._center_window()

    def _center_window(self):
        """توسيط النافذة على الشاشة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _load_user_data(self):
        """تحميل بيانات المستخدم من Airtable"""
        try:
            # الحصول على معلومات المستخدم الحالي
            current_username = self.controller.current_username

            if current_username and self.controller.airtable_users:
                # جلب جميع المستخدمين
                users = self.controller.airtable_users.fetch_records()

                # البحث عن المستخدم الحالي
                for user in users:
                    fields = user.get('fields', {})
                    if fields.get('Username', '').lower() == current_username.lower():
                        self.user_data = fields
                        self.user_record_id = user.get('id')
                        logger.info(f"تم جلب بيانات المستخدم: {current_username}")
                        return

            # إذا لم يتم العثور على البيانات، استخدم البيانات المحلية
            self.user_data = self.controller.current_user_info or {}
            self.user_record_id = self.user_data.get('record_id')

        except Exception as e:
            logger.error(f"خطأ في جلب بيانات المستخدم: {e}")
            self.user_data = {}
            self.user_record_id = None

    def _build_ui(self):
        """بناء واجهة الملف الشخصي"""
        # الحاوية الرئيسية مع التمرير
        main_frame = ctk.CTkScrollableFrame(self, width=400, height=500)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # العنوان
        title_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        title_frame.pack(fill="x", pady=(0, 20))

        # أيقونة المستخدم
        user_icon = ctk.CTkLabel(
            title_frame,
            text="👤",
            font=ctk.CTkFont(size=48)
        )
        user_icon.pack()

        # اسم المستخدم
        username = self.user_data.get('Username', 'Unknown')
        username_label = ctk.CTkLabel(
            title_frame,
            text=username,
            font=ctk.CTkFont(size=24, weight="bold")
        )
        username_label.pack(pady=(10, 5))

        # الدور
        role = self.user_data.get('Role', 'User')
        role_text = self._translate_role(role)
        role_label = ctk.CTkLabel(
            title_frame,
            text=role_text,
            font=ctk.CTkFont(size=14),
            text_color=("gray60", "gray40")
        )
        role_label.pack()

        # خط فاصل
        separator = ctk.CTkFrame(main_frame, height=2, fg_color=("gray70", "gray30"))
        separator.pack(fill="x", pady=20)

        # معلومات المستخدم
        self._create_info_section(main_frame)

        # إحصائيات الاستخدام
        self._create_stats_section(main_frame)

        # أزرار الإجراءات
        self._create_action_buttons(main_frame)

        # زر الإغلاق
        close_btn = ctk.CTkButton(
            self,
            text=self.lang_manager.get("close", "Close"),
            command=self.destroy,
            width=120
        )
        close_btn.pack(pady=(0, 20))

    def _create_info_section(self, parent):
        """إنشاء قسم المعلومات الأساسية"""
        info_frame = ctk.CTkFrame(parent)
        info_frame.pack(fill="x", pady=(0, 20))

        # عنوان القسم
        section_title = ctk.CTkLabel(
            info_frame,
            text=self.lang_manager.get("basic_info", "Basic Information"),
            font=ctk.CTkFont(size=16, weight="bold")
        )
        section_title.pack(anchor="w", padx=15, pady=(15, 10))

        # المعلومات
        info_items = [
            ("email", "Email", self.user_data.get('Email', 'Not provided')),
            ("phone", "Phone", self.user_data.get('Phone', 'Not provided')),
            ("department", "Department", self.user_data.get('Department', 'Not specified')),
            ("airtable_view", "Assigned View", self.user_data.get('Airtable View', 'Default')),
            ("status", "Status", "Active" if self.user_data.get('Active', True) else "Inactive")
        ]

        for key, label, value in info_items:
            self._create_info_row(info_frame, self.lang_manager.get(key, label), value)

    def _create_stats_section(self, parent):
        """إنشاء قسم الإحصائيات"""
        stats_frame = ctk.CTkFrame(parent)
        stats_frame.pack(fill="x", pady=(0, 20))

        # عنوان القسم
        section_title = ctk.CTkLabel(
            stats_frame,
            text=self.lang_manager.get("usage_stats", "Usage Statistics"),
            font=ctk.CTkFont(size=16, weight="bold")
        )
        section_title.pack(anchor="w", padx=15, pady=(15, 10))

        # الإحصائيات
        last_login = self.user_data.get('Last Login', '')
        if last_login:
            try:
                dt = datetime.fromisoformat(last_login.replace('Z', '+00:00'))
                last_login = dt.strftime("%Y-%m-%d %H:%M")
            except:
                pass

        login_count = self.user_data.get('Login Count', 0)
        created_date = self.user_data.get('Created Date', '')
        if created_date:
            try:
                dt = datetime.fromisoformat(created_date.replace('Z', '+00:00'))
                created_date = dt.strftime("%Y-%m-%d")
            except:
                pass

        stats_items = [
            ("last_login", "Last Login", last_login or 'Never'),
            ("login_count", "Login Count", str(login_count)),
            ("created_date", "Member Since", created_date or 'Unknown')
        ]

        for key, label, value in stats_items:
            self._create_info_row(stats_frame, self.lang_manager.get(key, label), value)

    def _create_info_row(self, parent, label, value):
        """إنشاء صف معلومات"""
        row_frame = ctk.CTkFrame(parent, fg_color="transparent")
        row_frame.pack(fill="x", padx=20, pady=3)

        # التسمية
        label_widget = ctk.CTkLabel(
            row_frame,
            text=f"{label}:",
            font=ctk.CTkFont(size=13),
            anchor="w",
            width=120
        )
        label_widget.pack(side="left")

        # القيمة
        value_widget = ctk.CTkLabel(
            row_frame,
            text=str(value),
            font=ctk.CTkFont(size=13, weight="bold"),
            anchor="w"
        )
        value_widget.pack(side="left", padx=(10, 0))

    def _create_action_buttons(self, parent):
        """إنشاء أزرار الإجراءات"""
        actions_frame = ctk.CTkFrame(parent)
        actions_frame.pack(fill="x", pady=(0, 20))

        # عنوان القسم
        section_title = ctk.CTkLabel(
            actions_frame,
            text=self.lang_manager.get("actions", "Actions"),
            font=ctk.CTkFont(size=16, weight="bold")
        )
        section_title.pack(anchor="w", padx=15, pady=(15, 10))

        # أزرار الإجراءات
        buttons_frame = ctk.CTkFrame(actions_frame, fg_color="transparent")
        buttons_frame.pack(fill="x", padx=20, pady=10)

        # زر تغيير كلمة المرور
        change_pwd_btn = ctk.CTkButton(
            buttons_frame,
            text=self.lang_manager.get("change_password", "Change Password"),
            command=self._change_password,
            width=180
        )
        change_pwd_btn.pack(pady=5)

        # زر تحديث البريد الإلكتروني
        update_email_btn = ctk.CTkButton(
            buttons_frame,
            text=self.lang_manager.get("update_email", "Update Email"),
            command=self._update_email,
            width=180,
            fg_color="transparent",
            border_width=2
        )
        update_email_btn.pack(pady=5)

    def _translate_role(self, role):
        """ترجمة الدور"""
        role_translations = {
            'admin': self.lang_manager.get("role_admin", "Administrator"),
            'manager': self.lang_manager.get("role_manager", "Manager"),
            'editor': self.lang_manager.get("role_editor", "Editor"),
            'viewer': self.lang_manager.get("role_viewer", "Viewer")
        }
        return role_translations.get(role.lower(), role)

    def _change_password(self):
        """فتح نافذة تغيير كلمة المرور"""
        dialog = ChangePasswordDialog(self, self.controller, self.lang_manager)

    def _update_email(self):
        """فتح نافذة تحديث البريد الإلكتروني"""
        dialog = UpdateEmailDialog(self, self.controller, self.lang_manager, self.user_data.get('Email', ''))


class ChangePasswordDialog(ctk.CTkToplevel):
    """نافذة حوار تغيير كلمة المرور"""

    def __init__(self, parent, controller, lang_manager):
        super().__init__(parent)

        self.controller = controller
        self.lang_manager = lang_manager

        # إعدادات النافذة
        self.title(lang_manager.get("change_password", "Change Password"))
        self.geometry("400x350")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        self._build_ui()
        self._center_window()

    def _center_window(self):
        """توسيط النافذة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _build_ui(self):
        """بناء الواجهة"""
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # العنوان
        title_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("change_password", "Change Password"),
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title_label.pack(pady=(0, 20))

        # كلمة المرور الحالية
        current_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("current_password", "Current Password"),
            anchor="w"
        )
        current_label.pack(fill="x", pady=(0, 5))

        self.current_entry = ctk.CTkEntry(
            main_frame,
            show="•",
            height=40
        )
        self.current_entry.pack(fill="x", pady=(0, 15))

        # كلمة المرور الجديدة
        new_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("new_password", "New Password"),
            anchor="w"
        )
        new_label.pack(fill="x", pady=(0, 5))

        self.new_entry = ctk.CTkEntry(
            main_frame,
            show="•",
            height=40
        )
        self.new_entry.pack(fill="x", pady=(0, 15))

        # تأكيد كلمة المرور
        confirm_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("confirm_password", "Confirm Password"),
            anchor="w"
        )
        confirm_label.pack(fill="x", pady=(0, 5))

        self.confirm_entry = ctk.CTkEntry(
            main_frame,
            show="•",
            height=40
        )
        self.confirm_entry.pack(fill="x", pady=(0, 20))

        # أزرار الإجراءات
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x")

        save_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("save", "Save"),
            command=self._save_password,
            width=100
        )
        save_btn.pack(side="left", padx=(0, 10))

        cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self.destroy,
            width=100,
            fg_color="gray"
        )
        cancel_btn.pack(side="left")

    def _save_password(self):
        """حفظ كلمة المرور الجديدة"""
        current = self.current_entry.get()
        new = self.new_entry.get()
        confirm = self.confirm_entry.get()

        # التحقق من الإدخال
        if not all([current, new, confirm]):
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                self.lang_manager.get("fill_all_fields", "Please fill all fields")
            )
            return

        if new != confirm:
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                self.lang_manager.get("passwords_dont_match", "Passwords do not match")
            )
            return

        if len(new) < 8:
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                self.lang_manager.get("password_too_short", "Password must be at least 8 characters")
            )
            return

        # محاولة تغيير كلمة المرور
        try:
            if hasattr(self.controller, 'user_mgr') and self.controller.user_mgr:
                success = self.controller.user_mgr.change_password(
                    self.controller.current_username,
                    current,
                    new
                )

                if success:
                    messagebox.showinfo(
                        self.lang_manager.get("success", "Success"),
                        self.lang_manager.get("password_changed", "Password changed successfully")
                    )
                    self.destroy()
                else:
                    messagebox.showerror(
                        self.lang_manager.get("error", "Error"),
                        self.lang_manager.get("incorrect_password", "Current password is incorrect")
                    )
            else:
                messagebox.showerror(
                    self.lang_manager.get("error", "Error"),
                    self.lang_manager.get("feature_not_available", "This feature is not available")
                )
        except Exception as e:
            logger.error(f"خطأ في تغيير كلمة المرور: {e}")
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                str(e)
            )


class UpdateEmailDialog(ctk.CTkToplevel):
    """نافذة حوار تحديث البريد الإلكتروني"""

    def __init__(self, parent, controller, lang_manager, current_email):
        super().__init__(parent)

        self.controller = controller
        self.lang_manager = lang_manager
        self.current_email = current_email

        # إعدادات النافذة
        self.title(lang_manager.get("update_email", "Update Email"))
        self.geometry("400x250")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        self._build_ui()
        self._center_window()

    def _center_window(self):
        """توسيط النافذة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _build_ui(self):
        """بناء الواجهة"""
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True, padx=20, pady=20)

        # العنوان
        title_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("update_email", "Update Email"),
            font=ctk.CTkFont(size=20, weight="bold")
        )
        title_label.pack(pady=(0, 20))

        # البريد الحالي
        current_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        current_frame.pack(fill="x", pady=(0, 15))

        current_label = ctk.CTkLabel(
            current_frame,
            text=self.lang_manager.get("current_email", "Current Email:"),
            anchor="w"
        )
        current_label.pack(side="left")

        current_value = ctk.CTkLabel(
            current_frame,
            text=self.current_email or "Not set",
            font=ctk.CTkFont(weight="bold"),
            anchor="w"
        )
        current_value.pack(side="left", padx=(10, 0))

        # البريد الجديد
        new_label = ctk.CTkLabel(
            main_frame,
            text=self.lang_manager.get("new_email", "New Email"),
            anchor="w"
        )
        new_label.pack(fill="x", pady=(0, 5))

        self.email_entry = ctk.CTkEntry(
            main_frame,
            height=40,
            placeholder_text="example@email.com"
        )
        self.email_entry.pack(fill="x", pady=(0, 20))

        # أزرار الإجراءات
        button_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        button_frame.pack(fill="x")

        save_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("save", "Save"),
            command=self._save_email,
            width=100
        )
        save_btn.pack(side="left", padx=(0, 10))

        cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self.destroy,
            width=100,
            fg_color="gray"
        )
        cancel_btn.pack(side="left")

    def _save_email(self):
        """حفظ البريد الإلكتروني الجديد"""
        new_email = self.email_entry.get().strip()

        if not new_email:
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                self.lang_manager.get("enter_email", "Please enter an email address")
            )
            return

        # التحقق من صحة البريد الإلكتروني
        if '@' not in new_email or '.' not in new_email:
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                self.lang_manager.get("invalid_email", "Please enter a valid email address")
            )
            return

        # تحديث البريد في Airtable
        messagebox.showinfo(
            self.lang_manager.get("info", "Information"),
            self.lang_manager.get("email_update_request", "Email update request has been sent to administrator")
        )
        self.destroy()


class SettingsWindow(ctk.CTkToplevel):
    """نافذة الإعدادات المحسنة"""

    def __init__(self, parent, lang_manager, config_manager, theme_manager):
        super().__init__(parent)

        self.lang_manager = lang_manager
        self.config_manager = config_manager
        self.theme_manager = theme_manager

        # إعدادات النافذة
        self.title(lang_manager.get("settings_title", "Settings"))
        self.geometry("600x500")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        # متغيرات الإعدادات
        self.settings_changed = False
        self.temp_settings = {}

        self._build_ui()
        self._center_window()
        self._load_current_settings()

    def _center_window(self):
        """توسيط النافذة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _build_ui(self):
        """بناء واجهة الإعدادات"""
        # الحاوية الرئيسية
        main_container = ctk.CTkFrame(self)
        main_container.pack(fill="both", expand=True)

        # العنوان
        title_frame = ctk.CTkFrame(main_container, height=60)
        title_frame.pack(fill="x")
        title_frame.pack_propagate(False)

        title_label = ctk.CTkLabel(
            title_frame,
            text=self.lang_manager.get("settings_title", "Settings"),
            font=ctk.CTkFont(size=24, weight="bold")
        )
        title_label.pack(expand=True)

        # التبويبات
        self.tabview = ctk.CTkTabview(main_container, width=550, height=350)
        self.tabview.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        # إضافة التبويبات
        self.tabview.add(self.lang_manager.get("appearance", "Appearance"))
        self.tabview.add(self.lang_manager.get("performance", "Performance"))
        self.tabview.add(self.lang_manager.get("advanced", "Advanced"))

        # محتوى التبويبات
        self._create_appearance_tab()
        self._create_performance_tab()
        self._create_advanced_tab()

        # أزرار الإجراءات
        self._create_action_buttons(main_container)

    def _create_appearance_tab(self):
        """إنشاء تبويب المظهر"""
        tab = self.tabview.tab(self.lang_manager.get("appearance", "Appearance"))

        # إطار المحتوى
        content_frame = ctk.CTkScrollableFrame(tab, height=300)
        content_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # 1. إعداد المظهر
        appearance_section = self._create_section(
            content_frame,
            self.lang_manager.get("theme_mode", "Theme Mode")
        )

        self.appearance_var = ctk.StringVar(value=ctk.get_appearance_mode())
        appearance_menu = ctk.CTkOptionMenu(
            appearance_section,
            values=["Light", "Dark", "System"],
            variable=self.appearance_var,
            command=self._on_appearance_change
        )
        appearance_menu.pack(fill="x", pady=5)

        # 2. اللون الأساسي - عرض فقط
        color_section = self._create_section(
            content_frame,
            self.lang_manager.get("primary_color", "Primary Color")
        )

        # عرض الثيم الحالي فقط
        current_theme = self.config_manager.get("color_theme", "blue")
        # تصحيح dark-blue إذا وجد
        if current_theme == "dark-blue":
            current_theme = "blue"

        theme_info_frame = ctk.CTkFrame(color_section, fg_color="transparent")
        theme_info_frame.pack(fill="x", pady=5)

        theme_label = ctk.CTkLabel(
            theme_info_frame,
            text=f"{self.lang_manager.get('current_theme', 'Current Theme')}: ",
            font=ctk.CTkFont(size=13)
        )
        theme_label.pack(side="left")

        theme_value = ctk.CTkLabel(
            theme_info_frame,
            text=current_theme.title(),
            font=ctk.CTkFont(size=13, weight="bold"),
            text_color=("#1976d2", "#64b5f6")
        )
        theme_value.pack(side="left")

        # رسالة معلومات
        info_msg = ctk.CTkLabel(
            color_section,
            text=self.lang_manager.get(
                "theme_info",
                "ℹ️ لتغيير الثيم اللوني، استخدم قائمة المستخدم في الشريط العلوي"
            ),
            font=ctk.CTkFont(size=11),
            text_color=("gray60", "gray40"),
            wraplength=400
        )
        info_msg.pack(fill="x", pady=(10, 0))

        # 3. حجم الخط
        font_section = self._create_section(
            content_frame,
            self.lang_manager.get("font_size", "Font Size")
        )

        self.font_size_var = ctk.DoubleVar(value=self.config_manager.get("font_size", 14))

        # إطار حجم الخط
        font_frame = ctk.CTkFrame(font_section, fg_color="transparent")
        font_frame.pack(fill="x", pady=5)

        font_slider = ctk.CTkSlider(
            font_frame,
            from_=10,
            to=20,
            variable=self.font_size_var,
            command=self._on_font_size_change
        )
        font_slider.pack(side="left", fill="x", expand=True)

        self.font_size_label = ctk.CTkLabel(
            font_frame,
            text=f"{int(self.font_size_var.get())}px",
            width=50
        )
        self.font_size_label.pack(side="left", padx=(10, 0))

        # 4. معاينة
        preview_section = self._create_section(
            content_frame,
            self.lang_manager.get("preview", "Preview")
        )

        self.preview_frame = ctk.CTkFrame(preview_section, height=100)
        self.preview_frame.pack(fill="x", pady=5)

        preview_content = ctk.CTkFrame(self.preview_frame, fg_color="transparent")
        preview_content.pack(expand=True)

        self.preview_label = ctk.CTkLabel(
            preview_content,
            text=self.lang_manager.get("preview_text", "This is a preview of your settings"),
            font=ctk.CTkFont(size=int(self.font_size_var.get()))
        )
        self.preview_label.pack(pady=10)

        # أمثلة أزرار للمعاينة
        preview_buttons = ctk.CTkFrame(preview_content, fg_color="transparent")
        preview_buttons.pack()

        preview_btn1 = ctk.CTkButton(
            preview_buttons,
            text=self.lang_manager.get("sample_button", "Sample Button"),
            width=120,
            height=32
        )
        preview_btn1.pack(side="left", padx=5)

        preview_btn2 = ctk.CTkButton(
            preview_buttons,
            text=self.lang_manager.get("secondary", "Secondary"),
            width=120,
            height=32,
            fg_color="transparent",
            border_width=2
        )
        preview_btn2.pack(side="left", padx=5)

    def _create_performance_tab(self):
        """إنشاء تبويب الأداء"""
        tab = self.tabview.tab(self.lang_manager.get("performance", "Performance"))

        content_frame = ctk.CTkScrollableFrame(tab, height=300)
        content_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # 1. التحميل التلقائي
        auto_refresh_section = self._create_section(
            content_frame,
            self.lang_manager.get("auto_refresh", "Auto Refresh")
        )

        self.auto_refresh_var = ctk.BooleanVar(
            value=self.config_manager.get("auto_refresh", True)
        )
        auto_refresh_switch = ctk.CTkSwitch(
            auto_refresh_section,
            text=self.lang_manager.get("enable_auto_refresh", "Enable automatic data refresh"),
            variable=self.auto_refresh_var,
            command=self._on_setting_change
        )
        auto_refresh_switch.pack(anchor="w", pady=5)

        # 2. فترة التحديث
        refresh_interval_section = self._create_section(
            content_frame,
            self.lang_manager.get("refresh_interval", "Refresh Interval")
        )

        self.refresh_interval_var = ctk.IntVar(
            value=self.config_manager.get("refresh_interval", 300)
        )

        interval_frame = ctk.CTkFrame(refresh_interval_section, fg_color="transparent")
        interval_frame.pack(fill="x", pady=5)

        interval_slider = ctk.CTkSlider(
            interval_frame,
            from_=60,
            to=600,
            variable=self.refresh_interval_var,
            command=self._on_interval_change
        )
        interval_slider.pack(side="left", fill="x", expand=True)

        self.interval_label = ctk.CTkLabel(
            interval_frame,
            text="5 min",
            width=60
        )
        self.interval_label.pack(side="left", padx=(10, 0))

        # 3. عدد السجلات في الصفحة
        page_size_section = self._create_section(
            content_frame,
            self.lang_manager.get("records_per_page", "Records per Page")
        )

        self.page_size_var = ctk.StringVar(
            value=str(self.config_manager.get("records_per_page", 100))
        )
        page_sizes = ["50", "100", "200", "500"]
        page_size_menu = ctk.CTkOptionMenu(
            page_size_section,
            values=page_sizes,
            variable=self.page_size_var,
            command=self._on_setting_change
        )
        page_size_menu.pack(fill="x", pady=5)

        # 4. التحميل الكسول
        lazy_loading_section = self._create_section(
            content_frame,
            self.lang_manager.get("lazy_loading", "Lazy Loading")
        )

        self.lazy_loading_var = ctk.BooleanVar(
            value=self.config_manager.get("enable_lazy_loading", True)
        )
        lazy_loading_switch = ctk.CTkSwitch(
            lazy_loading_section,
            text=self.lang_manager.get("enable_lazy_loading", "Load data on demand"),
            variable=self.lazy_loading_var,
            command=self._on_setting_change
        )
        lazy_loading_switch.pack(anchor="w", pady=5)

    def _create_advanced_tab(self):
        """إنشاء تبويب الإعدادات المتقدمة"""
        tab = self.tabview.tab(self.lang_manager.get("advanced", "Advanced"))

        content_frame = ctk.CTkScrollableFrame(tab, height=300)
        content_frame.pack(fill="both", expand=True, padx=10, pady=10)

        # 1. وضع المطور
        dev_section = self._create_section(
            content_frame,
            self.lang_manager.get("developer_mode", "Developer Mode")
        )

        self.dev_mode_var = ctk.BooleanVar(
            value=self.config_manager.get("developer_mode", False)
        )
        dev_mode_switch = ctk.CTkSwitch(
            dev_section,
            text=self.lang_manager.get("enable_dev_mode", "Show debug information"),
            variable=self.dev_mode_var,
            command=self._on_setting_change
        )
        dev_mode_switch.pack(anchor="w", pady=5)

        # 2. تصدير الإعدادات
        export_section = self._create_section(
            content_frame,
            self.lang_manager.get("export_settings", "Export Settings")
        )

        export_btn = ctk.CTkButton(
            export_section,
            text=self.lang_manager.get("export_to_file", "Export to File"),
            command=self._export_settings,
            width=150
        )
        export_btn.pack(pady=5)

        # 3. استيراد الإعدادات
        import_section = self._create_section(
            content_frame,
            self.lang_manager.get("import_settings", "Import Settings")
        )

        import_btn = ctk.CTkButton(
            import_section,
            text=self.lang_manager.get("import_from_file", "Import from File"),
            command=self._import_settings,
            width=150,
            fg_color="transparent",
            border_width=2
        )
        import_btn.pack(pady=5)

        # 4. إعادة تعيين الإعدادات
        reset_section = self._create_section(
            content_frame,
            self.lang_manager.get("reset_settings", "Reset Settings")
        )

        reset_btn = ctk.CTkButton(
            reset_section,
            text=self.lang_manager.get("reset_to_default", "Reset to Default"),
            command=self._reset_settings,
            width=150,
            fg_color="red",
            hover_color="darkred"
        )
        reset_btn.pack(pady=5)

    def _create_section(self, parent, title):
        """إنشاء قسم في الإعدادات"""
        section_frame = ctk.CTkFrame(parent)
        section_frame.pack(fill="x", pady=(0, 15))

        title_label = ctk.CTkLabel(
            section_frame,
            text=title,
            font=ctk.CTkFont(size=14, weight="bold"),
            anchor="w"
        )
        title_label.pack(fill="x", padx=15, pady=(10, 5))

        content_frame = ctk.CTkFrame(section_frame, fg_color="transparent")
        content_frame.pack(fill="x", padx=15, pady=(0, 10))

        return content_frame

    def _create_action_buttons(self, parent):
        """إنشاء أزرار الإجراءات"""
        button_frame = ctk.CTkFrame(parent, fg_color="transparent", height=50)
        button_frame.pack(fill="x", side="bottom", padx=20, pady=(0, 20))

        # زر الحفظ
        save_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("save_settings", "Save Settings"),
            command=self._save_settings,
            width=120
        )
        save_btn.pack(side="left", padx=(0, 10))

        # زر التطبيق
        apply_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("apply", "Apply"),
            command=self._apply_settings,
            width=120,
            fg_color="green"
        )
        apply_btn.pack(side="left", padx=(0, 10))

        # زر الإلغاء
        cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self._cancel_settings,
            width=120,
            fg_color="gray"
        )
        cancel_btn.pack(side="left")

    def _load_current_settings(self):
        """تحميل الإعدادات الحالية"""
        # المظهر
        current_mode = self.theme_manager.get_current_appearance_mode()
        self.appearance_var.set(current_mode.capitalize())

        # حجم الخط
        font_size = self.config_manager.get("font_size", 14)
        self.font_size_var.set(font_size)
        self._update_font_preview(font_size)

        # الأداء
        self.auto_refresh_var.set(self.config_manager.get("auto_refresh", True))
        self.refresh_interval_var.set(self.config_manager.get("refresh_interval", 300))
        self._update_interval_label(self.refresh_interval_var.get())
        self.page_size_var.set(str(self.config_manager.get("records_per_page", 100)))
        self.lazy_loading_var.set(self.config_manager.get("enable_lazy_loading", True))

        # متقدم
        self.dev_mode_var.set(self.config_manager.get("developer_mode", False))

    def _on_appearance_change(self, choice):
        """معالج تغيير المظهر"""
        self.settings_changed = True
        # معاينة فورية آمنة للـ appearance mode فقط
        try:
            ctk.set_appearance_mode(choice.lower())
        except Exception as e:
            logger.error(f"خطأ في تطبيق وضع المظهر: {e}")

    def _on_color_change(self, choice):
        """معالج تغيير اللون"""
        self.settings_changed = True

        # لا تطبق الثيم مباشرة
        # فقط أظهر رسالة تحذيرية
        if hasattr(self, 'theme_warning_label'):
            self.theme_warning_label.configure(
                text=self.lang_manager.get(
                    "theme_will_apply_on_restart",
                    "⚠️ سيتم تطبيق الثيم بعد إعادة التشغيل"
                )
            )

    def _on_font_size_change(self, value):
        """معالج تغيير حجم الخط"""
        self.settings_changed = True
        self._update_font_preview(int(value))

    def _on_interval_change(self, value):
        """معالج تغيير فترة التحديث"""
        self.settings_changed = True
        self._update_interval_label(int(value))

    def _on_setting_change(self, *args):
        """معالج عام لتغيير الإعدادات"""
        self.settings_changed = True

    def _update_font_preview(self, size):
        """تحديث معاينة حجم الخط"""
        self.font_size_label.configure(text=f"{int(size)}px")
        self.preview_label.configure(font=ctk.CTkFont(size=int(size)))

    def _update_interval_label(self, seconds):
        """تحديث تسمية فترة التحديث"""
        minutes = seconds // 60
        self.interval_label.configure(text=f"{minutes} min")

    def _save_settings(self):
        """حفظ جميع الإعدادات"""
        try:
            # تذكر الثيم القديم للمقارنة
            old_theme = self.config_manager.get("color_theme", "blue")

            # حفظ المظهر
            self.config_manager.set("appearance_mode", self.appearance_var.get().lower())
            self.config_manager.set("font_size", int(self.font_size_var.get()))

            # لا نغير الثيم من هنا لتجنب التجمد
            # new_theme = self.color_var.get()
            # self.config_manager.set("color_theme", new_theme)

            # حفظ الأداء
            self.config_manager.set("auto_refresh", self.auto_refresh_var.get())
            self.config_manager.set("refresh_interval", self.refresh_interval_var.get())
            self.config_manager.set("records_per_page", int(self.page_size_var.get()))
            self.config_manager.set("enable_lazy_loading", self.lazy_loading_var.get())

            # حفظ المتقدم
            self.config_manager.set("developer_mode", self.dev_mode_var.get())

            # تطبيق الإعدادات الآمنة فقط
            self.theme_manager.apply_appearance_mode(self.appearance_var.get().lower())

            # رسالة النجاح
            messagebox.showinfo(
                self.lang_manager.get("success", "Success"),
                self.lang_manager.get("settings_saved", "Settings saved successfully")
            )

            self.settings_changed = False
            self.destroy()

        except Exception as e:
            logger.error(f"خطأ في حفظ الإعدادات: {e}")
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                str(e)
            )

    def _apply_settings(self):
        """تطبيق الإعدادات بدون إغلاق النافذة"""
        self._save_settings()
        self.settings_changed = False

    def _cancel_settings(self):
        """إلغاء التغييرات"""
        if self.settings_changed:
            if messagebox.askyesno(
                self.lang_manager.get("confirm", "Confirm"),
                self.lang_manager.get("discard_changes", "Discard unsaved changes?")
            ):
                # إعادة الإعدادات الأصلية للـ appearance mode فقط
                original_mode = self.config_manager.get("appearance_mode", "light")
                try:
                    self.theme_manager.apply_appearance_mode(original_mode)
                except Exception as e:
                    logger.error(f"خطأ في إعادة وضع المظهر: {e}")
                self.destroy()
        else:
            self.destroy()

    def _export_settings(self):
        """تصدير الإعدادات إلى ملف"""
        file_path = filedialog.asksaveasfilename(
            defaultextension=".json",
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if file_path:
            try:
                settings = self.config_manager.get_all_settings()
                with open(file_path, 'w', encoding='utf-8') as f:
                    json.dump(settings, f, indent=2, ensure_ascii=False)

                messagebox.showinfo(
                    self.lang_manager.get("success", "Success"),
                    self.lang_manager.get("settings_exported", "Settings exported successfully")
                )
            except Exception as e:
                logger.error(f"خطأ في تصدير الإعدادات: {e}")
                messagebox.showerror(
                    self.lang_manager.get("error", "Error"),
                    str(e)
                )

    def _import_settings(self):
        """استيراد الإعدادات من ملف"""
        file_path = filedialog.askopenfilename(
            filetypes=[("JSON files", "*.json"), ("All files", "*.*")]
        )

        if file_path:
            try:
                with open(file_path, 'r', encoding='utf-8') as f:
                    settings = json.load(f)

                # تطبيق الإعدادات
                for key, value in settings.items():
                    self.config_manager.set(key, value)

                messagebox.showinfo(
                    self.lang_manager.get("success", "Success"),
                    self.lang_manager.get("settings_imported", "Settings imported successfully")
                )

                # إعادة تحميل الإعدادات في النافذة
                self._load_current_settings()

            except Exception as e:
                logger.error(f"خطأ في استيراد الإعدادات: {e}")
                messagebox.showerror(
                    self.lang_manager.get("error", "Error"),
                    str(e)
                )

    def _reset_settings(self):
        """إعادة تعيين الإعدادات إلى القيم الافتراضية"""
        if messagebox.askyesno(
            self.lang_manager.get("confirm", "Confirm"),
            self.lang_manager.get("confirm_reset", "Reset all settings to default values?")
        ):
            try:
                # حذف ملف الإعدادات
                if os.path.exists("config/settings.yaml"):
                    os.remove("config/settings.yaml")

                # إعادة تحميل الإعدادات الافتراضية
                self.config_manager.reload()

                messagebox.showinfo(
                    self.lang_manager.get("success", "Success"),
                    self.lang_manager.get("settings_reset", "Settings reset to default")
                )

                self.destroy()

            except Exception as e:
                logger.error(f"خطأ في إعادة تعيين الإعدادات: {e}")
                messagebox.showerror(
                    self.lang_manager.get("error", "Error"),
                    str(e)
                )


class LanguageWindow(ctk.CTkToplevel):
    """نافذة اختيار اللغة المحسنة"""

    def __init__(self, parent, lang_manager, language_callback):
        super().__init__(parent)

        self.lang_manager = lang_manager
        self.language_callback = language_callback

        # إعدادات النافذة
        self.title(lang_manager.get("language_title", "Select Language"))
        self.geometry("350x500")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        self._build_ui()
        self._center_window()

    def _center_window(self):
        """توسيط النافذة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _build_ui(self):
        """بناء واجهة اختيار اللغة"""
        # العنوان
        title_frame = ctk.CTkFrame(self, height=80)
        title_frame.pack(fill="x")
        title_frame.pack_propagate(False)

        title_label = ctk.CTkLabel(
            title_frame,
            text=self.lang_manager.get("language_title", "Select Language"),
            font=ctk.CTkFont(size=22, weight="bold")
        )
        title_label.pack(expand=True)

        # الوصف
        desc_label = ctk.CTkLabel(
            self,
            text=self.lang_manager.get("language_desc", "Choose your preferred language"),
            font=ctk.CTkFont(size=12),
            text_color=("gray60", "gray40")
        )
        desc_label.pack(pady=(0, 20))

        # قائمة اللغات المتاحة من ملفات الترجمة
        languages = self._get_available_languages()

        # إطار اللغات
        lang_frame = ctk.CTkScrollableFrame(self, height=280)
        lang_frame.pack(fill="both", expand=True, padx=20, pady=(0, 20))

        self.selected_lang = ctk.StringVar(value=self.lang_manager.current_lang)

        for code, name, flag, native_name in languages:
            self._create_language_option(lang_frame, code, name, flag, native_name)

        # أزرار الإجراءات
        button_frame = ctk.CTkFrame(self, fg_color="transparent", height=60)
        button_frame.pack(fill="x", side="bottom", padx=20, pady=(0, 20))

        apply_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("apply", "Apply"),
            command=self._apply_language,
            width=100
        )
        apply_btn.pack(side="left", padx=(0, 10))

        cancel_btn = ctk.CTkButton(
            button_frame,
            text=self.lang_manager.get("cancel", "Cancel"),
            command=self.destroy,
            width=100,
            fg_color="gray"
        )
        cancel_btn.pack(side="left")

    def _get_available_languages(self):
        """الحصول على اللغات المتاحة من مجلد locales"""
        languages = []

        # اللغات الافتراضية
        default_languages = [
            ("ar", "Arabic", "🇸🇦", "العربية"),
            ("en", "English", "🇬🇧", "English")
        ]

        # البحث في مجلد locales
        locales_dir = "locales"
        if os.path.exists(locales_dir):
            for file in os.listdir(locales_dir):
                if file.endswith('.yaml'):
                    lang_code = file.replace('.yaml', '')

                    # البحث عن معلومات اللغة في القائمة الافتراضية
                    for code, name, flag, native in default_languages:
                        if code == lang_code:
                            languages.append((code, name, flag, native))
                            break

        # إذا لم نجد أي لغات، استخدم الافتراضية
        if not languages:
            languages = default_languages[:2]  # العربية والإنجليزية فقط

        return languages

    def _create_language_option(self, parent, code, name, flag, native_name):
        """إنشاء خيار لغة"""
        option_frame = ctk.CTkFrame(parent, height=60)
        option_frame.pack(fill="x", pady=5)

        # زر الاختيار
        radio_btn = ctk.CTkRadioButton(
            option_frame,
            text="",
            variable=self.selected_lang,
            value=code,
            width=20
        )
        radio_btn.pack(side="left", padx=(15, 10))

        # العلم
        flag_label = ctk.CTkLabel(
            option_frame,
            text=flag,
            font=ctk.CTkFont(size=24)
        )
        flag_label.pack(side="left", padx=(0, 10))

        # معلومات اللغة
        info_frame = ctk.CTkFrame(option_frame, fg_color="transparent")
        info_frame.pack(side="left", fill="both", expand=True)

        # اسم اللغة بالإنجليزية
        name_label = ctk.CTkLabel(
            info_frame,
            text=name,
            font=ctk.CTkFont(size=14, weight="bold"),
            anchor="w"
        )
        name_label.pack(fill="x", pady=(10, 2))

        # اسم اللغة الأصلي
        native_label = ctk.CTkLabel(
            info_frame,
            text=native_name,
            font=ctk.CTkFont(size=12),
            text_color=("gray60", "gray40"),
            anchor="w"
        )
        native_label.pack(fill="x", pady=(0, 10))

        # تحديد اللغة الحالية
        if code == self.lang_manager.current_lang:
            current_label = ctk.CTkLabel(
                option_frame,
                text=self.lang_manager.get("current", "Current"),
                font=ctk.CTkFont(size=11),
                text_color="green"
            )
            current_label.pack(side="right", padx=15)

    def _apply_language(self):
        """تطبيق اللغة المختارة"""
        new_lang = self.selected_lang.get()
        if new_lang != self.lang_manager.current_lang:
            self.language_callback(new_lang)
        self.destroy()


class AboutWindow(ctk.CTkToplevel):
    """نافذة حول التطبيق المحسنة"""

    def __init__(self, parent, lang_manager):
        super().__init__(parent)

        self.lang_manager = lang_manager

        # إعدادات النافذة
        self.title(lang_manager.get("about", "About"))
        self.geometry("450x550")
        self.resizable(False, False)

        # جعل النافذة مشروطة
        self.transient(parent)
        self.grab_set()

        self._build_ui()
        self._center_window()

    def _center_window(self):
        """توسيط النافذة"""
        self.update_idletasks()
        width = self.winfo_width()
        height = self.winfo_height()
        x = (self.winfo_screenwidth() // 2) - (width // 2)
        y = (self.winfo_screenheight() // 2) - (height // 2)
        self.geometry(f"{width}x{height}+{x}+{y}")

    def _build_ui(self):
        """بناء واجهة حول التطبيق"""
        # الحاوية الرئيسية
        main_frame = ctk.CTkFrame(self)
        main_frame.pack(fill="both", expand=True)

        # الشعار والعنوان
        logo_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        logo_frame.pack(pady=30)

        # خلفية دائرية للشعار
        logo_bg = ctk.CTkFrame(
            logo_frame,
            width=100,
            height=100,
            corner_radius=50,
            fg_color=("#1f538d", "#4a9eff")
        )
        logo_bg.pack()
        logo_bg.pack_propagate(False)

        logo_text = ctk.CTkLabel(
            logo_bg,
            text="FTS",
            font=ctk.CTkFont(size=36, weight="bold"),
            text_color="white"
        )
        logo_text.place(relx=0.5, rely=0.5, anchor="center")

        # اسم التطبيق
        app_name = ctk.CTkLabel(
            main_frame,
            text="FTS TRAVELS",
            font=ctk.CTkFont(size=28, weight="bold"),
            text_color=("#1f538d", "#4a9eff")
        )
        app_name.pack()

        app_subtitle = ctk.CTkLabel(
            main_frame,
            text="Sales Manager",
            font=ctk.CTkFont(size=16),
            text_color=("gray60", "gray40")
        )
        app_subtitle.pack(pady=(0, 20))

        # معلومات الإصدار
        version_frame = ctk.CTkFrame(main_frame)
        version_frame.pack(fill="x", padx=40, pady=10)

        info_items = [
            ("version", "Version", "2.0.0"),
            ("build", "Build", "2024.01.15"),
            ("developer", "Developer", "FTS Development Team"),
            ("license", "License", "Proprietary")
        ]

        for key, label, value in info_items:
            row_frame = ctk.CTkFrame(version_frame, fg_color="transparent")
            row_frame.pack(fill="x", pady=5)

            label_widget = ctk.CTkLabel(
                row_frame,
                text=f"{self.lang_manager.get(key, label)}:",
                font=ctk.CTkFont(weight="bold"),
                anchor="w",
                width=100
            )
            label_widget.pack(side="left", padx=(20, 10))

            value_widget = ctk.CTkLabel(
                row_frame,
                text=value,
                anchor="w"
            )
            value_widget.pack(side="left")

        # الوصف
        desc_frame = ctk.CTkFrame(main_frame)
        desc_frame.pack(fill="x", padx=40, pady=20)

        description = self.lang_manager.get(
            "app_description",
            "FTS Travels Sales Manager is an integrated system for managing tourism sales and bookings.\n\n"
            "The system provides powerful tools for managing customers, bookings, and financial reports."
        )

        desc_label = ctk.CTkLabel(
            desc_frame,
            text=description,
            justify="center",
            wraplength=350,
            font=ctk.CTkFont(size=12)
        )
        desc_label.pack(pady=20)

        # روابط
        links_frame = ctk.CTkFrame(main_frame, fg_color="transparent")
        links_frame.pack(pady=10)

        website_btn = ctk.CTkButton(
            links_frame,
            text="🌐 " + self.lang_manager.get("website", "Website"),
            width=120,
            command=lambda: webbrowser.open("https://www.ftstravels.com")
        )
        website_btn.pack(side="left", padx=5)

        support_btn = ctk.CTkButton(
            links_frame,
            text="📧 " + self.lang_manager.get("support", "Support"),
            width=120,
            command=lambda: webbrowser.open("mailto:support@ftstravels.com")
        )
        support_btn.pack(side="left", padx=5)

        # حقوق النشر
        copyright_label = ctk.CTkLabel(
            main_frame,
            text="© 2024 FTS - All Rights Reserved",
            font=ctk.CTkFont(size=10),
            text_color=("gray60", "gray40")
        )
        copyright_label.pack(pady=(20, 0))

        # زر الإغلاق
        close_btn = ctk.CTkButton(
            main_frame,
            text=self.lang_manager.get("close", "Close"),
            command=self.destroy,
            width=120
        )
        close_btn.pack(pady=20)

============================================================
FILE: views\components\header.py
SIZE: 28565 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/header.py

مكون الهيدر العلوي المحسن بتصميم احترافي
"""

import customtkinter as ctk
import tkinter as tk
from typing import Callable, Dict, Any, Optional
import webbrowser
from datetime import datetime
import weakref

from core.language_manager import LanguageManager
from core.logger import logger

# استيراد نوافذ الحوار المحدثة
from .dropdown_dialogs import (
    ProfileWindow,
    SettingsWindow,
    LanguageWindow,
    AboutWindow
)


class DropdownMenu(ctk.CTkToplevel):
    """قائمة منسدلة احترافية مع تأثيرات بصرية وإدارة محسّنة للذاكرة"""

    def __init__(self, parent, x, y, lang_manager, header_component, **kwargs):
        super().__init__(parent, **kwargs)

        self.lang_manager = lang_manager
        # استخدام weakref لتجنب المراجع الدائرية
        self.header_component_ref = weakref.ref(header_component)
        self._after_ids = []  # لتتبع جميع after callbacks
        self._fade_out_id = None

        # إعدادات النافذة
        self.overrideredirect(True)
        self.attributes("-topmost", True)

        # تأثير الشفافية
        self.attributes("-alpha", 0.0)

        # الموضع
        self.geometry(f"+{x}+{y}")

        # الإطار الرئيسي مع ظل
        self.shadow_frame = ctk.CTkFrame(
            self,
            corner_radius=12,
            fg_color=("#000000", "#000000"),
            bg_color="transparent"
        )
        self.shadow_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # الإطار الرئيسي
        self.main_frame = ctk.CTkFrame(
            self.shadow_frame,
            corner_radius=10,
            fg_color=("#ffffff", "#2b2b2b"),
            border_width=1,
            border_color=("#e0e0e0", "#444444")
        )
        self.main_frame.pack(fill="both", expand=True, padx=1, pady=1)

        # بناء العناصر
        self._build_items()

        # تأثير الظهور التدريجي
        self._fade_in()

        # ربط النقر خارج القائمة لإغلاقها
        self.bind("<FocusOut>", lambda e: self._start_fade_out())

        # ربط حركة الماوس للتأثيرات
        self.bind("<Leave>", lambda e: self._start_fade_out())
        self.bind("<Enter>", lambda e: self._cancel_fade_out())

        # تسجيل callback للتنظيف عند الإغلاق
        self.protocol("WM_DELETE_WINDOW", self._cleanup_and_destroy)

    def _fade_in(self):
        """تأثير الظهور التدريجي"""
        try:
            if not self.winfo_exists():
                return

            alpha = float(self.attributes("-alpha"))
            if alpha < 0.95:
                self.attributes("-alpha", alpha + 0.1)
                after_id = self.after(10, self._fade_in)
                self._after_ids.append(after_id)
        except (tk.TclError, AttributeError):
            # النافذة تم إغلاقها
            pass

    def _fade_out(self):
        """تأثير الاختفاء التدريجي"""
        try:
            if not self.winfo_exists():
                return

            alpha = float(self.attributes("-alpha"))
            if alpha > 0.1:
                self.attributes("-alpha", alpha - 0.1)
                after_id = self.after(10, self._fade_out)
                self._after_ids.append(after_id)
            else:
                self._cleanup_and_destroy()
        except (tk.TclError, AttributeError):
            # النافذة تم إغلاقها
            self._cleanup_and_destroy()

    def _start_fade_out(self):
        """بدء الاختفاء بعد تأخير"""
        try:
            if self._fade_out_id:
                self.after_cancel(self._fade_out_id)

            self._fade_out_id = self.after(200, self._check_mouse_position)
            self._after_ids.append(self._fade_out_id)
        except tk.TclError:
            pass

    def _cancel_fade_out(self):
        """إلغاء الاختفاء"""
        try:
            if self._fade_out_id:
                self.after_cancel(self._fade_out_id)
                self._fade_out_id = None
        except tk.TclError:
            pass

    def _check_mouse_position(self):
        """التحقق من موضع الماوس"""
        try:
            if not self.winfo_exists():
                return

            # الحصول على موضع الماوس
            x = self.winfo_pointerx()
            y = self.winfo_pointery()

            # الحصول على حدود النافذة
            x1 = self.winfo_rootx()
            y1 = self.winfo_rooty()
            x2 = x1 + self.winfo_width()
            y2 = y1 + self.winfo_height()

            # التحقق من الموضع
            if not (x1 <= x <= x2 and y1 <= y <= y2):
                self._fade_out()
            else:
                self._start_fade_out()

        except (tk.TclError, AttributeError):
            # النافذة تم إغلاقها
            self._cleanup_and_destroy()

    def _cleanup_and_destroy(self):
        """تنظيف الموارد وإغلاق النافذة"""
        try:
            # إلغاء جميع after callbacks
            for after_id in self._after_ids:
                try:
                    self.after_cancel(after_id)
                except:
                    pass

            # إلغاء fade_out_id إن وجد
            if self._fade_out_id:
                try:
                    self.after_cancel(self._fade_out_id)
                except:
                    pass

            # تدمير النافذة
            if self.winfo_exists():
                self.destroy()

        except:
            # تجاهل أي أخطاء في التنظيف
            pass

    def _build_items(self):
        """بناء عناصر القائمة بتصميم احترافي"""
        header_component = self.header_component_ref()
        if not header_component:
            return

        # رأس القائمة مع معلومات المستخدم
        header_frame = ctk.CTkFrame(
            self.main_frame,
            fg_color=("#f8f9fa", "#1e1e1e"),
            corner_radius=10
        )
        header_frame.pack(fill="x", padx=10, pady=10)

        # صورة المستخدم (placeholder)
        user_avatar = ctk.CTkLabel(
            header_frame,
            text="👤",
            font=ctk.CTkFont(size=40),
            width=60,
            height=60,
            fg_color=("#e0e0e0", "#3a3a3a"),
            corner_radius=30
        )
        user_avatar.pack(pady=10)

        # اسم المستخدم
        username = header_component.user_record.get('fields', {}).get('Username', 'User')
        user_label = ctk.CTkLabel(
            header_frame,
            text=username,
            font=ctk.CTkFont(size=16, weight="bold")
        )
        user_label.pack()

        # الدور
        role = header_component.user_record.get('fields', {}).get('Role', '')
        if role:
            role_label = ctk.CTkLabel(
                header_frame,
                text=header_component._translate_role(role),
                font=ctk.CTkFont(size=12),
                text_color=("#666666", "#999999")
            )
            role_label.pack(pady=(0, 10))

        # خط فاصل أنيق
        separator = ctk.CTkFrame(
            self.main_frame,
            height=1,
            fg_color=("#e0e0e0", "#444444")
        )
        separator.pack(fill="x", padx=15, pady=5)

        # عناصر القائمة
        items = [
            ("👤", "profile", self._on_profile, "primary"),
            ("⚙️", "settings", self._on_settings, "default"),
            ("🌐", "language", self._on_language, "default"),
            ("ℹ️", "about", self._on_about, "default"),
            ("separator", None, None, None),
            ("🚪", "logout", self._on_logout, "danger")
        ]

        # إطار العناصر
        items_frame = ctk.CTkFrame(
            self.main_frame,
            fg_color="transparent"
        )
        items_frame.pack(fill="both", expand=True, padx=5, pady=5)

        for icon, key, command, style in items:
            if icon == "separator":
                separator = ctk.CTkFrame(
                    items_frame,
                    height=1,
                    fg_color=("#e0e0e0", "#444444")
                )
                separator.pack(fill="x", padx=10, pady=8)
            else:
                self._create_menu_item(items_frame, icon, key, command, style)

    def _create_menu_item(self, parent, icon, key, command, style):
        """إنشاء عنصر قائمة احترافي"""
        text = self.lang_manager.get(f"menu_{key}", key.title())

        # إطار العنصر
        item_frame = ctk.CTkFrame(
            parent,
            height=40,
            fg_color="transparent",
            corner_radius=8
        )
        item_frame.pack(fill="x", padx=5, pady=2)

        # تحديد الألوان حسب النمط
        if style == "primary":
            hover_color = ("#e3f2fd", "#1976d2")
            text_color = ("#1976d2", "#90caf9")
        elif style == "danger":
            hover_color = ("#ffebee", "#b71c1c")
            text_color = ("#d32f2f", "#ff5252")
        else:
            hover_color = ("#f5f5f5", "#3a3a3a")
            text_color = ("#333333", "#ffffff")

        # الزر
        btn = ctk.CTkButton(
            item_frame,
            text=f"{icon}  {text}",
            anchor="w",
            height=36,
            fg_color="transparent",
            hover_color=hover_color,
            text_color=text_color,
            font=ctk.CTkFont(size=13),
            command=command,
            corner_radius=8
        )
        btn.pack(fill="both", expand=True)

        # تأثير hover إضافي
        def on_enter(e):
            btn.configure(font=ctk.CTkFont(size=13, weight="bold"))

        def on_leave(e):
            btn.configure(font=ctk.CTkFont(size=13))

        btn.bind("<Enter>", on_enter)
        btn.bind("<Leave>", on_leave)

    def _on_profile(self):
        """معالج الملف الشخصي"""
        self._cleanup_and_destroy()
        header_component = self.header_component_ref()
        if not header_component:
            return

        controller = header_component.controller
        if controller:
            profile_window = ProfileWindow(
                header_component.winfo_toplevel(),
                controller,
                self.lang_manager
            )
        else:
            logger.error("لا يمكن فتح نافذة الملف الشخصي - المتحكم غير متاح")

    def _on_settings(self):
        """معالج الإعدادات"""
        self._cleanup_and_destroy()
        header_component = self.header_component_ref()
        if not header_component:
            return

        controller = header_component.controller
        if controller and hasattr(controller, 'config_mgr') and hasattr(controller, 'theme_manager'):
            settings_window = SettingsWindow(
                header_component.winfo_toplevel(),
                self.lang_manager,
                controller.config_mgr,
                controller.theme_manager
            )
        else:
            logger.error("لا يمكن فتح نافذة الإعدادات - المتحكم غير متاح")

    def _on_language(self):
        """معالج تغيير اللغة"""
        self._cleanup_and_destroy()
        header_component = self.header_component_ref()
        if not header_component:
            return

        def change_language(new_lang):
            if hasattr(header_component, 'on_language_change'):
                header_component.on_language_change(new_lang)
            else:
                self.lang_manager.set_language(new_lang)
                header_component.update_texts(self.lang_manager)

        language_window = LanguageWindow(
            header_component.winfo_toplevel(),
            self.lang_manager,
            change_language
        )

    def _on_about(self):
        """معالج حول التطبيق"""
        self._cleanup_and_destroy()
        header_component = self.header_component_ref()
        if not header_component:
            return

        about_window = AboutWindow(
            header_component.winfo_toplevel(),
            self.lang_manager
        )

    def _on_logout(self):
        """معالج تسجيل الخروج"""
        self._cleanup_and_destroy()
        header_component = self.header_component_ref()
        if not header_component:
            return

        from tkinter import messagebox
        if messagebox.askyesno(
            self.lang_manager.get("confirm", "Confirm"),
            self.lang_manager.get("confirm_logout", "Are you sure you want to logout?")
        ):
            logger.info("بدء عملية تسجيل الخروج...")

            controller = header_component.controller
            if controller:
                try:
                    if hasattr(controller, 'save_current_state'):
                        controller.save_current_state()

                    if hasattr(controller, 'cleanup'):
                        controller.cleanup()

                    if hasattr(controller, 'on_logout'):
                        controller.on_logout()

                    main_window = header_component.winfo_toplevel()
                    main_window.destroy()

                    if hasattr(controller, 'run'):
                        controller.run()

                except Exception as e:
                    logger.error(f"خطأ في تسجيل الخروج: {e}")
                    messagebox.showerror(
                        self.lang_manager.get("error", "Error"),
                        self.lang_manager.get("logout_error", "An error occurred during logout")
                    )
            else:
                header_component.winfo_toplevel().destroy()


class HeaderComponent(ctk.CTkFrame):
    """مكون الهيدر المحسن بتصميم احترافي"""

    def __init__(
        self,
        parent,
        lang_manager: LanguageManager,
        user_record: Dict[str, Any],
        on_search: Callable = None,
        on_refresh: Callable = None,
        on_menu_click: Callable = None,
        on_language_change: Callable = None,
        on_theme_change: Callable = None,
        controller: Any = None,
        **kwargs
    ):
        # إعدادات احترافية للإطار
        kwargs.setdefault('height', 80)
        kwargs.setdefault('corner_radius', 0)
        kwargs.setdefault('fg_color', ("#ffffff", "#2b2b2b"))

        super().__init__(parent, **kwargs)
        self.pack_propagate(False)

        self.lang_manager = lang_manager
        self.user_record = user_record
        self.on_search = on_search
        self.on_refresh = on_refresh
        self.on_language_change = on_language_change
        self.on_theme_change = on_theme_change
        self.controller = controller

        # متغير للقائمة المنسدلة
        self.dropdown_menu: Optional[DropdownMenu] = None

        # إطار الجانب الأيمن للأزرار الإضافية
        self.right_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.right_frame.pack(side="right", fill="y", padx=20)

        self._build_ui()

    def change_theme_with_restart(self, new_theme):
        """تغيير الثيم مع طلب إعادة التشغيل"""
        try:
            # حفظ الثيم الجديد
            self.controller.config_mgr.set("color_theme", new_theme)

            # عرض رسالة
            result = messagebox.askyesno(
                self.lang_manager.get("restart_required", "Restart Required"),
                self.lang_manager.get(
                    "restart_to_apply_theme",
                    f"تم حفظ الثيم '{new_theme}'.\n\n"
                    "يجب إعادة تشغيل التطبيق لتطبيق التغييرات.\n"
                    "هل تريد إعادة التشغيل الآن؟"
                )
            )

            if result:
                # إعادة تشغيل التطبيق
                import sys
                import os
                python = sys.executable
                os.execl(python, python, *sys.argv)

        except Exception as e:
            logger.error(f"خطأ في تغيير الثيم: {e}")
            messagebox.showerror(
                self.lang_manager.get("error", "Error"),
                str(e)
            )

    def _build_ui(self):
        """بناء الواجهة المحسنة"""
        # الشعار المحسن
        self._create_enhanced_logo()

        # شريط البحث المحسن
        self._create_enhanced_search_bar()

        # منطقة المستخدم المحسنة
        self._create_enhanced_user_area()

    def _create_enhanced_logo(self):
        """إنشاء شعار محسن احترافي"""
        # إطار الشعار
        logo_frame = ctk.CTkFrame(
            self,
            width=200,
            fg_color="transparent"
        )
        logo_frame.pack(side="left", fill="y", padx=(20, 10))
        logo_frame.pack_propagate(False)

        # إطار محتوى الشعار
        logo_content = ctk.CTkFrame(logo_frame, fg_color="transparent")
        logo_content.pack(expand=True)

        # إطار الأيقونة والنص
        logo_inner = ctk.CTkFrame(logo_content, fg_color="transparent")
        logo_inner.pack()

        # أيقونة الشركة
        logo_icon_bg = ctk.CTkFrame(
            logo_inner,
            width=50,
            height=50,
            corner_radius=25,
            fg_color=("#1976d2", "#2196f3")
        )
        logo_icon_bg.pack(side="left", padx=(0, 10))
        logo_icon_bg.pack_propagate(False)

        logo_icon = ctk.CTkLabel(
            logo_icon_bg,
            text="FTS",
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color="white"
        )
        logo_icon.place(relx=0.5, rely=0.5, anchor="center")

        # نصوص الشعار
        text_frame = ctk.CTkFrame(logo_inner, fg_color="transparent")
        text_frame.pack(side="left")

        # النص الرئيسي
        main_text = ctk.CTkLabel(
            text_frame,
            text="FTS TRAVELS",
            font=ctk.CTkFont(size=22, weight="bold"),
            text_color=("#1976d2", "#2196f3")
        )
        main_text.pack(anchor="w")

        # النص الفرعي
        sub_text = ctk.CTkLabel(
            text_frame,
            text="Sales Manager Pro",
            font=ctk.CTkFont(size=11),
            text_color=("#666666", "#999999")
        )
        sub_text.pack(anchor="w", pady=(0, 2))

    def _create_enhanced_search_bar(self):
        """إنشاء شريط بحث محسن احترافي"""
        search_container = ctk.CTkFrame(self, fg_color="transparent")
        search_container.pack(side="left", fill="both", expand=True, padx=20)

        # إطار البحث الرئيسي
        search_frame = ctk.CTkFrame(
            search_container,
            height=45,
            fg_color=("#f5f5f5", "#333333"),
            corner_radius=25,
            border_width=2,
            border_color=("#e0e0e0", "#444444")
        )
        search_frame.pack(expand=True, fill="x", pady=15)
        search_frame.pack_propagate(False)

        # أيقونة البحث
        search_icon = ctk.CTkLabel(
            search_frame,
            text="🔍",
            font=ctk.CTkFont(size=18),
            text_color=("#666666", "#999999")
        )
        search_icon.pack(side="left", padx=(15, 5))

        # حقل البحث
        self.search_var = ctk.StringVar()
        self.search_entry = ctk.CTkEntry(
            search_frame,
            textvariable=self.search_var,
            placeholder_text=self.lang_manager.get("search_placeholder", "Search bookings..."),
            border_width=0,
            fg_color="transparent",
            font=ctk.CTkFont(size=14),
            height=40
        )
        self.search_entry.pack(side="left", fill="both", expand=True, padx=(5, 10))

        # أزرار الإجراءات
        actions_frame = ctk.CTkFrame(search_frame, fg_color="transparent")
        actions_frame.pack(side="right", padx=(0, 10))

        # زر البحث
        search_btn = ctk.CTkButton(
            actions_frame,
            text="",
            image=None,  # يمكن إضافة أيقونة هنا
            width=35,
            height=35,
            corner_radius=17,
            fg_color=("#1976d2", "#2196f3"),
            hover_color=("#1565c0", "#1e88e5"),
            command=self._on_search
        )
        search_btn.pack(side="left", padx=2)

        # أيقونة البحث للزر
        search_btn_icon = ctk.CTkLabel(
            search_btn,
            text="→",
            font=ctk.CTkFont(size=16, weight="bold"),
            text_color="white"
        )
        search_btn_icon.place(relx=0.5, rely=0.5, anchor="center")

        # زر المسح
        if self.search_var.get():
            clear_btn = ctk.CTkButton(
                actions_frame,
                text="✕",
                width=30,
                height=30,
                corner_radius=15,
                fg_color="transparent",
                hover_color=("#e0e0e0", "#444444"),
                text_color=("#666666", "#999999"),
                command=self.clear_search
            )
            clear_btn.pack(side="left", padx=2)

        # زر التحديث
        if self.on_refresh:
            refresh_btn = ctk.CTkButton(
                actions_frame,
                text="↻",
                width=35,
                height=35,
                corner_radius=17,
                fg_color="transparent",
                hover_color=("#e0e0e0", "#444444"),
                text_color=("#666666", "#999999"),
                font=ctk.CTkFont(size=18),
                command=self.on_refresh
            )
            refresh_btn.pack(side="left", padx=2)

        # ربط Enter بالبحث
        self.search_entry.bind("<Return>", lambda e: self._on_search())

        # تحديث زر المسح عند الكتابة
        self.search_var.trace("w", self._update_clear_button)

    def _update_clear_button(self, *args):
        """تحديث ظهور زر المسح"""
        # يمكن تنفيذ منطق إظهار/إخفاء زر المسح هنا
        pass

    def _create_enhanced_user_area(self):
        """إنشاء منطقة مستخدم محسنة احترافية"""
        user_container = ctk.CTkFrame(self.right_frame, fg_color="transparent")
        user_container.pack(side="left", fill="y")

        # إطار معلومات المستخدم
        user_info_frame = ctk.CTkFrame(
            user_container,
            fg_color=("#f8f9fa", "#1e1e1e"),
            corner_radius=25,
            border_width=1,
            border_color=("#e0e0e0", "#444444")
        )
        user_info_frame.pack(side="left", padx=10, pady=15)

        # إطار المحتوى
        content_frame = ctk.CTkFrame(user_info_frame, fg_color="transparent")
        content_frame.pack(padx=15, pady=8)

        # صورة المستخدم
        avatar_frame = ctk.CTkFrame(
            content_frame,
            width=40,
            height=40,
            corner_radius=20,
            fg_color=("#e0e0e0", "#3a3a3a")
        )
        avatar_frame.pack(side="left", padx=(0, 10))
        avatar_frame.pack_propagate(False)

        avatar_label = ctk.CTkLabel(
            avatar_frame,
            text="👤",
            font=ctk.CTkFont(size=20)
        )
        avatar_label.place(relx=0.5, rely=0.5, anchor="center")

        # معلومات المستخدم
        info_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        info_frame.pack(side="left", padx=(0, 10))

        # اسم المستخدم
        username = self.user_record.get('fields', {}).get('Username', 'User')
        username_label = ctk.CTkLabel(
            info_frame,
            text=username,
            font=ctk.CTkFont(size=14, weight="bold"),
            text_color=("#333333", "#ffffff")
        )
        username_label.pack(anchor="w")

        # الدور
        role = self.user_record.get('fields', {}).get('Role', '')
        if role:
            role_text = self._translate_role(role)
            self.role_label = ctk.CTkLabel(
                info_frame,
                text=role_text,
                font=ctk.CTkFont(size=11),
                text_color=("#666666", "#999999")
            )
            self.role_label.pack(anchor="w")

        # زر القائمة المحسن
        self.menu_btn = ctk.CTkButton(
            content_frame,
            text="▼",
            width=30,
            height=30,
            corner_radius=15,
            fg_color="transparent",
            hover_color=("#e0e0e0", "#444444"),
            text_color=("#666666", "#999999"),
            font=ctk.CTkFont(size=12),
            command=self._toggle_dropdown_menu
        )
        self.menu_btn.pack(side="left")

        # تأثير hover للإطار الكامل
        def on_enter(e):
            user_info_frame.configure(border_color=("#1976d2", "#2196f3"))

        def on_leave(e):
            user_info_frame.configure(border_color=("#e0e0e0", "#444444"))

        user_info_frame.bind("<Enter>", on_enter)
        user_info_frame.bind("<Leave>", on_leave)

        # جعل الإطار كله قابل للنقر
        for widget in [user_info_frame, content_frame, info_frame, username_label]:
            widget.bind("<Button-1>", lambda e: self._toggle_dropdown_menu())

    def _toggle_dropdown_menu(self):
        """إظهار/إخفاء القائمة المنسدلة"""
        if self.dropdown_menu and hasattr(self.dropdown_menu, 'winfo_exists'):
            try:
                if self.dropdown_menu.winfo_exists():
                    self.dropdown_menu._cleanup_and_destroy()
                    self.dropdown_menu = None
                    return
            except:
                self.dropdown_menu = None

        # حساب موضع القائمة
        x = self.menu_btn.winfo_rootx() - 150
        y = self.menu_btn.winfo_rooty() + self.menu_btn.winfo_height() + 10

        # إنشاء القائمة المنسدلة
        self.dropdown_menu = DropdownMenu(
            self,
            x,
            y,
            self.lang_manager,
            self
        )

    def _translate_role(self, role):
        """ترجمة الدور"""
        return self.lang_manager.get(f"role_{role.lower()}", role)

    def _on_search(self):
        """معالج البحث"""
        if self.on_search:
            search_text = self.search_var.get().strip()
            self.on_search(search_text)

    def clear_search(self):
        """مسح البحث"""
        self.search_var.set("")
        if self.on_search:
            self.on_search("")

    def update_texts(self, lang_manager):
        """تحديث نصوص المكون"""
        self.lang_manager = lang_manager

        # تحديث placeholder البحث
        if hasattr(self, 'search_entry'):
            self.search_entry.configure(
                placeholder_text=lang_manager.get("search_placeholder", "Search bookings...")
            )

        # تحديث دور المستخدم
        if hasattr(self, 'role_label'):
            role = self.user_record.get('fields', {}).get('Role', '')
            if role:
                role_text = self._translate_role(role)
                self.role_label.configure(text=role_text)

    def refresh_theme(self):
        """تحديث الثيم"""
        # تحديث ألوان الإطار الرئيسي
        self.configure(fg_color=("#ffffff", "#2b2b2b"))

        # تحديث شريط البحث
        if hasattr(self, 'search_frame'):
            search_frame = self.search_entry.master
            if search_frame:
                search_frame.configure(
                    fg_color=("#f5f5f5", "#333333"),
                    border_color=("#e0e0e0", "#444444")
                )

        # تحديث منطقة المستخدم
        if hasattr(self, 'user_info_frame'):
            for widget in self.right_frame.winfo_children():
                if isinstance(widget, ctk.CTkFrame):
                    widget.configure(
                        fg_color=("#f8f9fa", "#1e1e1e"),
                        border_color=("#e0e0e0", "#444444")
                    )

        # إغلاق القائمة المنسدلة إذا كانت مفتوحة
        if self.dropdown_menu and self.dropdown_menu.winfo_exists():
            self.dropdown_menu.destroy()
            self.dropdown_menu = None

    def _cleanup(self):
        """تنظيف الموارد"""
        if self.dropdown_menu:
            try:
                self.dropdown_menu._cleanup_and_destroy()
            except:
                pass
            self.dropdown_menu = None

    def destroy(self):
        """تدمير المكون"""
        self._cleanup()
        super().destroy()

============================================================
FILE: views\components\menu_bar.py
SIZE: 11466 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/menu_bar.py

مكون شريط القوائم
"""

import tkinter as tk
from tkinter import messagebox
from typing import Callable, Optional, Dict, Any

from core.language_manager import LanguageManager
from core.logger import logger


class MenuBarComponent:
    """مكون شريط القوائم"""

    def __init__(
        self,
        parent_window,
        lang_manager: LanguageManager,
        user_record: Dict[str, Any],
        callbacks: Dict[str, Callable]
    ):
        """
        تهيئة شريط القوائم

        Args:
            parent_window: النافذة الرئيسية
            lang_manager: مدير اللغة
            user_record: سجل المستخدم
            callbacks: قاموس بالدوال المرجعية
        """
        self.parent = parent_window
        self.lang_manager = lang_manager
        self.user_record = user_record
        self.callbacks = callbacks

        # متغيرات القوائم
        self.dark_mode_var = tk.BooleanVar()
        self.fullscreen_var = tk.BooleanVar(value=False)
        self.performance_mode_var = tk.BooleanVar(value=False)
        self.lang_var = tk.StringVar(value=self.lang_manager.current_lang)

        # إنشاء شريط القوائم
        self._create_menu()

    def _create_menu(self):
        """إنشاء شريط القوائم"""
        try:
            # إنشاء شريط القوائم
            self.menubar = tk.Menu(self.parent)
            self.parent.config(menu=self.menubar)

            # إنشاء القوائم
            self._create_file_menu()
            self._create_edit_menu()
            self._create_view_menu()
            self._create_tools_menu()

            # قائمة المسؤول (للمشرفين فقط)
            if self._is_admin():
                self._create_admin_menu()

            self._create_help_menu()

            logger.info("تم إنشاء شريط القوائم بنجاح")

        except Exception as e:
            logger.error(f"خطأ في إنشاء شريط القوائم: {e}")

    def _create_file_menu(self):
        """إنشاء قائمة ملف"""
        file_menu = tk.Menu(self.menubar, tearoff=0)

        # تسجيل خروج
        file_menu.add_command(
            label=self.lang_manager.get("logout", "Logout"),
            command=self._get_callback('logout'),
            accelerator="Ctrl+Shift+L"
        )

        file_menu.add_separator()

        # تصدير البيانات
        file_menu.add_command(
            label=self.lang_manager.get("export_data", "Export Data"),
            command=self._get_callback('export'),
            accelerator="Ctrl+S"
        )

        file_menu.add_separator()

        # إغلاق
        file_menu.add_command(
            label=self.lang_manager.get("close", "Close"),
            command=self._get_callback('close'),
            accelerator="Alt+F4"
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("file_menu", "File"),
            menu=file_menu
        )

    def _create_edit_menu(self):
        """إنشاء قائمة تحرير"""
        edit_menu = tk.Menu(self.menubar, tearoff=0)

        # إضافة
        edit_menu.add_command(
            label=self.lang_manager.get("add", "Add"),
            command=self._get_callback('add'),
            accelerator="Ctrl+N"
        )

        # تعديل
        edit_menu.add_command(
            label=self.lang_manager.get("edit", "Edit"),
            command=self._get_callback('edit'),
            accelerator="Ctrl+E"
        )

        # حذف
        edit_menu.add_command(
            label=self.lang_manager.get("delete", "Delete"),
            command=self._get_callback('delete'),
            accelerator="Delete"
        )

        edit_menu.add_separator()

        # تحديد الكل
        edit_menu.add_command(
            label=self.lang_manager.get("select_all", "Select All"),
            command=self._get_callback('select_all'),
            accelerator="Ctrl+A"
        )

        # إلغاء التحديد
        edit_menu.add_command(
            label=self.lang_manager.get("clear_selection", "Clear Selection"),
            command=self._get_callback('clear_selection'),
            accelerator="Escape"
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("edit_menu", "Edit"),
            menu=edit_menu
        )

    def _create_view_menu(self):
        """إنشاء قائمة عرض"""
        view_menu = tk.Menu(self.menubar, tearoff=0)

        # الوضع الداكن
        view_menu.add_checkbutton(
            label=self.lang_manager.get("dark_mode", "Dark Mode"),
            variable=self.dark_mode_var,
            command=self._toggle_dark_mode,
            accelerator="Ctrl+T"
        )

        view_menu.add_separator()

        # قائمة لغة فرعية
        self._create_language_submenu(view_menu)

        view_menu.add_separator()

        # تحديث البيانات
        view_menu.add_command(
            label=self.lang_manager.get("refresh", "Refresh"),
            command=self._get_callback('refresh'),
            accelerator="F5"
        )

        # وضع ملء الشاشة
        view_menu.add_checkbutton(
            label=self.lang_manager.get("fullscreen", "Fullscreen"),
            variable=self.fullscreen_var,
            command=self._toggle_fullscreen,
            accelerator="F11"
        )

        # وضع الأداء العالي
        view_menu.add_checkbutton(
            label=self.lang_manager.get("performance_mode", "Performance Mode"),
            variable=self.performance_mode_var,
            command=self._toggle_performance_mode
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("view_menu", "View"),
            menu=view_menu
        )

    def _create_language_submenu(self, parent_menu):
        """إنشاء قائمة اللغة الفرعية"""
        lang_menu = tk.Menu(parent_menu, tearoff=0)

        # العربية
        lang_menu.add_radiobutton(
            label=self.lang_manager.get("arabic", "العربية"),
            command=lambda: self._change_language("ar"),
            value="ar",
            variable=self.lang_var
        )

        # English
        lang_menu.add_radiobutton(
            label=self.lang_manager.get("english", "English"),
            command=lambda: self._change_language("en"),
            value="en",
            variable=self.lang_var
        )

        parent_menu.add_cascade(
            label=self.lang_manager.get("language_menu", "Language"),
            menu=lang_menu
        )

    def _create_tools_menu(self):
        """إنشاء قائمة أدوات"""
        tools_menu = tk.Menu(self.menubar, tearoff=0)

        # البحث
        tools_menu.add_command(
            label=self.lang_manager.get("search", "Search"),
            command=self._get_callback('search'),
            accelerator="Ctrl+F"
        )

        tools_menu.add_separator()

        # الإحصائيات
        tools_menu.add_command(
            label=self.lang_manager.get("statistics", "Statistics"),
            command=self._get_callback('statistics')
        )

        # التقارير
        tools_menu.add_command(
            label=self.lang_manager.get("reports", "Reports"),
            command=self._get_callback('reports')
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("tools_menu", "Tools"),
            menu=tools_menu
        )

    def _create_admin_menu(self):
        """إنشاء قائمة المسؤول"""
        admin_menu = tk.Menu(self.menubar, tearoff=0)

        # إدارة المستخدمين
        admin_menu.add_command(
            label=self.lang_manager.get("user_management", "User Management"),
            command=self._get_callback('user_management')
        )

        # محرر الإعدادات
        admin_menu.add_command(
            label=self.lang_manager.get("config_editor", "Configuration Editor"),
            command=self._get_callback('config_editor')
        )

        admin_menu.add_separator()

        # مسح الذاكرة المؤقتة
        admin_menu.add_command(
            label=self.lang_manager.get("clear_cache", "Clear Cache"),
            command=self._get_callback('clear_cache')
        )

        # عرض السجلات
        admin_menu.add_command(
            label=self.lang_manager.get("view_logs", "View Logs"),
            command=self._get_callback('view_logs')
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("admin_menu", "Admin"),
            menu=admin_menu
        )

    def _create_help_menu(self):
        """إنشاء قائمة المساعدة"""
        help_menu = tk.Menu(self.menubar, tearoff=0)

        # الاختصارات
        help_menu.add_command(
            label=self.lang_manager.get("shortcuts", "Keyboard Shortcuts"),
            command=self._get_callback('shortcuts'),
            accelerator="F1"
        )

        help_menu.add_separator()

        # دليل المستخدم
        help_menu.add_command(
            label=self.lang_manager.get("user_guide", "User Guide"),
            command=self._get_callback('user_guide')
        )

        # حول البرنامج
        help_menu.add_command(
            label=self.lang_manager.get("about", "About"),
            command=self._get_callback('about')
        )

        self.menubar.add_cascade(
            label=self.lang_manager.get("help_menu", "Help"),
            menu=help_menu
        )

    def _is_admin(self) -> bool:
        """التحقق من صلاحيات المسؤول"""
        return self.user_record.get('fields', {}).get('Role', '').lower() == 'admin'

    def _get_callback(self, action: str) -> Callable:
        """الحصول على الدالة المرجعية"""
        return self.callbacks.get(action, lambda: logger.warning(f"No callback for action: {action}"))

    def _toggle_dark_mode(self):
        """تبديل الوضع الداكن"""
        if 'toggle_theme' in self.callbacks:
            self.callbacks['toggle_theme']()

    def _toggle_fullscreen(self):
        """تبديل وضع ملء الشاشة"""
        if self.fullscreen_var.get():
            self.parent.attributes("-fullscreen", True)
        else:
            self.parent.attributes("-fullscreen", False)

        if 'fullscreen_changed' in self.callbacks:
            self.callbacks['fullscreen_changed'](self.fullscreen_var.get())

    def _toggle_performance_mode(self):
        """تبديل وضع الأداء العالي"""
        if 'performance_mode' in self.callbacks:
            self.callbacks['performance_mode'](self.performance_mode_var.get())

    def _change_language(self, lang_code: str):
        """تغيير اللغة"""
        if 'change_language' in self.callbacks:
            self.callbacks['change_language'](lang_code)
            self.lang_var.set(lang_code)

    def update_texts(self):
        """تحديث النصوص عند تغيير اللغة"""
        # إعادة بناء القائمة بالكامل
        self._create_menu()

        # تحديث المتغيرات
        self.lang_var.set(self.lang_manager.current_lang)

    def update_dark_mode(self, is_dark: bool):
        """تحديث حالة الوضع الداكن"""
        self.dark_mode_var.set(is_dark)

    def destroy(self):
        """تدمير المكون"""
        try:
            if hasattr(self, 'menubar'):
                self.menubar.destroy()
        except:
            pass

============================================================
FILE: views\components\quick_test.py
SIZE: 2201 characters
============================================================

#!/usr/bin/env python3
# -*- coding: utf-8 -*-
"""
اختبار سريع للقائمة المحسنة - لحل مشكلة الإغلاق السريع
"""

import customtkinter as ctk
from enhanced_searchable_combobox import EnhancedSearchableComboBox

def test_fixed_dropdown():
    """اختبار سريع للقائمة المصححة"""

    app = ctk.CTk()
    app.title("🔧 اختبار القائمة المصححة - لا تختفي بسرعة")
    app.geometry("600x500")

    # تعليمات
    instructions = ctk.CTkLabel(
        app,
        text="""🔧 اختبار حل مشكلة الإغلاق السريع:

1. اضغط على زر ▼ - يجب أن تفتح القائمة وتبقى مفتوحة
2. حرك الماوس فوق الخيارات - يجب أن تبقى القائمة مفتوحة
3. انقر على خيار - يجب أن يتم اختياره
4. راقب رسائل التشخيص في Console

إذا كانت القائمة لا تزال تختفي، سنحتاج لمزيد من التحسينات.""",
        font=ctk.CTkFont(size=12),
        justify="left"
    )
    instructions.pack(pady=20, padx=20)

    # القائمة المحسنة
    test_values = [
        "Cairo", "Alexandria", "Luxor", "Aswan",
        "Hurghada", "Sharm El Sheikh", "Giza"
    ]

    combo = EnhancedSearchableComboBox(
        app,
        values=test_values,
        placeholder="اختبر هنا - يجب ألا تختفي بسرعة",
        width=500,
        height=40,
        debug_mode=True,  # مهم للتشخيص
        on_select=lambda v: print(f"🎯 تم اختيار: {v}")
    )
    combo.pack(pady=30)

    # زر اختبار يدوي
    def manual_test():
        print("\n🧪 اختبار يدوي للقائمة:")
        combo._show_all_results()
        combo._open_dropdown()
        print("📝 تم فتح القائمة يدوياً - يجب أن تبقى مفتوحة")

    test_btn = ctk.CTkButton(
        app,
        text="🧪 فتح القائمة يدوياً",
        command=manual_test,
        height=40
    )
    test_btn.pack(pady=10)

    # نصائح
    tips = ctk.CTkLabel(
        app,
        text="""💡 نصائح الاختبار:
• إذا اختفت القائمة بسرعة، راجع رسائل Console
• ابحث عن رسائل "❌ إغلاق القائمة" في Console
• جرب النقر ببطء على الخيارات
• لا تحرك الماوس بسرعة خارج القائمة""",
        font=ctk.CTkFont(size=11),
        justify="left"
    )
    tips.pack(pady=20)

    print("🚀 تشغيل اختبار القائمة المصححة")
    print("📋 راقب هذه النافذة للرسائل التشخيصية")

    app.mainloop()

if __name__ == "__main__":
    test_fixed_dropdown()

============================================================
FILE: views\components\searchable_combobox.py
SIZE: 20729 characters
============================================================

# -*- coding: utf-8 -*-
"""
components/enhanced_searchable_combobox.py - النسخة المبسطة والمثبتة

الإصلاحات المطبقة:
✅ كود مبسط وأكثر استقراراً
✅ معالجة أحداث محسنة
✅ بحث مرن فعال
✅ أداء محسن
✅ سهولة في الاستخدام
"""

import customtkinter as ctk
import tkinter as tk
from typing import List, Callable, Optional, Any
import threading
import time


class EnhancedSearchableComboBox(ctk.CTkFrame):
    """قائمة منسدلة مدعومة بالبحث - نسخة مبسطة ومحسنة"""

    def __init__(self,
                 parent,
                 values: List[str] = None,
                 placeholder: str = "اكتب للبحث...",
                 width: int = 300,
                 height: int = 35,
                 max_results: int = 10,
                 enable_fuzzy: bool = True,
                 fuzzy_threshold: float = 0.6,
                 on_select: Callable[[str], None] = None,
                 **kwargs):

        super().__init__(parent, width=width, height=height, **kwargs)

        # الإعدادات
        self.values = values or []
        self.placeholder = placeholder
        self.max_results = max_results
        self.enable_fuzzy = enable_fuzzy
        self.fuzzy_threshold = fuzzy_threshold
        self.on_select = on_select

        # الحالة
        self.filtered_values = self.values.copy()
        self.selected_value = ""
        self.selected_index = -1
        self.is_dropdown_open = False

        # متغيرات واجهة المستخدم
        self.text_var = tk.StringVar()
        self.text_var.trace_add('write', self._on_text_change)

        # بناء الواجهة
        self._build_ui()
        self._setup_bindings()

        # النافذة المنبثقة
        self.dropdown_window = None
        self.option_buttons = []

        # تخزين مؤقت للبحث
        self._search_cache = {}

    def _build_ui(self):
        """بناء واجهة مستخدم بسيطة وفعالة"""
        # الإطار الرئيسي
        self.main_frame = ctk.CTkFrame(self, fg_color="transparent")
        self.main_frame.pack(fill="both", expand=True, padx=2, pady=2)

        # حقل النص
        self.entry = ctk.CTkEntry(
            self.main_frame,
            textvariable=self.text_var,
            placeholder_text=self.placeholder,
            height=self.cget("height") - 4
        )
        self.entry.pack(side="left", fill="both", expand=True, padx=(2, 1))

        # زر القائمة المنسدلة
        self.dropdown_btn = ctk.CTkButton(
            self.main_frame,
            text="▼",
            width=30,
            height=self.cget("height") - 4,
            command=self._toggle_dropdown
        )
        self.dropdown_btn.pack(side="right", padx=(1, 2))

    def _setup_bindings(self):
        """إعداد أحداث بسيطة ومستقرة"""
        # أحداث لوحة المفاتيح
        self.entry.bind('<Down>', self._on_arrow_down)
        self.entry.bind('<Up>', self._on_arrow_up)
        self.entry.bind('<Return>', self._on_enter)
        self.entry.bind('<Escape>', self._on_escape)
        self.entry.bind('<Tab>', self._on_tab)

        # أحداث التركيز - مبسطة
        self.entry.bind('<FocusIn>', self._on_focus_in)

        # فحص دوري للنقر خارج المكون
        self._check_outside_click()

    def _check_outside_click(self):
        """فحص دوري للنقر خارج المكون"""
        def check():
            try:
                if self.is_dropdown_open:
                    focused = self.focus_get()
                    if not self._is_focus_inside(focused):
                        self._close_dropdown()
            except:
                pass

            # إعادة جدولة الفحص
            self.after(200, check)

        self.after(200, check)

    def _is_focus_inside(self, widget) -> bool:
        """فحص إذا كان التركيز داخل المكون"""
        if not widget:
            return False

        # فحص العناصر الرئيسية
        main_widgets = [self, self.entry, self.dropdown_btn, self.main_frame]
        if widget in main_widgets:
            return True

        # فحص عناصر القائمة المنسدلة
        if widget in self.option_buttons:
            return True

        return False

    def _on_text_change(self, *args):
        """معالج تغيير النص - مبسط وفعال"""
        text = self.text_var.get()

        # البحث الفوري
        self._perform_search(text)

    def _perform_search(self, query: str):
        """تنفيذ البحث المحسن"""
        if not query:
            self.filtered_values = self.values.copy()
        else:
            # استخدام التخزين المؤقت
            if query in self._search_cache:
                self.filtered_values = self._search_cache[query]
            else:
                self.filtered_values = self._search_values(query)
                # حفظ في التخزين المؤقت
                if len(self._search_cache) < 50:
                    self._search_cache[query] = self.filtered_values.copy()

        # تحديث القائمة المنسدلة
        if self.is_dropdown_open:
            self._update_dropdown()
        elif self.filtered_values and query:
            self._open_dropdown()

    def _search_values(self, query: str) -> List[str]:
        """البحث في القيم مع دعم البحث المرن"""
        if not query:
            return self.values.copy()

        query_lower = query.lower()
        results = []

        # البحث بالأولوية
        for value in self.values:
            value_lower = value.lower()

            # تطابق تام
            if query_lower == value_lower:
                results.append((value, 1.0))
            # يبدأ بالاستعلام
            elif value_lower.startswith(query_lower):
                results.append((value, 0.9))
            # يحتوي على الاستعلام
            elif query_lower in value_lower:
                results.append((value, 0.7))
            # بحث مرن
            elif self.enable_fuzzy:
                similarity = self._calculate_similarity(query_lower, value_lower)
                if similarity >= self.fuzzy_threshold:
                    results.append((value, similarity * 0.6))

        # ترتيب حسب النقاط
        results.sort(key=lambda x: -x[1])

        # إرجاع النتائج (بدون النقاط)
        return [value for value, score in results[:self.max_results]]

    def _calculate_similarity(self, text1: str, text2: str) -> float:
        """حساب التشابه بخوارزمية بسيطة وسريعة"""
        if not text1 or not text2:
            return 0.0

        # نسبة الأحرف المشتركة
        common_chars = sum(1 for c in text1 if c in text2)
        max_len = max(len(text1), len(text2))

        return common_chars / max_len if max_len > 0 else 0.0

    def _toggle_dropdown(self):
        """تبديل حالة القائمة المنسدلة"""
        if self.is_dropdown_open:
            self._close_dropdown()
        else:
            self._open_dropdown()

    def _open_dropdown(self):
        """فتح القائمة المنسدلة"""
        if self.is_dropdown_open:
            return

        try:
            self._create_dropdown()
            self.is_dropdown_open = True
            self.dropdown_btn.configure(text="▲")

        except Exception as e:
            print(f"خطأ في فتح القائمة: {e}")

    def _create_dropdown(self):
        """إنشاء القائمة المنسدلة"""
        # تدمير النافذة القديمة
        if self.dropdown_window:
            try:
                self.dropdown_window.destroy()
            except:
                pass

        # حساب الموقع والحجم
        x = self.winfo_rootx()
        y = self.winfo_rooty() + self.winfo_height()
        width = self.winfo_width()
        height = min(200, len(self.filtered_values) * 35 + 10)

        # إنشاء النافذة
        self.dropdown_window = ctk.CTkToplevel(self)
        self.dropdown_window.wm_overrideredirect(True)
        self.dropdown_window.geometry(f"{width}x{height}+{x}+{y}")

        # إطار القائمة
        self.list_frame = ctk.CTkScrollableFrame(
            self.dropdown_window,
            width=width-10,
            height=height-10
        )
        self.list_frame.pack(fill="both", expand=True, padx=5, pady=5)

        self._populate_dropdown()

    def _populate_dropdown(self):
        """ملء القائمة المنسدلة"""
        # مسح الأزرار السابقة
        for btn in self.option_buttons:
            try:
                btn.destroy()
            except:
                pass

        self.option_buttons.clear()

        # إضافة الخيارات الجديدة
        for i, value in enumerate(self.filtered_values):
            btn = ctk.CTkButton(
                self.list_frame,
                text=value,
                height=30,
                anchor="w",
                command=lambda v=value: self._select_value(v)
            )
            btn.pack(fill="x", pady=1)

            # ربط أحداث الماوس
            btn.bind('<Enter>', lambda e, idx=i: self._highlight_option(idx))

            self.option_buttons.append(btn)

    def _update_dropdown(self):
        """تحديث محتوى القائمة المنسدلة"""
        if self.dropdown_window and self.dropdown_window.winfo_exists():
            self._populate_dropdown()

    def _close_dropdown(self):
        """إغلاق القائمة المنسدلة"""
        if self.dropdown_window:
            try:
                self.dropdown_window.destroy()
            except:
                pass
            finally:
                self.dropdown_window = None

        self.is_dropdown_open = False
        self.selected_index = -1
        self.dropdown_btn.configure(text="▼")

    def _select_value(self, value: str):
        """اختيار قيمة"""
        self.selected_value = value
        self.text_var.set(value)
        self._close_dropdown()

        # استدعاء callback
        if self.on_select:
            try:
                self.on_select(value)
            except Exception as e:
                print(f"خطأ في callback: {e}")

    def _highlight_option(self, index: int):
        """تمييز خيار"""
        self.selected_index = index

        # إزالة التمييز من جميع الأزرار
        for btn in self.option_buttons:
            btn.configure(fg_color=["gray75", "gray25"])

        # تمييز الزر المحدد
        if 0 <= index < len(self.option_buttons):
            self.option_buttons[index].configure(fg_color=["gray65", "gray35"])

    # معالجات الأحداث
    def _on_arrow_down(self, event):
        """السهم لأسفل"""
        if not self.is_dropdown_open:
            self._open_dropdown()
            return "break"

        if self.option_buttons:
            if self.selected_index < len(self.option_buttons) - 1:
                self.selected_index += 1
            else:
                self.selected_index = 0

            self._highlight_option(self.selected_index)

        return "break"

    def _on_arrow_up(self, event):
        """السهم لأعلى"""
        if not self.is_dropdown_open:
            return "break"

        if self.option_buttons:
            if self.selected_index > 0:
                self.selected_index -= 1
            else:
                self.selected_index = len(self.option_buttons) - 1

            self._highlight_option(self.selected_index)

        return "break"

    def _on_enter(self, event):
        """مفتاح Enter"""
        if self.is_dropdown_open and 0 <= self.selected_index < len(self.filtered_values):
            self._select_value(self.filtered_values[self.selected_index])
        return "break"

    def _on_escape(self, event):
        """مفتاح Escape"""
        if self.is_dropdown_open:
            self._close_dropdown()
        else:
            self.clear()
        return "break"

    def _on_tab(self, event):
        """مفتاح Tab"""
        if self.is_dropdown_open and 0 <= self.selected_index < len(self.filtered_values):
            self._select_value(self.filtered_values[self.selected_index])
            return "break"

    def _on_focus_in(self, event):
        """التركيز على الحقل"""
        text = self.text_var.get()
        if text:
            self._perform_search(text)

    # الواجهة العامة
    def get(self) -> str:
        """الحصول على القيمة المحددة"""
        return self.selected_value

    def set(self, value: str):
        """تعيين قيمة"""
        if value in self.values:
            self.selected_value = value
            self.text_var.set(value)
        else:
            # إضافة القيمة إذا لم تكن موجودة
            self.add_value(value)
            self.selected_value = value
            self.text_var.set(value)

    def clear(self):
        """مسح القيمة"""
        self.selected_value = ""
        self.text_var.set("")
        self.filtered_values = self.values.copy()
        self._close_dropdown()

    def set_values(self, values: List[str]):
        """تحديث قائمة القيم"""
        self.values = values.copy()
        self.filtered_values = values.copy()
        self._search_cache.clear()

    def add_value(self, value: str):
        """إضافة قيمة جديدة"""
        if value and value not in self.values:
            self.values.append(value)
            self.filtered_values = self.values.copy()
            self._search_cache.clear()

    def remove_value(self, value: str):
        """حذف قيمة"""
        if value in self.values:
            self.values.remove(value)
            self.filtered_values = self.values.copy()
            self._search_cache.clear()

            if self.selected_value == value:
                self.clear()

    def is_valid_selection(self) -> bool:
        """التحقق من صحة الاختيار"""
        return self.selected_value in self.values

    def focus_set(self):
        """التركيز على الحقل"""
        self.entry.focus_set()


# مثال للاختبار
if __name__ == "__main__":
    import customtkinter as ctk

    class TestApp:
        def __init__(self):
            ctk.set_appearance_mode("dark")
            ctk.set_default_color_theme("blue")

            self.root = ctk.CTk()
            self.root.title("Enhanced SearchableComboBox - Test")
            self.root.geometry("700x500")

            # بيانات تجريبية
            self.cities = [
                "القاهرة", "الإسكندرية", "الجيزة", "شرم الشيخ", "الغردقة",
                "أسوان", "الأقصر", "مرسى مطروح", "طابا", "دهب", "سفاجا",
                "Cairo", "Alexandria", "Giza", "Sharm El Sheikh", "Hurghada",
                "Aswan", "Luxor", "Marsa Matrouh", "Taba", "Dahab", "Safaga",
                "New York", "Los Angeles", "Chicago", "Houston", "Philadelphia",
                "London", "Paris", "Berlin", "Rome", "Madrid", "Barcelona",
                "Tokyo", "Sydney", "Toronto", "Dubai", "Kuwait", "Riyadh"
            ]

            self.setup_ui()

        def setup_ui(self):
            """إعداد واجهة الاختبار"""
            # العنوان
            title = ctk.CTkLabel(
                self.root,
                text="🔽 Enhanced SearchableComboBox",
                font=ctk.CTkFont(size=24, weight="bold")
            )
            title.pack(pady=20)

            # وصف التحسينات
            improvements = """
✅ كود مبسط ومستقر
✅ أداء محسن وسريع
✅ بحث مرن فعال
✅ واجهة سهلة الاستخدام
✅ معالجة أحداث محسنة
            """

            desc_label = ctk.CTkLabel(
                self.root,
                text=improvements,
                font=ctk.CTkFont(size=12),
                justify="left"
            )
            desc_label.pack(pady=10)

            # الاختبار الأول - قائمة المدن
            label1 = ctk.CTkLabel(
                self.root,
                text="🌍 اختيار المدينة:",
                font=ctk.CTkFont(size=14, weight="bold")
            )
            label1.pack(pady=(20, 5))

            self.combo1 = EnhancedSearchableComboBox(
                self.root,
                values=self.cities,
                placeholder="ابحث عن مدينة...",
                width=500,
                enable_fuzzy=True,
                on_select=self.on_city_select
            )
            self.combo1.pack(pady=5)

            # الاختبار الثاني - قائمة بدون بحث مرن
            label2 = ctk.CTkLabel(
                self.root,
                text="📋 بحث دقيق (بدون مرونة):",
                font=ctk.CTkFont(size=14, weight="bold")
            )
            label2.pack(pady=(20, 5))

            self.combo2 = EnhancedSearchableComboBox(
                self.root,
                values=self.cities[:10],  # قائمة أصغر
                placeholder="بحث دقيق فقط...",
                width=500,
                enable_fuzzy=False,
                on_select=self.on_exact_select
            )
            self.combo2.pack(pady=5)

            # عرض النتائج
            self.result_label = ctk.CTkLabel(
                self.root,
                text="🎯 لم يتم الاختيار بعد",
                font=ctk.CTkFont(size=16)
            )
            self.result_label.pack(pady=20)

            # أزرار التحكم
            controls_frame = ctk.CTkFrame(self.root)
            controls_frame.pack(pady=20)

            buttons = [
                ("🗑️ مسح الكل", self.clear_all),
                ("📊 عرض القيم", self.show_values),
                ("➕ إضافة مدينة", self.add_city),
                ("🔄 تحديث القوائم", self.refresh_lists),
                ("🧪 اختبار البحث", self.test_search)
            ]

            for i, (text, command) in enumerate(buttons):
                btn = ctk.CTkButton(
                    controls_frame,
                    text=text,
                    command=command,
                    width=140,
                    height=35
                )
                btn.grid(row=i//3, column=i%3, padx=5, pady=5)

        def on_city_select(self, value):
            """معالج اختيار المدينة"""
            self.result_label.configure(
                text=f"🌍 المدينة المختارة: {value}",
                text_color="green"
            )

        def on_exact_select(self, value):
            """معالج البحث الدقيق"""
            self.result_label.configure(
                text=f"📋 البحث الدقيق: {value}",
                text_color="blue"
            )

        def clear_all(self):
            """مسح جميع الاختيارات"""
            self.combo1.clear()
            self.combo2.clear()
            self.result_label.configure(
                text="🗑️ تم مسح جميع الاختيارات",
                text_color="orange"
            )

        def show_values(self):
            """عرض القيم المحددة"""
            value1 = self.combo1.get() or "غير محدد"
            value2 = self.combo2.get() or "غير محدد"

            self.result_label.configure(
                text=f"📊 القيم: مدن({value1}) | دقيق({value2})",
                text_color="purple"
            )

        def add_city(self):
            """إضافة مدينة جديدة"""
            import random
            new_cities = ["أبو ظبي", "الدوحة", "بيروت", "عمان", "الكويت", "المنامة"]
            new_city = random.choice(new_cities)

            self.combo1.add_value(new_city)
            self.combo2.add_value(new_city)

            self.result_label.configure(
                text=f"➕ تم إضافة: {new_city}",
                text_color="green"
            )

        def refresh_lists(self):
            """تحديث القوائم"""
            # إضافة بعض المدن الجديدة
            additional_cities = ["أغادير", "فاس", "الرباط", "الدار البيضاء"]

            current_cities = self.combo1.values + additional_cities
            self.combo1.set_values(list(set(current_cities)))
            self.combo2.set_values(current_cities[:15])

            self.result_label.configure(
                text="🔄 تم تحديث القوائم",
                text_color="blue"
            )

        def test_search(self):
            """اختبار البحث"""
            import random
            test_terms = ["Cair", "Alex", "قاهر", "اسكند", "Lond", "باري"]
            test_term = random.choice(test_terms)

            self.combo1.clear()
            self.combo1.text_var.set(test_term)

            self.result_label.configure(
                text=f"🧪 اختبار البحث عن: '{test_term}'",
                text_color="purple"
            )

        def run(self):
            """تشغيل التطبيق"""
            self.root.mainloop()

    # تشغيل الاختبار
    app = TestApp()
    app.run()


============================================================
FILE: views\components\sidebar.py
SIZE: 19652 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/sidebar.py

مكون الشريط الجانبي المحسن بتصميم احترافي
"""

import customtkinter as ctk
from typing import Callable, Dict, Any, Optional

from core.language_manager import LanguageManager


class SidebarComponent(ctk.CTkFrame):
    """مكون الشريط الجانبي المحسن بتصميم احترافي"""

    def __init__(
        self,
        parent,
        lang_manager: LanguageManager,
        theme_manager: Optional[Any] = None,
        on_navigate: Callable = None,
        **kwargs
    ):
        # إعدادات احترافية للإطار
        kwargs.setdefault('width', 280)
        kwargs.setdefault('corner_radius', 0)
        kwargs.setdefault('fg_color', ("#f8f9fa", "#1e1e1e"))

        super().__init__(parent, **kwargs)
        self.pack_propagate(False)

        self.lang_manager = lang_manager
        self.theme_manager = theme_manager
        self.on_navigate = on_navigate
        self.is_collapsed = False
        self.nav_buttons = []
        self.active_button = None

        self._build_ui()

    def _build_ui(self):
        """بناء الواجهة المحسنة"""
        # رأس الشريط الجانبي
        self._create_header()

        # قائمة التنقل
        self._create_navigation_section()

        # قسم الإحصائيات
        self._create_stats_section()

        # قسم الاختصارات السريعة
        self._create_quick_actions()

        # تذييل مع معلومات إضافية
        self._create_footer()

    def _create_header(self):
        """إنشاء رأس الشريط الجانبي"""
        header_frame = ctk.CTkFrame(
            self,
            height=60,
            fg_color=("#e9ecef", "#252525"),
            corner_radius=0
        )
        header_frame.pack(fill="x")
        header_frame.pack_propagate(False)

        # إطار المحتوى
        content_frame = ctk.CTkFrame(header_frame, fg_color="transparent")
        content_frame.pack(expand=True)

        # العنوان مع أيقونة
        title_frame = ctk.CTkFrame(content_frame, fg_color="transparent")
        title_frame.pack()

        # أيقونة القائمة
        menu_icon = ctk.CTkLabel(
            title_frame,
            text="📊",
            font=ctk.CTkFont(size=20)
        )
        menu_icon.pack(side="left", padx=(0, 8))

        # العنوان
        title_label = ctk.CTkLabel(
            title_frame,
            text=self.lang_manager.get("dashboard", "Dashboard"),
            font=ctk.CTkFont(size=18, weight="bold"),
            text_color=("#1976d2", "#2196f3")
        )
        title_label.pack(side="left")

        # زر التبديل
        self.toggle_btn = ctk.CTkButton(
            header_frame,
            text="◀",
            width=30,
            height=30,
            corner_radius=15,
            command=self._toggle_sidebar,
            fg_color="transparent",
            hover_color=("#dee2e6", "#343a40"),
            text_color=("#666666", "#999999"),
            font=ctk.CTkFont(size=14)
        )
        self.toggle_btn.pack(side="right", padx=10)

    def _create_navigation_section(self):
        """إنشاء قسم التنقل المحسن"""
        # إطار القسم
        nav_section = ctk.CTkFrame(self, fg_color="transparent")
        nav_section.pack(fill="x", padx=15, pady=(15, 0))

        # عنوان القسم
        self.nav_title = ctk.CTkLabel(
            nav_section,
            text=self.lang_manager.get("quick_navigation", "Quick Navigation"),
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=("#666666", "#999999")
        )
        self.nav_title.pack(anchor="w", pady=(0, 10))

        # إطار الأزرار
        self.nav_frame = ctk.CTkFrame(nav_section, fg_color="transparent")
        self.nav_frame.pack(fill="x")

        # عناصر التنقل
        nav_items = [
            ("🏠", "home", "Home", "primary"),
            ("📅", "today", "Today's Bookings", "info"),
            ("⏳", "pending", "Pending Bookings", "warning"),
            ("✅", "confirmed", "Confirmed Bookings", "success"),
            ("📊", "reports", "Reports", "secondary"),
        ]

        for icon, key, default_text, style in nav_items:
            text = self.lang_manager.get(f"nav_{key}", default_text)
            btn = self._create_nav_button(self.nav_frame, icon, key, text, style)
            self.nav_buttons.append((btn, icon, key, default_text, style))

    def _create_nav_button(self, parent, icon, key, text, style="default"):
        """إنشاء زر تنقل احترافي"""
        # إطار الزر
        button_frame = ctk.CTkFrame(
            parent,
            height=45,
            fg_color="transparent",
            corner_radius=10
        )
        button_frame.pack(fill="x", pady=3)

        # الزر
        btn = ctk.CTkButton(
            button_frame,
            text=f"{icon}  {text}",
            anchor="w",
            height=40,
            fg_color="transparent",
            hover_color=("#e9ecef", "#2d3436"),
            text_color=("#495057", "#e9ecef"),
            font=ctk.CTkFont(size=14),
            command=lambda: self._on_navigate(key, button_frame),
            corner_radius=8
        )
        btn.pack(fill="both", expand=True, padx=2, pady=2)

        # تأثير التحديد
        button_frame.is_active = False
        button_frame.key = key
        button_frame.button = btn
        button_frame.style = style

        # ألوان الأنماط
        style_colors = {
            "primary": ("#1976d2", "#2196f3"),
            "info": ("#0288d1", "#03a9f4"),
            "warning": ("#f57c00", "#ff9800"),
            "success": ("#388e3c", "#4caf50"),
            "secondary": ("#616161", "#757575")
        }
        button_frame.accent_color = style_colors.get(style, style_colors["primary"])

        # تأثيرات hover
        def on_enter(e):
            if not button_frame.is_active:
                color = button_frame.accent_color[1 if ctk.get_appearance_mode() == "Dark" else 0]
                btn.configure(text_color=color)

        def on_leave(e):
            if not button_frame.is_active:
                btn.configure(text_color=("#495057", "#e9ecef"))

        btn.bind("<Enter>", on_enter)
        btn.bind("<Leave>", on_leave)

        return button_frame

    def _on_navigate(self, key, button_frame):
        """معالج التنقل مع تأثيرات بصرية"""
        # إلغاء تفعيل الزر السابق
        if self.active_button:
            self.active_button.is_active = False
            self.active_button.button.configure(
                fg_color="transparent",
                text_color=("#495057", "#e9ecef")
            )

        # تفعيل الزر الحالي
        button_frame.is_active = True
        self.active_button = button_frame

        # تطبيق لون التفعيل
        accent = button_frame.accent_color[1 if ctk.get_appearance_mode() == "Dark" else 0]
        # استخدام لون أفتح بدلاً من الشفافية
        light_accent = self._get_lighter_color(accent, 0.1)
        button_frame.button.configure(
            fg_color=light_accent,
            text_color=accent
        )

        # استدعاء دالة التنقل
        if self.on_navigate:
            self.on_navigate(key)

    def _create_stats_section(self):
        """إنشاء قسم الإحصائيات المحسن"""
        # إطار القسم
        stats_section = ctk.CTkFrame(self, fg_color="transparent")
        stats_section.pack(fill="x", padx=15, pady=(25, 0))

        # عنوان القسم
        self.stats_title = ctk.CTkLabel(
            stats_section,
            text=self.lang_manager.get("quick_stats", "Quick Stats"),
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=("#666666", "#999999")
        )
        self.stats_title.pack(anchor="w", pady=(0, 10))

        # إطار البطاقات
        self.stats_frame = ctk.CTkFrame(stats_section, fg_color="transparent")
        self.stats_frame.pack(fill="x")

        # بطاقات الإحصائيات
        self.stats_cards = {}
        self.stats_info = []

        stats_items = [
            ("total", "📊", "Total Bookings", "#1976d2"),
            ("today", "📅", "Today's Bookings", "#388e3c"),
            ("pending", "⏳", "Pending", "#f57c00")
        ]

        for key, icon, default_label, color in stats_items:
            label = self.lang_manager.get(f"stats_{key}", default_label)
            card_frame, value_label = self._create_enhanced_stat_card(
                self.stats_frame, icon, label, color
            )
            self.stats_cards[key] = value_label
            self.stats_info.append((key, icon, default_label, card_frame, color))

    def _create_enhanced_stat_card(self, parent, icon, label, color):
        """إنشاء بطاقة إحصائية محسنة"""
        # إطار البطاقة
        card = ctk.CTkFrame(
            parent,
            height=80,
            corner_radius=12,
            fg_color=("#ffffff", "#2b2b2b"),
            border_width=1,
            border_color=("#e0e0e0", "#444444")
        )
        card.pack(fill="x", pady=5)

        # تأثير hover
        def on_enter(e):
            card.configure(border_color=color)

        def on_leave(e):
            card.configure(border_color=("#e0e0e0", "#444444"))

        card.bind("<Enter>", on_enter)
        card.bind("<Leave>", on_leave)

        # محتوى البطاقة
        content_frame = ctk.CTkFrame(card, fg_color="transparent")
        content_frame.pack(expand=True, padx=15)

        # الصف العلوي
        top_row = ctk.CTkFrame(content_frame, fg_color="transparent")
        top_row.pack(fill="x")

        # الأيقونة مع خلفية ملونة
        # استخدام ألوان أفتح بدلاً من الشفافية
        light_color = self._get_lighter_color(color, 0.2)
        dark_color = self._get_lighter_color(color, 0.3)

        icon_bg = ctk.CTkFrame(
            top_row,
            width=40,
            height=40,
            corner_radius=20,
            fg_color=(light_color, dark_color)
        )
        icon_bg.pack(side="left")
        icon_bg.pack_propagate(False)

        icon_label = ctk.CTkLabel(
            icon_bg,
            text=icon,
            font=ctk.CTkFont(size=20),
            text_color=color
        )
        icon_label.place(relx=0.5, rely=0.5, anchor="center")

        # القيمة
        value_label = ctk.CTkLabel(
            top_row,
            text="0",
            font=ctk.CTkFont(size=24, weight="bold"),
            text_color=color
        )
        value_label.pack(side="right")

        # التسمية
        label_widget = ctk.CTkLabel(
            content_frame,
            text=label,
            font=ctk.CTkFont(size=12),
            text_color=("#666666", "#999999")
        )
        label_widget.pack(anchor="w", pady=(5, 0))

        # حفظ مرجع التسمية
        card.label_widget = label_widget
        card.color = color

        return card, value_label

    def _create_quick_actions(self):
        """إنشاء قسم الإجراءات السريعة"""
        # إطار القسم
        actions_section = ctk.CTkFrame(self, fg_color="transparent")
        actions_section.pack(fill="x", padx=15, pady=(25, 0))

        # عنوان القسم
        actions_title = ctk.CTkLabel(
            actions_section,
            text=self.lang_manager.get("quick_actions", "Quick Actions"),
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=("#666666", "#999999")
        )
        actions_title.pack(anchor="w", pady=(0, 10))

        # أزرار الإجراءات
        actions_frame = ctk.CTkFrame(actions_section, fg_color="transparent")
        actions_frame.pack(fill="x")

        # زر إضافة سريع
        add_btn = ctk.CTkButton(
            actions_frame,
            text=f"➕ {self.lang_manager.get('quick_add', 'Quick Add')}",
            height=35,
            corner_radius=8,
            fg_color=("#4caf50", "#2e7d32"),
            hover_color=("#45a049", "#1b5e20"),
            font=ctk.CTkFont(size=13, weight="bold"),
            command=lambda: self.on_navigate and self.on_navigate("add")
        )
        add_btn.pack(fill="x", pady=3)

        # زر البحث السريع
        search_btn = ctk.CTkButton(
            actions_frame,
            text=f"🔍 {self.lang_manager.get('quick_search', 'Quick Search')}",
            height=35,
            corner_radius=8,
            fg_color=("#2196f3", "#1976d2"),
            hover_color=("#1976d2", "#1565c0"),
            font=ctk.CTkFont(size=13, weight="bold"),
            command=lambda: self.on_navigate and self.on_navigate("search")
        )
        search_btn.pack(fill="x", pady=3)

    def _create_footer(self):
        """إنشاء تذييل الشريط الجانبي"""
        # مساحة مرنة
        spacer = ctk.CTkFrame(self, fg_color="transparent")
        spacer.pack(fill="both", expand=True)

        # إطار التذييل
        footer_frame = ctk.CTkFrame(
            self,
            height=60,
            fg_color=("#e9ecef", "#252525"),
            corner_radius=0
        )
        footer_frame.pack(fill="x", side="bottom")

        # محتوى التذييل
        footer_content = ctk.CTkFrame(footer_frame, fg_color="transparent")
        footer_content.pack(expand=True)

        # معلومات النظام
        system_info = ctk.CTkLabel(
            footer_content,
            text="FTS System v2.0",
            font=ctk.CTkFont(size=11),
            text_color=("#666666", "#999999")
        )
        system_info.pack()

        # حقوق النشر
        copyright_label = ctk.CTkLabel(
            footer_content,
            text="© 2024 FTS",
            font=ctk.CTkFont(size=10),
            text_color=("#999999", "#666666")
        )
        copyright_label.pack()

    def _toggle_sidebar(self):
        """تبديل الشريط الجانبي مع تأثيرات سلسة"""
        if self.is_collapsed:
            # توسيع الشريط
            self._expand_sidebar()
        else:
            # طي الشريط
            self._collapse_sidebar()

        self.is_collapsed = not self.is_collapsed

    def _collapse_sidebar(self):
        """طي الشريط الجانبي"""
        # تقليل العرض تدريجياً
        target_width = 60
        current_width = self.winfo_width()

        while current_width > target_width:
            current_width = max(current_width - 20, target_width)
            self.configure(width=current_width)
            self.update()
            self.after(10)

        # تغيير أيقونة التبديل
        self.toggle_btn.configure(text="▶")

        # إخفاء النصوص
        for widget in [self.nav_title, self.stats_title]:
            widget.pack_forget()

        # إخفاء البطاقات
        for _, _, _, card, _ in self.stats_info:
            card.pack_forget()

    def _expand_sidebar(self):
        """توسيع الشريط الجانبي"""
        # زيادة العرض تدريجياً
        target_width = 280
        current_width = self.winfo_width()

        while current_width < target_width:
            current_width = min(current_width + 20, target_width)
            self.configure(width=current_width)
            self.update()
            self.after(10)

        # تغيير أيقونة التبديل
        self.toggle_btn.configure(text="◀")

        # إظهار النصوص
        self.nav_title.pack(anchor="w", pady=(0, 10))
        self.stats_title.pack(anchor="w", pady=(0, 10))

        # إظهار البطاقات
        for _, _, _, card, _ in self.stats_info:
            card.pack(fill="x", pady=5)

    def update_stats(self, stats: Dict[str, int]):
        """تحديث الإحصائيات مع تأثيرات"""
        for key, value in stats.items():
            if key in self.stats_cards:
                label = self.stats_cards[key]
                # تحديث القيمة مع تأثير
                self._animate_value_change(label, int(label.cget("text")), value)

    def _animate_value_change(self, label, start, end):
        """تحريك تغيير القيمة"""
        if start == end:
            return

        # حساب الخطوة
        diff = end - start
        steps = 20
        step = diff / steps

        def update_value(current, target, step_count):
            if step_count <= 0:
                label.configure(text=str(int(target)))
                return

            new_value = current + step
            label.configure(text=str(int(new_value)))

            self.after(50, lambda: update_value(new_value, target, step_count - 1))

        update_value(start, end, steps)

    def update_texts(self, lang_manager):
        """تحديث نصوص المكون"""
        self.lang_manager = lang_manager

        # تحديث العناوين
        if hasattr(self, 'nav_title'):
            self.nav_title.configure(
                text=lang_manager.get("quick_navigation", "Quick Navigation")
            )

        if hasattr(self, 'stats_title'):
            self.stats_title.configure(
                text=lang_manager.get("quick_stats", "Quick Stats")
            )

        # تحديث أزرار التنقل
        for btn_frame, icon, key, default_text, style in self.nav_buttons:
            translated_text = lang_manager.get(f"nav_{key}", default_text)
            btn_frame.button.configure(text=f"{icon}  {translated_text}")

        # تحديث بطاقات الإحصائيات
        for key, icon, default_label, card_frame, color in self.stats_info:
            translated_label = lang_manager.get(f"stats_{key}", default_label)
            if hasattr(card_frame, 'label_widget'):
                card_frame.label_widget.configure(text=translated_label)

    def set_active_nav(self, key: str):
        """تعيين العنصر النشط في التنقل"""
        for btn_frame, _, btn_key, _, _ in self.nav_buttons:
            if btn_key == key:
                self._on_navigate(key, btn_frame)
                break

    def add_navigation_button(self, text, icon=None, command=None, style="default"):
        """إضافة زر تنقل مخصص"""
        if not hasattr(self, 'nav_frame'):
            return None

        display_text = f"{icon}  {text}" if icon else text

        # إنشاء الزر
        btn_frame = self._create_nav_button(
            self.nav_frame,
            icon or "•",
            text.lower().replace(" ", "_"),
            display_text,
            style
        )

        # تعيين الأمر المخصص
        if command:
            btn_frame.button.configure(command=command)

        # إضافة للقائمة
        self.nav_buttons.append((btn_frame, icon or "", text, text, style))

        return btn_frame

    def refresh_theme(self):
        """تحديث الثيم عند تغييره"""
        # إعادة بناء الواجهة لتطبيق الألوان الجديدة
        for widget in self.winfo_children():
            widget.destroy()
        self._build_ui()

    def _get_lighter_color(self, hex_color: str, factor: float = 0.2) -> str:
        """الحصول على لون أفتح من اللون المعطى"""
        # إزالة # إذا كانت موجودة
        hex_color = hex_color.lstrip('#')

        # تحويل hex إلى RGB
        r = int(hex_color[0:2], 16)
        g = int(hex_color[2:4], 16)
        b = int(hex_color[4:6], 16)

        # جعل اللون أفتح
        r = int(r + (255 - r) * factor)
        g = int(g + (255 - g) * factor)
        b = int(b + (255 - b) * factor)

        # التأكد من عدم تجاوز 255
        r = min(255, r)
        g = min(255, g)
        b = min(255, b)

        # تحويل مرة أخرى إلى hex
        return f"#{r:02x}{g:02x}{b:02x}"


# للتوافق مع الأكواد القديمة
Sidebar = SidebarComponent

============================================================
FILE: views\components\status_bar.py
SIZE: 20837 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/status_bar.py

مكون شريط الحالة المحسن بتصميم احترافي مع حماية من الأخطاء
"""

import customtkinter as ctk
from datetime import datetime
from typing import Optional, Tuple
import threading

from core.language_manager import LanguageManager


class StatusBarComponent(ctk.CTkFrame):
    """مكون شريط الحالة المحسن بتصميم احترافي مع حماية من الأخطاء"""

    def __init__(
        self,
        parent,
        lang_manager: LanguageManager,
        **kwargs
    ):
        # إعدادات احترافية للإطار
        kwargs.setdefault('height', 35)
        kwargs.setdefault('corner_radius', 0)
        kwargs.setdefault('fg_color', ("#f8f9fa", "#1e1e1e"))
        kwargs.setdefault('border_width', 1)
        kwargs.setdefault('border_color', ("#e0e0e0", "#444444"))

        super().__init__(parent, **kwargs)
        self.pack_propagate(False)

        self.lang_manager = lang_manager

        # متغيرات الحالة
        self.current_status = ""
        self.status_type = "info"
        self.progress_active = False

        # متغير لتتبع حالة التدمير
        self._destroyed = False
        self._time_update_running = False

        self._build_ui()
        self._start_time_update()

        # ربط حدث التدمير
        self.bind("<Destroy>", self._on_destroy)

    def _on_destroy(self, event=None):
        """معالج تدمير المكون"""
        if event and event.widget == self:
            self._destroyed = True
            self._time_update_running = False

    def _is_valid(self):
        """فحص صحة المكون قبل أي عملية"""
        try:
            return not self._destroyed and self.winfo_exists()
        except:
            self._destroyed = True
            return False

    def _safe_configure(self, widget, **kwargs):
        """تكوين آمن للمكونات مع فحص الصحة"""
        try:
            if self._is_valid() and widget and hasattr(widget, 'configure'):
                if hasattr(widget, 'winfo_exists'):
                    if widget.winfo_exists():
                        widget.configure(**kwargs)
                        return True
                else:
                    widget.configure(**kwargs)
                    return True
        except Exception as e:
            # تسجيل الخطأ بهدوء دون إيقاف البرنامج
            pass
        return False

    def _build_ui(self):
        """بناء الواجهة المحسنة"""
        # الحاوية الرئيسية
        main_container = ctk.CTkFrame(self, fg_color="transparent")
        main_container.pack(fill="both", expand=True, padx=10)

        # القسم الأيسر - رسالة الحالة
        left_section = ctk.CTkFrame(main_container, fg_color="transparent")
        left_section.pack(side="left", fill="x", expand=True)

        # أيقونة الحالة
        self.status_icon = ctk.CTkLabel(
            left_section,
            text="ℹ️",
            font=ctk.CTkFont(size=14),
            width=20
        )
        self.status_icon.pack(side="left", padx=(0, 5))

        # رسالة الحالة
        self.status_label = ctk.CTkLabel(
            left_section,
            text=self.lang_manager.get("ready", "Ready"),
            anchor="w",
            font=ctk.CTkFont(size=12)
        )
        self.status_label.pack(side="left", fill="x", expand=True)

        # شريط التقدم (مخفي افتراضياً)
        self.progress_bar = ctk.CTkProgressBar(
            left_section,
            width=150,
            height=8,
            corner_radius=4,
            progress_color=("#2196f3", "#1976d2")
        )

        # القسم الأوسط - معلومات إضافية
        middle_section = ctk.CTkFrame(main_container, fg_color="transparent")
        middle_section.pack(side="left", padx=20)

        # عداد العناصر
        self.items_frame = ctk.CTkFrame(middle_section, fg_color="transparent")
        self.items_frame.pack(side="left", padx=10)

        self.items_icon = ctk.CTkLabel(
            self.items_frame,
            text="📄",
            font=ctk.CTkFont(size=12)
        )

        self.items_label = ctk.CTkLabel(
            self.items_frame,
            text="",
            font=ctk.CTkFont(size=11),
            text_color=("#666666", "#999999")
        )

        # القسم الأيمن - المؤشرات
        right_section = ctk.CTkFrame(main_container, fg_color="transparent")
        right_section.pack(side="right")

        # مؤشر الاتصال
        self.connection_frame = ctk.CTkFrame(right_section, fg_color="transparent")
        self.connection_frame.pack(side="left", padx=10)

        self.connection_indicator = ctk.CTkLabel(
            self.connection_frame,
            text="●",
            font=ctk.CTkFont(size=10),
            text_color=("#4caf50", "#2e7d32")
        )
        self.connection_indicator.pack(side="left", padx=(0, 3))

        self.connection_label = ctk.CTkLabel(
            self.connection_frame,
            text=self.lang_manager.get("connected", "Connected"),
            font=ctk.CTkFont(size=11),
            text_color=("#4caf50", "#2e7d32")
        )
        self.connection_label.pack(side="left")

        # خط فاصل
        separator = ctk.CTkFrame(
            right_section,
            width=1,
            fg_color=("#e0e0e0", "#444444")
        )
        separator.pack(side="left", fill="y", padx=10)

        # الوقت والتاريخ
        self.datetime_frame = ctk.CTkFrame(right_section, fg_color="transparent")
        self.datetime_frame.pack(side="left", padx=10)

        self.time_label = ctk.CTkLabel(
            self.datetime_frame,
            text="",
            font=ctk.CTkFont(size=12, weight="bold"),
            text_color=("#1976d2", "#2196f3")
        )
        self.time_label.pack()

        self.date_label = ctk.CTkLabel(
            self.datetime_frame,
            text="",
            font=ctk.CTkFont(size=10),
            text_color=("#666666", "#999999")
        )
        self.date_label.pack()

    def set_status(self, message: str, status_type: str = "info", duration: int = None):
        """تعيين رسالة الحالة مع نوع وأيقونة - مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            self.current_status = message
            self.status_type = status_type

            # تحديث النص بطريقة آمنة
            if not self._safe_configure(self.status_label, text=message):
                return

            # تحديد الأيقونة واللون حسب النوع
            status_config = self._get_status_config(status_type)

            # تحديث الأيقونة
            self._safe_configure(
                self.status_icon,
                text=status_config["icon"],
                text_color=status_config["color"]
            )

            # تحديث لون النص
            self._safe_configure(self.status_label, text_color=status_config["color"])

            # تأثير الظهور
            self._animate_status_change()

            # إخفاء تلقائي بعد مدة معينة
            if duration and self._is_valid():
                self.after(duration * 1000, lambda: self._delayed_status_reset())

        except Exception as e:
            # في حالة حدوث خطأ، نحاول مرة أخيرة بطريقة بسيطة
            pass

    def _delayed_status_reset(self):
        """إعادة تعيين الحالة بعد تأخير مع فحص الصحة"""
        if self._is_valid():
            self.set_status(self.lang_manager.get("ready", "Ready"), "info")

    def _get_status_config(self, status_type: str) -> dict:
        """الحصول على تكوين الحالة"""
        is_dark = ctk.get_appearance_mode() == "Dark"

        status_configs = {
            "info": {
                "icon": "ℹ️",
                "color": ("#2196f3", "#1976d2")
            },
            "success": {
                "icon": "✅",
                "color": ("#4caf50", "#2e7d32")
            },
            "warning": {
                "icon": "⚠️",
                "color": ("#ff9800", "#f57c00")
            },
            "error": {
                "icon": "❌",
                "color": ("#f44336", "#d32f2f")
            },
            "loading": {
                "icon": "⏳",
                "color": ("#9c27b0", "#7b1fa2")
            }
        }

        config = status_configs.get(status_type, status_configs["info"])
        # اختيار اللون حسب الوضع
        config["color"] = config["color"][1 if is_dark else 0]

        return config

    def _animate_status_change(self):
        """تأثير تغيير الحالة مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            # تأثير الوميض للفت الانتباه
            if self.status_type in ["error", "warning"]:
                for i in range(2):
                    if not self._is_valid():
                        break

                    self._safe_configure(self.status_label, text_color="transparent")
                    if self._is_valid():
                        self.update()
                        self.after(100)

                    color = self._get_status_config(self.status_type)["color"]
                    self._safe_configure(self.status_label, text_color=color)
                    if self._is_valid():
                        self.update()
                        self.after(100)
        except:
            pass

    def set_connection_status(self, connected: bool, details: str = None):
        """تعيين حالة الاتصال مع تفاصيل - مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            if connected:
                self._safe_configure(self.connection_indicator, text_color=("#4caf50", "#2e7d32"))
                text = self.lang_manager.get("connected", "Connected")
                if details:
                    text += f" • {details}"
                self._safe_configure(
                    self.connection_label,
                    text=text,
                    text_color=("#4caf50", "#2e7d32")
                )

                # تأثير النبض للاتصال النشط
                self._pulse_connection_indicator()
            else:
                self._safe_configure(self.connection_indicator, text_color=("#f44336", "#d32f2f"))
                text = self.lang_manager.get("disconnected", "Disconnected")
                if details:
                    text += f" • {details}"
                self._safe_configure(
                    self.connection_label,
                    text=text,
                    text_color=("#f44336", "#d32f2f")
                )
        except:
            pass

    def _pulse_connection_indicator(self):
        """تأثير نبض لمؤشر الاتصال مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        def pulse():
            if self._is_valid():
                # تكبير
                self._safe_configure(self.connection_indicator, font=ctk.CTkFont(size=12))
                if self._is_valid():
                    self.after(200, lambda: self._safe_configure(self.connection_indicator, font=ctk.CTkFont(size=10)) if self._is_valid() else None)

        try:
            pulse()
        except:
            pass

    def show_progress(self, value: float = None, text: str = None):
        """عرض شريط التقدم مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            if not self.progress_active:
                self.progress_active = True
                if hasattr(self.progress_bar, 'pack') and self._is_valid():
                    self.progress_bar.pack(side="left", padx=(10, 0))
                    if hasattr(self.progress_bar, 'set'):
                        self.progress_bar.set(0)

            if value is not None and hasattr(self.progress_bar, 'set'):
                self.progress_bar.set(value)

            if text:
                self.set_status(text, "loading")

            # إخفاء التقدم عند الاكتمال
            if value and value >= 1.0 and self._is_valid():
                self.after(500, self.hide_progress)
        except:
            pass

    def hide_progress(self):
        """إخفاء شريط التقدم مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            self.progress_active = False
            if hasattr(self.progress_bar, 'pack_forget'):
                self.progress_bar.pack_forget()
            self.set_status(self.lang_manager.get("ready", "Ready"), "info")
        except:
            pass

    def show_items_count(self, total: int, filtered: int = None):
        """عرض عداد العناصر مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            if total > 0:
                if hasattr(self.items_icon, 'pack') and self._is_valid():
                    self.items_icon.pack(side="left", padx=(0, 3))

                if filtered is not None and filtered < total:
                    text = self.lang_manager.get(
                        "showing_filtered",
                        f"Showing {filtered} of {total}"
                    )
                else:
                    text = self.lang_manager.get(
                        "total_items",
                        f"{total} items"
                    )

                self._safe_configure(self.items_label, text=text)
                if hasattr(self.items_label, 'pack') and self._is_valid():
                    self.items_label.pack(side="left")
            else:
                if hasattr(self.items_icon, 'pack_forget'):
                    self.items_icon.pack_forget()
                if hasattr(self.items_label, 'pack_forget'):
                    self.items_label.pack_forget()
        except:
            pass

    def _update_time(self):
        """تحديث الوقت والتاريخ مع حماية من الأخطاء"""
        if not self._is_valid() or not self._time_update_running:
            return

        try:
            now = datetime.now()

            # تنسيق الوقت
            time_format = "%I:%M:%S %p" if self.lang_manager.current_lang == "en" else "%H:%M:%S"
            time_str = now.strftime(time_format)
            self._safe_configure(self.time_label, text=time_str)

            # تنسيق التاريخ
            if self.lang_manager.current_lang == "ar":
                # التاريخ بالعربية
                months_ar = [
                    "يناير", "فبراير", "مارس", "أبريل", "مايو", "يونيو",
                    "يوليو", "أغسطس", "سبتمبر", "أكتوبر", "نوفمبر", "ديسمبر"
                ]
                days_ar = [
                    "الإثنين", "الثلاثاء", "الأربعاء", "الخميس",
                    "الجمعة", "السبت", "الأحد"
                ]

                day = days_ar[now.weekday()]
                month = months_ar[now.month - 1]
                date_str = f"{day}، {now.day} {month} {now.year}"
            else:
                # التاريخ بالإنجليزية
                date_str = now.strftime("%A, %d %B %Y")

            self._safe_configure(self.date_label, text=date_str)

            # جدولة التحديث التالي
            if self._is_valid() and self._time_update_running:
                self.after(1000, self._update_time)

        except Exception as e:
            # إذا حدث خطأ، توقف عن التحديث
            self._time_update_running = False

    def _start_time_update(self):
        """بدء تحديث الوقت مع حماية من الأخطاء"""
        if self._is_valid():
            self._time_update_running = True
            self._update_time()

    def show_notification(self, title: str, message: str, type: str = "info"):
        """عرض إشعار مؤقت مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            # إنشاء إطار الإشعار
            top_window = self.winfo_toplevel()
            if not top_window or not hasattr(top_window, 'winfo_exists') or not top_window.winfo_exists():
                return

            notif_frame = ctk.CTkFrame(
                top_window,
                corner_radius=8,
                fg_color=("#ffffff", "#2b2b2b"),
                border_width=2,
                border_color=self._get_status_config(type)["color"]
            )

            # وضع الإشعار فوق شريط الحالة
            notif_frame.place(
                in_=self,
                x=10,
                y=-80,
                width=300,
                height=70
            )

            # محتوى الإشعار
            content_frame = ctk.CTkFrame(notif_frame, fg_color="transparent")
            content_frame.pack(expand=True, padx=15, pady=10)

            # العنوان
            title_label = ctk.CTkLabel(
                content_frame,
                text=title,
                font=ctk.CTkFont(size=13, weight="bold"),
                anchor="w"
            )
            title_label.pack(fill="x")

            # الرسالة
            msg_label = ctk.CTkLabel(
                content_frame,
                text=message,
                font=ctk.CTkFont(size=11),
                anchor="w",
                text_color=("#666666", "#999999")
            )
            msg_label.pack(fill="x")

            # تأثير الظهور
            notif_frame.lift()

            # إخفاء تلقائي بعد 3 ثواني
            if self._is_valid():
                self.after(3000, lambda: self._safe_destroy_notification(notif_frame))

        except Exception as e:
            pass

    def _safe_destroy_notification(self, notification_frame):
        """تدمير آمن للإشعار"""
        try:
            if notification_frame and hasattr(notification_frame, 'winfo_exists'):
                if notification_frame.winfo_exists():
                    notification_frame.destroy()
        except:
            pass

    def update_texts(self, lang_manager: LanguageManager):
        """تحديث نصوص المكون مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            self.lang_manager = lang_manager

            # تحديث النص الافتراضي
            if self.current_status == "" or self.status_type == "info":
                self._safe_configure(self.status_label, text=lang_manager.get("ready", "Ready"))

            # تحديث نص الاتصال
            current_connection_text = ""
            try:
                if hasattr(self.connection_label, 'cget'):
                    current_connection_text = self.connection_label.cget("text")
            except:
                pass

            if "Connected" in current_connection_text or "متصل" in current_connection_text:
                self._safe_configure(
                    self.connection_label,
                    text=lang_manager.get("connected", "Connected")
                )
            elif current_connection_text:  # إذا كان هناك نص
                self._safe_configure(
                    self.connection_label,
                    text=lang_manager.get("disconnected", "Disconnected")
                )
        except Exception as e:
            pass

    def set_user_info(self, username: str, role: str = None):
        """عرض معلومات المستخدم في شريط الحالة"""
        if not self._is_valid():
            return

        try:
            user_text = f"👤 {username}"
            if role:
                user_text += f" ({role})"

            # يمكن إضافة إطار لمعلومات المستخدم إذا لزم الأمر
            pass
        except:
            pass

    def refresh_theme(self):
        """تحديث الثيم عند تغييره مع حماية من الأخطاء"""
        if not self._is_valid():
            return

        try:
            # تحديث الألوان حسب الوضع الجديد
            if self.current_status:
                self.set_status(self.current_status, self.status_type)

            # تحديث ألوان الاتصال
            current_connection_text = ""
            try:
                if hasattr(self.connection_label, 'cget'):
                    current_connection_text = self.connection_label.cget("text")
            except:
                pass

            if self.lang_manager.get("connected", "Connected") in current_connection_text:
                self.set_connection_status(True)
            elif current_connection_text:  # إذا كان هناك نص
                self.set_connection_status(False)
        except Exception as e:
            pass

============================================================
FILE: views\components\toolbar.py
SIZE: 18926 characters
============================================================

# -*- coding: utf-8 -*-
"""
views/components/toolbar.py

شريط الأدوات المحسن بتصميم احترافي
"""

import customtkinter as ctk
from typing import Callable, Optional
from core.language_manager import LanguageManager


class ToolbarComponent(ctk.CTkFrame):
    """شريط الأدوات المحسن بتصميم احترافي"""

    def __init__(
        self,
        parent,
        lang_manager: LanguageManager,
        theme_manager=None,
        on_add=None,
        on_edit=None,
        on_delete=None,
        on_refresh=None,
        on_export=None,
        on_import=None,  # إضافة استيراد
        on_print=None,   # إضافة طباعة
        on_language_toggle=None
    ):
        # إعدادات احترافية للإطار
        super().__init__(parent, height=60, corner_radius=0, fg_color="transparent")

        self.lang_manager = lang_manager
        self.theme_manager = theme_manager
        self.on_add = on_add
        self.on_edit = on_edit
        self.on_delete = on_delete
        self.on_refresh = on_refresh
        self.on_export = on_export
        self.on_import = on_import
        self.on_print = on_print
        self.on_language_toggle = on_language_toggle

        # حالة الأزرار
        self.is_loading = False

        self._build_ui()

    def _build_ui(self):
        """بناء واجهة شريط الأدوات المحسنة"""
        # الحاوية الرئيسية
        main_container = ctk.CTkFrame(
            self,
            corner_radius=10,
            fg_color=("#f8f9fa", "#1e1e1e"),
            border_width=1,
            border_color=("#e0e0e0", "#444444")
        )
        main_container.pack(fill="both", expand=True)

        # إطار الأزرار الرئيسية (يسار)
        left_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        left_frame.pack(side="left", fill="y", padx=10, pady=8)

        # مجموعة أزرار CRUD
        crud_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        crud_frame.pack(side="left", padx=(0, 20))

        # زر الإضافة
        self.add_button = self._create_action_button(
            crud_frame,
            icon="➕",
            text=self.lang_manager.get('add_button', 'Add'),
            command=self.on_add,
            style="primary",
            tooltip=self.lang_manager.get('add_tooltip', 'Add new booking (Ctrl+N)')
        )
        self.add_button.pack(side="left", padx=3)

        # زر التعديل
        self.edit_button = self._create_action_button(
            crud_frame,
            icon="✏️",
            text=self.lang_manager.get('edit_button', 'Edit'),
            command=self.on_edit,
            style="info",
            state="disabled",
            tooltip=self.lang_manager.get('edit_tooltip', 'Edit selected booking (Ctrl+E)')
        )
        self.edit_button.pack(side="left", padx=3)

        # زر الحذف
        self.delete_button = self._create_action_button(
            crud_frame,
            icon="🗑️",
            text=self.lang_manager.get('delete_button', 'Delete'),
            command=self.on_delete,
            style="danger",
            state="disabled",
            tooltip=self.lang_manager.get('delete_tooltip', 'Delete selected bookings (Delete)')
        )
        self.delete_button.pack(side="left", padx=3)

        # خط فاصل
        separator1 = ctk.CTkFrame(
            left_frame,
            width=1,
            fg_color=("#e0e0e0", "#444444")
        )
        separator1.pack(side="left", fill="y", padx=10)

        # مجموعة أزرار العمليات
        operations_frame = ctk.CTkFrame(left_frame, fg_color="transparent")
        operations_frame.pack(side="left")

        # زر التحديث
        self.refresh_button = self._create_action_button(
            operations_frame,
            icon="🔄",
            text=self.lang_manager.get('refresh', 'Refresh'),
            command=self.on_refresh,
            style="secondary",
            tooltip=self.lang_manager.get('refresh_tooltip', 'Refresh data (F5)')
        )
        self.refresh_button.pack(side="left", padx=3)

        # زر التصدير
        self.export_button = self._create_action_button(
            operations_frame,
            icon="📤",
            text=self.lang_manager.get('export', 'Export'),
            command=self.on_export,
            style="secondary",
            tooltip=self.lang_manager.get('export_tooltip', 'Export to Excel (Ctrl+S)')
        )
        self.export_button.pack(side="left", padx=3)

        # زر الاستيراد
        if self.on_import:
            self.import_button = self._create_action_button(
                operations_frame,
                icon="📥",
                text=self.lang_manager.get('import', 'Import'),
                command=self.on_import,
                style="secondary",
                tooltip=self.lang_manager.get('import_tooltip', 'Import from Excel')
            )
            self.import_button.pack(side="left", padx=3)

        # زر الطباعة
        if self.on_print:
            self.print_button = self._create_action_button(
                operations_frame,
                icon="🖨️",
                text=self.lang_manager.get('print', 'Print'),
                command=self.on_print,
                style="secondary",
                tooltip=self.lang_manager.get('print_tooltip', 'Print selected (Ctrl+P)')
            )
            self.print_button.pack(side="left", padx=3)

        # إطار الجانب الأيمن
        right_frame = ctk.CTkFrame(main_container, fg_color="transparent")
        right_frame.pack(side="right", fill="y", padx=10, pady=8)

        # مؤشر التحميل
        self.loading_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        self.loading_frame.pack(side="right", padx=10)

        self.loading_spinner = ctk.CTkLabel(
            self.loading_frame,
            text="",
            font=ctk.CTkFont(size=16)
        )
        self.loading_spinner.pack(side="left", padx=(0, 5))

        self.loading_label = ctk.CTkLabel(
            self.loading_frame,
            text="",
            font=ctk.CTkFont(size=13),
            text_color=("#666666", "#999999")
        )
        self.loading_label.pack(side="left")

        # عداد التحديد
        self.selection_frame = ctk.CTkFrame(right_frame, fg_color="transparent")
        self.selection_frame.pack(side="right", padx=10)

        self.selection_icon = ctk.CTkLabel(
            self.selection_frame,
            text="☑️",
            font=ctk.CTkFont(size=14)
        )

        self.selection_label = ctk.CTkLabel(
            self.selection_frame,
            text="",
            font=ctk.CTkFont(size=13),
            text_color=("#666666", "#999999")
        )

        # زر تبديل اللغة (إذا كان مطلوباً)
        if self.on_language_toggle:
            separator2 = ctk.CTkFrame(
                right_frame,
                width=1,
                fg_color=("#e0e0e0", "#444444")
            )
            separator2.pack(side="right", fill="y", padx=10)

            current_lang = self.lang_manager.current_lang
            button_text = "🌐 EN" if current_lang == "ar" else "🌐 AR"

            self.language_button = self._create_action_button(
                right_frame,
                icon="",
                text=button_text,
                command=self.on_language_toggle,
                style="accent",
                tooltip=self.lang_manager.get('change_language', 'Change Language (Ctrl+L)')
            )
            self.language_button.pack(side="right", padx=3)

    def _create_action_button(self, parent, icon, text, command, style="default", state="normal", tooltip=None):
        """إنشاء زر إجراء احترافي مع تأثيرات"""
        # تحديد الألوان حسب النمط
        colors = self._get_button_colors(style)

        # إطار الزر
        button_frame = ctk.CTkFrame(parent, fg_color="transparent")

        # الزر
        btn = ctk.CTkButton(
            button_frame,
            text=f"{icon} {text}" if icon else text,
            width=120,
            height=40,
            corner_radius=8,
            fg_color=colors["bg"],
            hover_color=colors["hover"],
            text_color=colors["text"],
            font=ctk.CTkFont(size=14, weight="bold"),
            command=command,
            state=state,
            border_width=2,
            border_color=colors["border"]
        )
        btn.pack()

        # تأثيرات hover متقدمة
        def on_enter(e):
            if btn.cget("state") != "disabled":
                btn.configure(border_color=colors["border_hover"])
                # عرض tooltip
                if tooltip and hasattr(self, '_show_tooltip'):
                    self._show_tooltip(btn, tooltip)

        def on_leave(e):
            if btn.cget("state") != "disabled":
                btn.configure(border_color=colors["border"])
                # إخفاء tooltip
                if hasattr(self, '_hide_tooltip'):
                    self._hide_tooltip()

        btn.bind("<Enter>", on_enter)
        btn.bind("<Leave>", on_leave)

        # حفظ مرجع للزر
        button_frame.button = btn

        return button_frame

    def _get_button_colors(self, style):
        """الحصول على ألوان الزر حسب النمط"""
        is_dark = ctk.get_appearance_mode() == "Dark"

        color_schemes = {
            "primary": {
                "bg": ("#4caf50", "#2e7d32"),
                "hover": ("#45a049", "#1b5e20"),
                "text": ("white", "white"),
                "border": ("#4caf50", "#2e7d32"),
                "border_hover": ("#388e3c", "#1b5e20")
            },
            "info": {
                "bg": ("#2196f3", "#1976d2"),
                "hover": ("#1976d2", "#1565c0"),
                "text": ("white", "white"),
                "border": ("#2196f3", "#1976d2"),
                "border_hover": ("#1565c0", "#0d47a1")
            },
            "danger": {
                "bg": ("#f44336", "#d32f2f"),
                "hover": ("#d32f2f", "#c62828"),
                "text": ("white", "white"),
                "border": ("#f44336", "#d32f2f"),
                "border_hover": ("#c62828", "#b71c1c")
            },
            "secondary": {
                "bg": ("#9e9e9e", "#616161"),
                "hover": ("#757575", "#424242"),
                "text": ("white", "white"),
                "border": ("#9e9e9e", "#616161"),
                "border_hover": ("#616161", "#424242")
            },
            "accent": {
                "bg": ("#9c27b0", "#7b1fa2"),
                "hover": ("#7b1fa2", "#6a1b9a"),
                "text": ("white", "white"),
                "border": ("#9c27b0", "#7b1fa2"),
                "border_hover": ("#6a1b9a", "#4a148c")
            },
            "default": {
                "bg": ("#e0e0e0", "#424242"),
                "hover": ("#d5d5d5", "#616161"),
                "text": ("#333333", "#ffffff"),
                "border": ("#e0e0e0", "#424242"),
                "border_hover": ("#bdbdbd", "#616161")
            }
        }

        scheme = color_schemes.get(style, color_schemes["default"])

        return {
            "bg": scheme["bg"][1 if is_dark else 0],
            "hover": scheme["hover"][1 if is_dark else 0],
            "text": scheme["text"][1 if is_dark else 0],
            "border": scheme["border"][1 if is_dark else 0],
            "border_hover": scheme["border_hover"][1 if is_dark else 0]
        }

    def update_selection(self, count: int):
        """تحديث حالة الأزرار وعرض عدد المحدد"""
        # تحديث حالة الأزرار
        if count == 0:
            self.edit_button.button.configure(state="disabled")
            self.delete_button.button.configure(state="disabled")
            # إخفاء عداد التحديد
            self.selection_icon.pack_forget()
            self.selection_label.pack_forget()
        else:
            # عرض عداد التحديد
            self.selection_icon.pack(side="left", padx=(0, 5))
            self.selection_label.pack(side="left")

            if count == 1:
                self.edit_button.button.configure(state="normal")
                self.delete_button.button.configure(state="normal")
                self.selection_label.configure(
                    text=self.lang_manager.get("selected_one", "1 selected")
                )
            else:
                self.edit_button.button.configure(state="disabled")
                self.delete_button.button.configure(state="normal")
                self.selection_label.configure(
                    text=self.lang_manager.get("selected_multiple", f"{count} selected")
                )

    def set_loading(self, is_loading: bool, message: str = None):
        """تعيين حالة التحميل مع رسالة اختيارية"""
        self.is_loading = is_loading

        if is_loading:
            # عرض مؤشر التحميل
            self.loading_spinner.configure(text="⟳")
            self.loading_label.configure(
                text=message or self.lang_manager.get("loading", "Loading...")
            )

            # تدوير المؤشر
            self._animate_spinner()

            # تعطيل زر التحديث
            self.refresh_button.button.configure(state="disabled")
        else:
            # إخفاء مؤشر التحميل
            self.loading_spinner.configure(text="")
            self.loading_label.configure(text="")

            # تفعيل زر التحديث
            self.refresh_button.button.configure(state="normal")

    def _animate_spinner(self):
        """تحريك مؤشر التحميل"""
        if self.is_loading:
            current = self.loading_spinner.cget("text")
            # دوران المؤشر
            spinners = ["⟳", "⟲", "⟱", "⟰"]
            try:
                idx = spinners.index(current)
                next_idx = (idx + 1) % len(spinners)
                self.loading_spinner.configure(text=spinners[next_idx])
            except:
                self.loading_spinner.configure(text=spinners[0])

            # جدولة الإطار التالي
            self.after(200, self._animate_spinner)

    def update_texts(self, lang_manager):
        """تحديث نصوص المكون"""
        self.lang_manager = lang_manager

        # تحديث نصوص الأزرار
        button_updates = [
            (self.add_button, 'add_button', 'Add', '➕'),
            (self.edit_button, 'edit_button', 'Edit', '✏️'),
            (self.delete_button, 'delete_button', 'Delete', '🗑️'),
            (self.refresh_button, 'refresh', 'Refresh', '🔄'),
            (self.export_button, 'export', 'Export', '📤')
        ]

        for button_frame, key, default, icon in button_updates:
            if hasattr(button_frame, 'button'):
                text = lang_manager.get(key, default)
                button_frame.button.configure(text=f"{icon} {text}")

        # تحديث الأزرار الاختيارية
        if hasattr(self, 'import_button'):
            self.import_button.button.configure(
                text=f"📥 {lang_manager.get('import', 'Import')}"
            )

        if hasattr(self, 'print_button'):
            self.print_button.button.configure(
                text=f"🖨️ {lang_manager.get('print', 'Print')}"
            )

        # تحديث زر اللغة
        if hasattr(self, 'language_button'):
            current_lang = lang_manager.current_lang
            button_text = "🌐 EN" if current_lang == "ar" else "🌐 AR"
            self.language_button.button.configure(text=button_text)

        # تحديث نص التحميل إذا كان ظاهراً
        if self.is_loading:
            self.loading_label.configure(
                text=lang_manager.get("loading", "Loading...")
            )

        # تحديث عداد التحديد إذا كان ظاهراً
        if hasattr(self, 'selection_label'):
            current_text = self.selection_label.cget("text")
            if current_text:
                # استخراج العدد من النص الحالي
                try:
                    count = int(''.join(filter(str.isdigit, current_text)))
                    if count == 1:
                        self.selection_label.configure(
                            text=lang_manager.get("selected_one", "1 selected")
                        )
                    else:
                        self.selection_label.configure(
                            text=lang_manager.get("selected_multiple", f"{count} selected")
                        )
                except:
                    pass

    def refresh_theme(self):
        """تحديث الثيم عند تغييره"""
        # تحديث ألوان الإطار الرئيسي
        main_container = self.winfo_children()[0] if self.winfo_children() else None
        if main_container and isinstance(main_container, ctk.CTkFrame):
            main_container.configure(
                fg_color=("#f8f9fa", "#1e1e1e"),
                border_color=("#e0e0e0", "#444444")
            )

        # تحديث ألوان الأزرار
        self._update_button_colors()

        # إعادة تحديد حالة التحميل إذا كانت نشطة
        if self.is_loading:
            current_text = self.loading_label.cget("text")
            self.set_loading(True, current_text)

    def _update_button_colors(self):
        """تحديث ألوان الأزرار حسب الثيم الجديد"""
        # قائمة الأزرار مع أنماطها
        button_configs = [
            (self.add_button, "primary"),
            (self.edit_button, "info"),
            (self.delete_button, "danger"),
            (self.refresh_button, "secondary"),
            (self.export_button, "secondary")
        ]

        # إضافة الأزرار الاختيارية إذا كانت موجودة
        if hasattr(self, 'import_button'):
            button_configs.append((self.import_button, "secondary"))
        if hasattr(self, 'print_button'):
            button_configs.append((self.print_button, "secondary"))
        if hasattr(self, 'language_button'):
            button_configs.append((self.language_button, "accent"))

        # تحديث كل زر
        for button_frame, style in button_configs:
            if hasattr(button_frame, 'button'):
                colors = self._get_button_colors(style)
                button_frame.button.configure(
                    fg_color=colors["bg"],
                    hover_color=colors["hover"],
                    text_color=colors["text"],
                    border_color=colors["border"]
                )

    def show_success_feedback(self, message: str):
        """عرض رسالة نجاح مؤقتة"""
        # يمكن إضافة منطق لعرض رسالة نجاح مؤقتة
        pass

    def show_error_feedback(self, message: str):
        """عرض رسالة خطأ مؤقتة"""
        # يمكن إضافة منطق لعرض رسالة خطأ مؤقتة
        pass


# للتوافق مع الكود القديم
class Toolbar(ToolbarComponent):
    """صنف بديل للتوافق مع الأكواد القديمة"""
    pass

================================================================================
EXPORT SUMMARY
================================================================================
Total files read: 55
Errors encountered: 0
Export date: 2025-07-03 04:28:57
